#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Jun 24 16:39:08 2021 by generateDS.py version 2.28a.
#
# Command line options:
#   ('--no-warnings', '')
#   ('--export', 'write literal etree')
#   ('--super', 'pmml44Super')
#   ('--subclass-suffix', '')
#   ('-o', 'pmml44Super.py')
#   ('-s', 'pmml44.py')
#   ('-b', 'behaviorsDir.xml')
#   ('-f', '')
#
# Command line arguments:
#   ..\pmml44.xsd
#
# Command line:
#   C:\Users\NIBO\OneDrive - Software AG\projects\New folder\nyoka\nyoka\PMML44\gds_local.py --no-warnings --export="write literal etree" --super="pmml44Super" --subclass-suffix -o "pmml44Super.py" -s "pmml44.py" -b "behaviorsDir.xml" -f ..\pmml44.xsd
#
# Current working directory (os.getcwd()):
#   PMML44
#

"""
 Copyright (c) 2004-2016 Zementis, Inc.
 Copyright (c) 2016-2021 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its

 SPDX-License-Identifier: Apache-2.0

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
"""

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser(huge_tree=True)
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(str(i) for i in input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(str(i) for i in input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(str(i) for i in input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(str(i) for i in input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class DefineFunction(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, optype=None, dataType=None, Extension=None, ParameterField=None, FieldRef=None, Apply=None, Constant=None, NormContinuous=None, NormDiscrete=None, Discretize=None, MapValues=None, TextIndex=None, Aggregate=None, Lag=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.optype = _cast(None, optype)
        self.dataType = _cast(None, dataType)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if ParameterField is None:
            self.ParameterField = []
        else:
            self.ParameterField = ParameterField
        self.FieldRef = FieldRef
        self.Apply = Apply
        self.Constant = Constant
        self.NormContinuous = NormContinuous
        self.NormDiscrete = NormDiscrete
        self.Discretize = Discretize
        self.MapValues = MapValues
        self.TextIndex = TextIndex
        self.Aggregate = Aggregate
        self.Lag = Lag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DefineFunction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DefineFunction.subclass:
            return DefineFunction.subclass(*args_, **kwargs_)
        else:
            return DefineFunction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_ParameterField(self): return self.ParameterField
    def set_ParameterField(self, ParameterField): self.ParameterField = ParameterField
    def add_ParameterField(self, value): self.ParameterField.append(value)
    def insert_ParameterField_at(self, index, value): self.ParameterField.insert(index, value)
    def replace_ParameterField_at(self, index, value): self.ParameterField[index] = value
    def get_FieldRef(self): return self.FieldRef
    def set_FieldRef(self, FieldRef): self.FieldRef = FieldRef
    def get_Apply(self): return self.Apply
    def set_Apply(self, Apply): self.Apply = Apply
    def get_Constant(self): return self.Constant
    def set_Constant(self, Constant): self.Constant = Constant
    def get_NormContinuous(self): return self.NormContinuous
    def set_NormContinuous(self, NormContinuous): self.NormContinuous = NormContinuous
    def get_NormDiscrete(self): return self.NormDiscrete
    def set_NormDiscrete(self, NormDiscrete): self.NormDiscrete = NormDiscrete
    def get_Discretize(self): return self.Discretize
    def set_Discretize(self, Discretize): self.Discretize = Discretize
    def get_MapValues(self): return self.MapValues
    def set_MapValues(self, MapValues): self.MapValues = MapValues
    def get_TextIndex(self): return self.TextIndex
    def set_TextIndex(self, TextIndex): self.TextIndex = TextIndex
    def get_Aggregate(self): return self.Aggregate
    def set_Aggregate(self, Aggregate): self.Aggregate = Aggregate
    def get_Lag(self): return self.Lag
    def set_Lag(self, Lag): self.Lag = Lag
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_optype(self): return self.optype
    def set_optype(self, optype): self.optype = optype
    def get_dataType(self): return self.dataType
    def set_dataType(self, dataType): self.dataType = dataType
    def validate_OPTYPE(self, value):
        # Validate type OPTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['categorical', 'ordinal', 'continuous']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OPTYPE' % {"value" : value.encode("utf-8")} )
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DATATYPE' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Extension or
            self.ParameterField or
            self.FieldRef is not None or
            self.Apply is not None or
            self.Constant is not None or
            self.NormContinuous is not None or
            self.NormDiscrete is not None or
            self.Discretize is not None or
            self.MapValues is not None or
            self.TextIndex is not None or
            self.Aggregate is not None or
            self.Lag is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DefineFunction', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DefineFunction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefineFunction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DefineFunction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DefineFunction'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            outfile.write(' optype=%s' % (quote_attrib(self.optype), ))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (quote_attrib(self.dataType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DefineFunction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for ParameterField_ in self.ParameterField:
            ParameterField_.export(outfile, level, namespace_, name_='ParameterField', pretty_print=pretty_print)
        if self.FieldRef is not None:
            self.FieldRef.export(outfile, level, namespace_, name_='FieldRef', pretty_print=pretty_print)
        if self.Apply is not None:
            self.Apply.export(outfile, level, namespace_, name_='Apply', pretty_print=pretty_print)
        if self.Constant is not None:
            self.Constant.export(outfile, level, namespace_, name_='Constant', pretty_print=pretty_print)
        if self.NormContinuous is not None:
            self.NormContinuous.export(outfile, level, namespace_, name_='NormContinuous', pretty_print=pretty_print)
        if self.NormDiscrete is not None:
            self.NormDiscrete.export(outfile, level, namespace_, name_='NormDiscrete', pretty_print=pretty_print)
        if self.Discretize is not None:
            self.Discretize.export(outfile, level, namespace_, name_='Discretize', pretty_print=pretty_print)
        if self.MapValues is not None:
            self.MapValues.export(outfile, level, namespace_, name_='MapValues', pretty_print=pretty_print)
        if self.TextIndex is not None:
            self.TextIndex.export(outfile, level, namespace_, name_='TextIndex', pretty_print=pretty_print)
        if self.Aggregate is not None:
            self.Aggregate.export(outfile, level, namespace_, name_='Aggregate', pretty_print=pretty_print)
        if self.Lag is not None:
            self.Lag.export(outfile, level, namespace_, name_='Lag', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DefineFunction', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.optype is not None:
            element.set('optype', self.optype)
        if self.dataType is not None:
            element.set('dataType', self.dataType)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for ParameterField_ in self.ParameterField:
            ParameterField_.to_etree(element, name_='ParameterField', mapping_=mapping_)
        if self.FieldRef is not None:
            FieldRef_ = self.FieldRef
            FieldRef_.to_etree(element, name_='FieldRef', mapping_=mapping_)
        if self.Apply is not None:
            Apply_ = self.Apply
            Apply_.to_etree(element, name_='Apply', mapping_=mapping_)
        if self.Constant is not None:
            Constant_ = self.Constant
            Constant_.to_etree(element, name_='Constant', mapping_=mapping_)
        if self.NormContinuous is not None:
            NormContinuous_ = self.NormContinuous
            NormContinuous_.to_etree(element, name_='NormContinuous', mapping_=mapping_)
        if self.NormDiscrete is not None:
            NormDiscrete_ = self.NormDiscrete
            NormDiscrete_.to_etree(element, name_='NormDiscrete', mapping_=mapping_)
        if self.Discretize is not None:
            Discretize_ = self.Discretize
            Discretize_.to_etree(element, name_='Discretize', mapping_=mapping_)
        if self.MapValues is not None:
            MapValues_ = self.MapValues
            MapValues_.to_etree(element, name_='MapValues', mapping_=mapping_)
        if self.TextIndex is not None:
            TextIndex_ = self.TextIndex
            TextIndex_.to_etree(element, name_='TextIndex', mapping_=mapping_)
        if self.Aggregate is not None:
            Aggregate_ = self.Aggregate
            Aggregate_.to_etree(element, name_='Aggregate', mapping_=mapping_)
        if self.Lag is not None:
            Lag_ = self.Lag
            Lag_.to_etree(element, name_='Lag', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DefineFunction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            showIndent(outfile, level)
            outfile.write('optype="%s",\n' % (self.optype,))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            showIndent(outfile, level)
            outfile.write('dataType="%s",\n' % (self.dataType,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ParameterField=[\n')
        level += 1
        for ParameterField_ in self.ParameterField:
            showIndent(outfile, level)
            outfile.write('model_.ParameterField(\n')
            ParameterField_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.FieldRef is not None:
            showIndent(outfile, level)
            outfile.write('FieldRef=model_.FieldRef(\n')
            self.FieldRef.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Apply is not None:
            showIndent(outfile, level)
            outfile.write('Apply=model_.Apply(\n')
            self.Apply.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Constant is not None:
            showIndent(outfile, level)
            outfile.write('Constant=model_.Constant(\n')
            self.Constant.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormContinuous is not None:
            showIndent(outfile, level)
            outfile.write('NormContinuous=model_.NormContinuous(\n')
            self.NormContinuous.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormDiscrete is not None:
            showIndent(outfile, level)
            outfile.write('NormDiscrete=model_.NormDiscrete(\n')
            self.NormDiscrete.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Discretize is not None:
            showIndent(outfile, level)
            outfile.write('Discretize=model_.Discretize(\n')
            self.Discretize.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MapValues is not None:
            showIndent(outfile, level)
            outfile.write('MapValues=model_.MapValues(\n')
            self.MapValues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextIndex is not None:
            showIndent(outfile, level)
            outfile.write('TextIndex=model_.TextIndex(\n')
            self.TextIndex.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Aggregate is not None:
            showIndent(outfile, level)
            outfile.write('Aggregate=model_.Aggregate(\n')
            self.Aggregate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Lag is not None:
            showIndent(outfile, level)
            outfile.write('Lag=model_.Lag(\n')
            self.Lag.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('optype', node)
        if value is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            self.optype = value
            self.validate_OPTYPE(self.optype)    # validate type OPTYPE
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ParameterField':
            obj_ = ParameterField.factory()
            obj_.build(child_)
            self.ParameterField.append(obj_)
            obj_.original_tagname_ = 'ParameterField'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory()
            obj_.build(child_)
            self.FieldRef = obj_
            obj_.original_tagname_ = 'FieldRef'
        elif nodeName_ == 'Apply':
            obj_ = Apply.factory()
            obj_.build(child_)
            self.Apply = obj_
            obj_.original_tagname_ = 'Apply'
        elif nodeName_ == 'Constant':
            obj_ = Constant.factory()
            obj_.build(child_)
            self.Constant = obj_
            obj_.original_tagname_ = 'Constant'
        elif nodeName_ == 'NormContinuous':
            obj_ = NormContinuous.factory()
            obj_.build(child_)
            self.NormContinuous = obj_
            obj_.original_tagname_ = 'NormContinuous'
        elif nodeName_ == 'NormDiscrete':
            obj_ = NormDiscrete.factory()
            obj_.build(child_)
            self.NormDiscrete = obj_
            obj_.original_tagname_ = 'NormDiscrete'
        elif nodeName_ == 'Discretize':
            obj_ = Discretize.factory()
            obj_.build(child_)
            self.Discretize = obj_
            obj_.original_tagname_ = 'Discretize'
        elif nodeName_ == 'MapValues':
            obj_ = MapValues.factory()
            obj_.build(child_)
            self.MapValues = obj_
            obj_.original_tagname_ = 'MapValues'
        elif nodeName_ == 'TextIndex':
            obj_ = TextIndex.factory()
            obj_.build(child_)
            self.TextIndex = obj_
            obj_.original_tagname_ = 'TextIndex'
        elif nodeName_ == 'Aggregate':
            obj_ = Aggregate.factory()
            obj_.build(child_)
            self.Aggregate = obj_
            obj_.original_tagname_ = 'Aggregate'
        elif nodeName_ == 'Lag':
            obj_ = Lag.factory()
            obj_.build(child_)
            self.Lag = obj_
            obj_.original_tagname_ = 'Lag'
# end class DefineFunction


class ParameterField(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, optype=None, dataType=None, displayName=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.optype = _cast(None, optype)
        self.dataType = _cast(None, dataType)
        self.displayName = _cast(None, displayName)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterField.subclass:
            return ParameterField.subclass(*args_, **kwargs_)
        else:
            return ParameterField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_optype(self): return self.optype
    def set_optype(self, optype): self.optype = optype
    def get_dataType(self): return self.dataType
    def set_dataType(self, dataType): self.dataType = dataType
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_OPTYPE(self, value):
        # Validate type OPTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['categorical', 'ordinal', 'continuous']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OPTYPE' % {"value" : value.encode("utf-8")} )
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DATATYPE' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ParameterField', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParameterField')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ParameterField', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParameterField'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            outfile.write(' optype=%s' % (quote_attrib(self.optype), ))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (quote_attrib(self.dataType), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ParameterField', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='ParameterField', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.name)
        if self.optype is not None:
            element.set('optype', self.optype)
        if self.dataType is not None:
            element.set('dataType', self.dataType)
        if self.displayName is not None:
            element.set('displayName', self.gds_format_string(self.displayName))
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ParameterField'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            showIndent(outfile, level)
            outfile.write('optype="%s",\n' % (self.optype,))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            showIndent(outfile, level)
            outfile.write('dataType="%s",\n' % (self.dataType,))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            showIndent(outfile, level)
            outfile.write('displayName="%s",\n' % (self.displayName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('optype', node)
        if value is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            self.optype = value
            self.validate_OPTYPE(self.optype)    # validate type OPTYPE
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ParameterField


class Apply(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, function=None, mapMissingTo=None, defaultValue=None, invalidValueTreatment='returnInvalid', Extension=None, FieldRef=None, Apply_member=None, Constant=None, NormContinuous=None, NormDiscrete=None, Discretize=None, MapValues=None, TextIndex=None, Aggregate=None, Lag=None):
        self.original_tagname_ = None
        self.function = _cast(None, function)
        self.mapMissingTo = _cast(None, mapMissingTo)
        self.defaultValue = _cast(None, defaultValue)
        self.invalidValueTreatment = _cast(None, invalidValueTreatment)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if FieldRef is None:
            self.FieldRef = []
        else:
            self.FieldRef = FieldRef
        if Apply_member is None:
            self.Apply = []
        else:
            self.Apply = Apply_member
        if Constant is None:
            self.Constant = []
        else:
            self.Constant = Constant
        if NormContinuous is None:
            self.NormContinuous = []
        else:
            self.NormContinuous = NormContinuous
        if NormDiscrete is None:
            self.NormDiscrete = []
        else:
            self.NormDiscrete = NormDiscrete
        if Discretize is None:
            self.Discretize = []
        else:
            self.Discretize = Discretize
        if MapValues is None:
            self.MapValues = []
        else:
            self.MapValues = MapValues
        if TextIndex is None:
            self.TextIndex = []
        else:
            self.TextIndex = TextIndex
        if Aggregate is None:
            self.Aggregate = []
        else:
            self.Aggregate = Aggregate
        if Lag is None:
            self.Lag = []
        else:
            self.Lag = Lag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Apply)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Apply.subclass:
            return Apply.subclass(*args_, **kwargs_)
        else:
            return Apply(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_FieldRef(self): return self.FieldRef
    def set_FieldRef(self, FieldRef): self.FieldRef = FieldRef
    def add_FieldRef(self, value): self.FieldRef.append(value)
    def insert_FieldRef_at(self, index, value): self.FieldRef.insert(index, value)
    def replace_FieldRef_at(self, index, value): self.FieldRef[index] = value
    def get_Apply(self): return self.Apply
    def set_Apply(self, Apply): self.Apply = Apply
    def add_Apply(self, value): self.Apply.append(value)
    def insert_Apply_at(self, index, value): self.Apply.insert(index, value)
    def replace_Apply_at(self, index, value): self.Apply[index] = value
    def get_Constant(self): return self.Constant
    def set_Constant(self, Constant): self.Constant = Constant
    def add_Constant(self, value): self.Constant.append(value)
    def insert_Constant_at(self, index, value): self.Constant.insert(index, value)
    def replace_Constant_at(self, index, value): self.Constant[index] = value
    def get_NormContinuous(self): return self.NormContinuous
    def set_NormContinuous(self, NormContinuous): self.NormContinuous = NormContinuous
    def add_NormContinuous(self, value): self.NormContinuous.append(value)
    def insert_NormContinuous_at(self, index, value): self.NormContinuous.insert(index, value)
    def replace_NormContinuous_at(self, index, value): self.NormContinuous[index] = value
    def get_NormDiscrete(self): return self.NormDiscrete
    def set_NormDiscrete(self, NormDiscrete): self.NormDiscrete = NormDiscrete
    def add_NormDiscrete(self, value): self.NormDiscrete.append(value)
    def insert_NormDiscrete_at(self, index, value): self.NormDiscrete.insert(index, value)
    def replace_NormDiscrete_at(self, index, value): self.NormDiscrete[index] = value
    def get_Discretize(self): return self.Discretize
    def set_Discretize(self, Discretize): self.Discretize = Discretize
    def add_Discretize(self, value): self.Discretize.append(value)
    def insert_Discretize_at(self, index, value): self.Discretize.insert(index, value)
    def replace_Discretize_at(self, index, value): self.Discretize[index] = value
    def get_MapValues(self): return self.MapValues
    def set_MapValues(self, MapValues): self.MapValues = MapValues
    def add_MapValues(self, value): self.MapValues.append(value)
    def insert_MapValues_at(self, index, value): self.MapValues.insert(index, value)
    def replace_MapValues_at(self, index, value): self.MapValues[index] = value
    def get_TextIndex(self): return self.TextIndex
    def set_TextIndex(self, TextIndex): self.TextIndex = TextIndex
    def add_TextIndex(self, value): self.TextIndex.append(value)
    def insert_TextIndex_at(self, index, value): self.TextIndex.insert(index, value)
    def replace_TextIndex_at(self, index, value): self.TextIndex[index] = value
    def get_Aggregate(self): return self.Aggregate
    def set_Aggregate(self, Aggregate): self.Aggregate = Aggregate
    def add_Aggregate(self, value): self.Aggregate.append(value)
    def insert_Aggregate_at(self, index, value): self.Aggregate.insert(index, value)
    def replace_Aggregate_at(self, index, value): self.Aggregate[index] = value
    def get_Lag(self): return self.Lag
    def set_Lag(self, Lag): self.Lag = Lag
    def add_Lag(self, value): self.Lag.append(value)
    def insert_Lag_at(self, index, value): self.Lag.insert(index, value)
    def replace_Lag_at(self, index, value): self.Lag[index] = value
    def get_function(self): return self.function
    def set_function(self, function): self.function = function
    def get_mapMissingTo(self): return self.mapMissingTo
    def set_mapMissingTo(self, mapMissingTo): self.mapMissingTo = mapMissingTo
    def get_defaultValue(self): return self.defaultValue
    def set_defaultValue(self, defaultValue): self.defaultValue = defaultValue
    def get_invalidValueTreatment(self): return self.invalidValueTreatment
    def set_invalidValueTreatment(self, invalidValueTreatment): self.invalidValueTreatment = invalidValueTreatment
    def validate_INVALID_VALUE_TREATMENT_METHOD(self, value):
        # Validate type INVALID-VALUE-TREATMENT-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['returnInvalid', 'asIs', 'asMissing', 'asValue']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on INVALID-VALUE-TREATMENT-METHOD' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Extension or
            self.FieldRef or
            self.Apply or
            self.Constant or
            self.NormContinuous or
            self.NormDiscrete or
            self.Discretize or
            self.MapValues or
            self.TextIndex or
            self.Aggregate or
            self.Lag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Apply', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Apply')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Apply')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Apply', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Apply'):
        if self.function is not None and 'function' not in already_processed:
            already_processed.add('function')
            outfile.write(' function=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.function), input_name='function')), ))
        if self.mapMissingTo is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            outfile.write(' mapMissingTo=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mapMissingTo), input_name='mapMissingTo')), ))
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            outfile.write(' defaultValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.defaultValue), input_name='defaultValue')), ))
        if self.invalidValueTreatment != "returnInvalid" and 'invalidValueTreatment' not in already_processed:
            already_processed.add('invalidValueTreatment')
            outfile.write(' invalidValueTreatment=%s' % (quote_attrib(self.invalidValueTreatment), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Apply', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for FieldRef_ in self.FieldRef:
            FieldRef_.export(outfile, level, namespace_, name_='FieldRef', pretty_print=pretty_print)
        for Apply_ in self.Apply:
            Apply_.export(outfile, level, namespace_, name_='Apply', pretty_print=pretty_print)
        for Constant_ in self.Constant:
            Constant_.export(outfile, level, namespace_, name_='Constant', pretty_print=pretty_print)
        for NormContinuous_ in self.NormContinuous:
            NormContinuous_.export(outfile, level, namespace_, name_='NormContinuous', pretty_print=pretty_print)
        for NormDiscrete_ in self.NormDiscrete:
            NormDiscrete_.export(outfile, level, namespace_, name_='NormDiscrete', pretty_print=pretty_print)
        for Discretize_ in self.Discretize:
            Discretize_.export(outfile, level, namespace_, name_='Discretize', pretty_print=pretty_print)
        for MapValues_ in self.MapValues:
            MapValues_.export(outfile, level, namespace_, name_='MapValues', pretty_print=pretty_print)
        for TextIndex_ in self.TextIndex:
            TextIndex_.export(outfile, level, namespace_, name_='TextIndex', pretty_print=pretty_print)
        for Aggregate_ in self.Aggregate:
            Aggregate_.export(outfile, level, namespace_, name_='Aggregate', pretty_print=pretty_print)
        for Lag_ in self.Lag:
            Lag_.export(outfile, level, namespace_, name_='Lag', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Apply', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.function is not None:
            element.set('function', self.gds_format_string(self.function))
        if self.mapMissingTo is not None:
            element.set('mapMissingTo', self.gds_format_string(self.mapMissingTo))
        if self.defaultValue is not None:
            element.set('defaultValue', self.gds_format_string(self.defaultValue))
        if self.invalidValueTreatment is not None:
            element.set('invalidValueTreatment', self.invalidValueTreatment)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for FieldRef_ in self.FieldRef:
            FieldRef_.to_etree(element, name_='FieldRef', mapping_=mapping_)
        for Apply_ in self.Apply:
            Apply_.to_etree(element, name_='Apply', mapping_=mapping_)
        for Constant_ in self.Constant:
            Constant_.to_etree(element, name_='Constant', mapping_=mapping_)
        for NormContinuous_ in self.NormContinuous:
            NormContinuous_.to_etree(element, name_='NormContinuous', mapping_=mapping_)
        for NormDiscrete_ in self.NormDiscrete:
            NormDiscrete_.to_etree(element, name_='NormDiscrete', mapping_=mapping_)
        for Discretize_ in self.Discretize:
            Discretize_.to_etree(element, name_='Discretize', mapping_=mapping_)
        for MapValues_ in self.MapValues:
            MapValues_.to_etree(element, name_='MapValues', mapping_=mapping_)
        for TextIndex_ in self.TextIndex:
            TextIndex_.to_etree(element, name_='TextIndex', mapping_=mapping_)
        for Aggregate_ in self.Aggregate:
            Aggregate_.to_etree(element, name_='Aggregate', mapping_=mapping_)
        for Lag_ in self.Lag:
            Lag_.to_etree(element, name_='Lag', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Apply'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.function is not None and 'function' not in already_processed:
            already_processed.add('function')
            showIndent(outfile, level)
            outfile.write('function="%s",\n' % (self.function,))
        if self.mapMissingTo is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            showIndent(outfile, level)
            outfile.write('mapMissingTo="%s",\n' % (self.mapMissingTo,))
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            showIndent(outfile, level)
            outfile.write('defaultValue="%s",\n' % (self.defaultValue,))
        if self.invalidValueTreatment is not None and 'invalidValueTreatment' not in already_processed:
            already_processed.add('invalidValueTreatment')
            showIndent(outfile, level)
            outfile.write('invalidValueTreatment="%s",\n' % (self.invalidValueTreatment,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FieldRef=[\n')
        level += 1
        for FieldRef_ in self.FieldRef:
            showIndent(outfile, level)
            outfile.write('model_.FieldRef(\n')
            FieldRef_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Apply=[\n')
        level += 1
        for Apply_ in self.Apply:
            showIndent(outfile, level)
            outfile.write('model_.Apply(\n')
            Apply_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Constant=[\n')
        level += 1
        for Constant_ in self.Constant:
            showIndent(outfile, level)
            outfile.write('model_.Constant(\n')
            Constant_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NormContinuous=[\n')
        level += 1
        for NormContinuous_ in self.NormContinuous:
            showIndent(outfile, level)
            outfile.write('model_.NormContinuous(\n')
            NormContinuous_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NormDiscrete=[\n')
        level += 1
        for NormDiscrete_ in self.NormDiscrete:
            showIndent(outfile, level)
            outfile.write('model_.NormDiscrete(\n')
            NormDiscrete_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Discretize=[\n')
        level += 1
        for Discretize_ in self.Discretize:
            showIndent(outfile, level)
            outfile.write('model_.Discretize(\n')
            Discretize_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MapValues=[\n')
        level += 1
        for MapValues_ in self.MapValues:
            showIndent(outfile, level)
            outfile.write('model_.MapValues(\n')
            MapValues_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TextIndex=[\n')
        level += 1
        for TextIndex_ in self.TextIndex:
            showIndent(outfile, level)
            outfile.write('model_.TextIndex(\n')
            TextIndex_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Aggregate=[\n')
        level += 1
        for Aggregate_ in self.Aggregate:
            showIndent(outfile, level)
            outfile.write('model_.Aggregate(\n')
            Aggregate_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Lag=[\n')
        level += 1
        for Lag_ in self.Lag:
            showIndent(outfile, level)
            outfile.write('model_.Lag(\n')
            Lag_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('function', node)
        if value is not None and 'function' not in already_processed:
            already_processed.add('function')
            self.function = value
        value = find_attr_value_('mapMissingTo', node)
        if value is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            self.mapMissingTo = value
        value = find_attr_value_('defaultValue', node)
        if value is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            self.defaultValue = value
        value = find_attr_value_('invalidValueTreatment', node)
        if value is not None and 'invalidValueTreatment' not in already_processed:
            already_processed.add('invalidValueTreatment')
            self.invalidValueTreatment = value
            self.validate_INVALID_VALUE_TREATMENT_METHOD(self.invalidValueTreatment)    # validate type INVALID-VALUE-TREATMENT-METHOD
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory()
            obj_.build(child_)
            self.FieldRef.append(obj_)
            obj_.original_tagname_ = 'FieldRef'
        elif nodeName_ == 'Apply':
            obj_ = Apply.factory()
            obj_.build(child_)
            self.Apply.append(obj_)
            obj_.original_tagname_ = 'Apply'
        elif nodeName_ == 'Constant':
            obj_ = Constant.factory()
            obj_.build(child_)
            self.Constant.append(obj_)
            obj_.original_tagname_ = 'Constant'
        elif nodeName_ == 'NormContinuous':
            obj_ = NormContinuous.factory()
            obj_.build(child_)
            self.NormContinuous.append(obj_)
            obj_.original_tagname_ = 'NormContinuous'
        elif nodeName_ == 'NormDiscrete':
            obj_ = NormDiscrete.factory()
            obj_.build(child_)
            self.NormDiscrete.append(obj_)
            obj_.original_tagname_ = 'NormDiscrete'
        elif nodeName_ == 'Discretize':
            obj_ = Discretize.factory()
            obj_.build(child_)
            self.Discretize.append(obj_)
            obj_.original_tagname_ = 'Discretize'
        elif nodeName_ == 'MapValues':
            obj_ = MapValues.factory()
            obj_.build(child_)
            self.MapValues.append(obj_)
            obj_.original_tagname_ = 'MapValues'
        elif nodeName_ == 'TextIndex':
            obj_ = TextIndex.factory()
            obj_.build(child_)
            self.TextIndex.append(obj_)
            obj_.original_tagname_ = 'TextIndex'
        elif nodeName_ == 'Aggregate':
            obj_ = Aggregate.factory()
            obj_.build(child_)
            self.Aggregate.append(obj_)
            obj_.original_tagname_ = 'Aggregate'
        elif nodeName_ == 'Lag':
            obj_ = Lag.factory()
            obj_.build(child_)
            self.Lag.append(obj_)
            obj_.original_tagname_ = 'Lag'
# end class Apply


class MiningModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, isScorable=True, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, Regression=None, DecisionTree=None, Segmentation=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.ModelExplanation = ModelExplanation
        self.Targets = Targets
        self.LocalTransformations = LocalTransformations
        if Regression is None:
            self.Regression = []
        else:
            self.Regression = Regression
        if DecisionTree is None:
            self.DecisionTree = []
        else:
            self.DecisionTree = DecisionTree
        self.Segmentation = Segmentation
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MiningModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MiningModel.subclass:
            return MiningModel.subclass(*args_, **kwargs_)
        else:
            return MiningModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_ModelExplanation(self): return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation): self.ModelExplanation = ModelExplanation
    def get_Targets(self): return self.Targets
    def set_Targets(self, Targets): self.Targets = Targets
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_Regression(self): return self.Regression
    def set_Regression(self, Regression): self.Regression = Regression
    def add_Regression(self, value): self.Regression.append(value)
    def insert_Regression_at(self, index, value): self.Regression.insert(index, value)
    def replace_Regression_at(self, index, value): self.Regression[index] = value
    def get_DecisionTree(self): return self.DecisionTree
    def set_DecisionTree(self, DecisionTree): self.DecisionTree = DecisionTree
    def add_DecisionTree(self, value): self.DecisionTree.append(value)
    def insert_DecisionTree_at(self, index, value): self.DecisionTree.insert(index, value)
    def replace_DecisionTree_at(self, index, value): self.DecisionTree[index] = value
    def get_Segmentation(self): return self.Segmentation
    def set_Segmentation(self, Segmentation): self.Segmentation = Segmentation
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.Regression or
            self.DecisionTree or
            self.Segmentation is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MiningModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MiningModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MiningModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MiningModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MiningModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='MiningModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            self.ModelExplanation.export(outfile, level, namespace_, name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            self.Targets.export(outfile, level, namespace_, name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        for Regression_ in self.Regression:
            Regression_.export(outfile, level, namespace_, name_='Regression', pretty_print=pretty_print)
        for DecisionTree_ in self.DecisionTree:
            DecisionTree_.export(outfile, level, namespace_, name_='DecisionTree', pretty_print=pretty_print)
        if self.Segmentation is not None:
            self.Segmentation.export(outfile, level, namespace_, name_='Segmentation', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MiningModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.ModelExplanation is not None:
            ModelExplanation_ = self.ModelExplanation
            ModelExplanation_.to_etree(element, name_='ModelExplanation', mapping_=mapping_)
        if self.Targets is not None:
            Targets_ = self.Targets
            Targets_.to_etree(element, name_='Targets', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        for Regression_ in self.Regression:
            Regression_.to_etree(element, name_='Regression', mapping_=mapping_)
        for DecisionTree_ in self.DecisionTree:
            DecisionTree_.to_etree(element, name_='DecisionTree', mapping_=mapping_)
        if self.Segmentation is not None:
            Segmentation_ = self.Segmentation
            Segmentation_.to_etree(element, name_='Segmentation', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MiningModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelExplanation is not None:
            showIndent(outfile, level)
            outfile.write('ModelExplanation=model_.ModelExplanation(\n')
            self.ModelExplanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targets is not None:
            showIndent(outfile, level)
            outfile.write('Targets=model_.Targets(\n')
            self.Targets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Regression=[\n')
        level += 1
        for Regression_ in self.Regression:
            showIndent(outfile, level)
            outfile.write('model_.Regression(\n')
            Regression_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DecisionTree=[\n')
        level += 1
        for DecisionTree_ in self.DecisionTree:
            showIndent(outfile, level)
            outfile.write('model_.DecisionTree(\n')
            DecisionTree_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Segmentation is not None:
            showIndent(outfile, level)
            outfile.write('Segmentation=model_.Segmentation(\n')
            self.Segmentation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory()
            obj_.build(child_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory()
            obj_.build(child_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'Regression':
            obj_ = Regression.factory()
            obj_.build(child_)
            self.Regression.append(obj_)
            obj_.original_tagname_ = 'Regression'
        elif nodeName_ == 'DecisionTree':
            obj_ = DecisionTree.factory()
            obj_.build(child_)
            self.DecisionTree.append(obj_)
            obj_.original_tagname_ = 'DecisionTree'
        elif nodeName_ == 'Segmentation':
            obj_ = Segmentation.factory()
            obj_.build(child_)
            self.Segmentation = obj_
            obj_.original_tagname_ = 'Segmentation'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class MiningModel


class Segmentation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, multipleModelMethod=None, missingPredictionTreatment='continue', missingThreshold='1', Extension=None, Segment=None):
        self.original_tagname_ = None
        self.multipleModelMethod = _cast(None, multipleModelMethod)
        self.missingPredictionTreatment = _cast(None, missingPredictionTreatment)
        self.missingThreshold = _cast(None, missingThreshold)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Segment is None:
            self.Segment = []
        else:
            self.Segment = Segment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Segmentation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Segmentation.subclass:
            return Segmentation.subclass(*args_, **kwargs_)
        else:
            return Segmentation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Segment(self): return self.Segment
    def set_Segment(self, Segment): self.Segment = Segment
    def add_Segment(self, value): self.Segment.append(value)
    def insert_Segment_at(self, index, value): self.Segment.insert(index, value)
    def replace_Segment_at(self, index, value): self.Segment[index] = value
    def get_multipleModelMethod(self): return self.multipleModelMethod
    def set_multipleModelMethod(self, multipleModelMethod): self.multipleModelMethod = multipleModelMethod
    def get_missingPredictionTreatment(self): return self.missingPredictionTreatment
    def set_missingPredictionTreatment(self, missingPredictionTreatment): self.missingPredictionTreatment = missingPredictionTreatment
    def get_missingThreshold(self): return self.missingThreshold
    def set_missingThreshold(self, missingThreshold): self.missingThreshold = missingThreshold
    def validate_MULTIPLE_MODEL_METHOD(self, value):
        # Validate type MULTIPLE-MODEL-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['majorityVote', 'weightedMajorityVote', 'average', 'weightedAverage', 'median', 'weightedMedian', 'max', 'sum', 'weightedSum', 'selectFirst', 'selectAll', 'modelChain']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MULTIPLE-MODEL-METHOD' % {"value" : value.encode("utf-8")} )
    def validate_MISSING_PREDICTION_TREATMENT(self, value):
        # Validate type MISSING-PREDICTION-TREATMENT, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['returnMissing', 'skipSegment', 'continue']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MISSING-PREDICTION-TREATMENT' % {"value" : value.encode("utf-8")} )
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Segment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Segmentation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Segmentation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Segmentation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Segmentation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Segmentation'):
        if self.multipleModelMethod is not None and 'multipleModelMethod' not in already_processed:
            already_processed.add('multipleModelMethod')
            outfile.write(' multipleModelMethod=%s' % (quote_attrib(self.multipleModelMethod), ))
        if self.missingPredictionTreatment != "continue" and 'missingPredictionTreatment' not in already_processed:
            already_processed.add('missingPredictionTreatment')
            outfile.write(' missingPredictionTreatment=%s' % (quote_attrib(self.missingPredictionTreatment), ))
        if self.missingThreshold != 1 and 'missingThreshold' not in already_processed:
            already_processed.add('missingThreshold')
            outfile.write(' missingThreshold=%s' % (quote_attrib(self.missingThreshold), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Segmentation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Segment_ in self.Segment:
            Segment_.export(outfile, level, namespace_, name_='Segment', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Segmentation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.multipleModelMethod is not None:
            element.set('multipleModelMethod', self.multipleModelMethod)
        if self.missingPredictionTreatment is not None:
            element.set('missingPredictionTreatment', self.missingPredictionTreatment)
        if self.missingThreshold is not None:
            element.set('missingThreshold', self.missingThreshold)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Segment_ in self.Segment:
            Segment_.to_etree(element, name_='Segment', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Segmentation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.multipleModelMethod is not None and 'multipleModelMethod' not in already_processed:
            already_processed.add('multipleModelMethod')
            showIndent(outfile, level)
            outfile.write('multipleModelMethod="%s",\n' % (self.multipleModelMethod,))
        if self.missingPredictionTreatment is not None and 'missingPredictionTreatment' not in already_processed:
            already_processed.add('missingPredictionTreatment')
            showIndent(outfile, level)
            outfile.write('missingPredictionTreatment="%s",\n' % (self.missingPredictionTreatment,))
        if self.missingThreshold is not None and 'missingThreshold' not in already_processed:
            already_processed.add('missingThreshold')
            showIndent(outfile, level)
            outfile.write('missingThreshold=%e,\n' % (self.missingThreshold,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Segment=[\n')
        level += 1
        for Segment_ in self.Segment:
            showIndent(outfile, level)
            outfile.write('model_.Segment(\n')
            Segment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('multipleModelMethod', node)
        if value is not None and 'multipleModelMethod' not in already_processed:
            already_processed.add('multipleModelMethod')
            self.multipleModelMethod = value
            self.validate_MULTIPLE_MODEL_METHOD(self.multipleModelMethod)    # validate type MULTIPLE-MODEL-METHOD
        value = find_attr_value_('missingPredictionTreatment', node)
        if value is not None and 'missingPredictionTreatment' not in already_processed:
            already_processed.add('missingPredictionTreatment')
            self.missingPredictionTreatment = value
            self.validate_MISSING_PREDICTION_TREATMENT(self.missingPredictionTreatment)    # validate type MISSING-PREDICTION-TREATMENT
        value = find_attr_value_('missingThreshold', node)
        if value is not None and 'missingThreshold' not in already_processed:
            already_processed.add('missingThreshold')
            try:
                self.missingThreshold = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (missingThreshold): %s' % exp)
            self.validate_PROB_NUMBER(self.missingThreshold)    # validate type PROB-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Segment':
            obj_ = Segment.factory()
            obj_.build(child_)
            self.Segment.append(obj_)
            obj_.original_tagname_ = 'Segment'
# end class Segmentation


class Segment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, weight='1', Extension=None, SimplePredicate=None, CompoundPredicate=None, SimpleSetPredicate=None, True_=None, False_=None, AnomalyDetectionModel=None, AssociationModel=None, BayesianNetworkModel=None, BaselineModel=None, ClusteringModel=None, GaussianProcessModel=None, GeneralRegressionModel=None, MiningModel=None, NaiveBayesModel=None, NearestNeighborModel=None, NeuralNetwork=None, RegressionModel=None, RuleSetModel=None, SequenceModel=None, Scorecard=None, SupportVectorMachineModel=None, TextModel=None, TimeSeriesModel=None, TreeModel=None, VariableWeight=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.weight = _cast(None, weight)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.SimplePredicate = SimplePredicate
        self.CompoundPredicate = CompoundPredicate
        self.SimpleSetPredicate = SimpleSetPredicate
        self.True_ = True_
        self.False_ = False_
        self.AnomalyDetectionModel = AnomalyDetectionModel
        self.AssociationModel = AssociationModel
        self.BayesianNetworkModel = BayesianNetworkModel
        self.BaselineModel = BaselineModel
        self.ClusteringModel = ClusteringModel
        self.GaussianProcessModel = GaussianProcessModel
        self.GeneralRegressionModel = GeneralRegressionModel
        self.MiningModel = MiningModel
        self.NaiveBayesModel = NaiveBayesModel
        self.NearestNeighborModel = NearestNeighborModel
        self.NeuralNetwork = NeuralNetwork
        self.RegressionModel = RegressionModel
        self.RuleSetModel = RuleSetModel
        self.SequenceModel = SequenceModel
        self.Scorecard = Scorecard
        self.SupportVectorMachineModel = SupportVectorMachineModel
        self.TextModel = TextModel
        self.TimeSeriesModel = TimeSeriesModel
        self.TreeModel = TreeModel
        self.VariableWeight = VariableWeight
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Segment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Segment.subclass:
            return Segment.subclass(*args_, **kwargs_)
        else:
            return Segment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_SimplePredicate(self): return self.SimplePredicate
    def set_SimplePredicate(self, SimplePredicate): self.SimplePredicate = SimplePredicate
    def get_CompoundPredicate(self): return self.CompoundPredicate
    def set_CompoundPredicate(self, CompoundPredicate): self.CompoundPredicate = CompoundPredicate
    def get_SimpleSetPredicate(self): return self.SimpleSetPredicate
    def set_SimpleSetPredicate(self, SimpleSetPredicate): self.SimpleSetPredicate = SimpleSetPredicate
    def get_True(self): return self.True_
    def set_True(self, True_): self.True_ = True_
    def get_False(self): return self.False_
    def set_False(self, False_): self.False_ = False_
    def get_AnomalyDetectionModel(self): return self.AnomalyDetectionModel
    def set_AnomalyDetectionModel(self, AnomalyDetectionModel): self.AnomalyDetectionModel = AnomalyDetectionModel
    def get_AssociationModel(self): return self.AssociationModel
    def set_AssociationModel(self, AssociationModel): self.AssociationModel = AssociationModel
    def get_BayesianNetworkModel(self): return self.BayesianNetworkModel
    def set_BayesianNetworkModel(self, BayesianNetworkModel): self.BayesianNetworkModel = BayesianNetworkModel
    def get_BaselineModel(self): return self.BaselineModel
    def set_BaselineModel(self, BaselineModel): self.BaselineModel = BaselineModel
    def get_ClusteringModel(self): return self.ClusteringModel
    def set_ClusteringModel(self, ClusteringModel): self.ClusteringModel = ClusteringModel
    def get_GaussianProcessModel(self): return self.GaussianProcessModel
    def set_GaussianProcessModel(self, GaussianProcessModel): self.GaussianProcessModel = GaussianProcessModel
    def get_GeneralRegressionModel(self): return self.GeneralRegressionModel
    def set_GeneralRegressionModel(self, GeneralRegressionModel): self.GeneralRegressionModel = GeneralRegressionModel
    def get_MiningModel(self): return self.MiningModel
    def set_MiningModel(self, MiningModel): self.MiningModel = MiningModel
    def get_NaiveBayesModel(self): return self.NaiveBayesModel
    def set_NaiveBayesModel(self, NaiveBayesModel): self.NaiveBayesModel = NaiveBayesModel
    def get_NearestNeighborModel(self): return self.NearestNeighborModel
    def set_NearestNeighborModel(self, NearestNeighborModel): self.NearestNeighborModel = NearestNeighborModel
    def get_NeuralNetwork(self): return self.NeuralNetwork
    def set_NeuralNetwork(self, NeuralNetwork): self.NeuralNetwork = NeuralNetwork
    def get_RegressionModel(self): return self.RegressionModel
    def set_RegressionModel(self, RegressionModel): self.RegressionModel = RegressionModel
    def get_RuleSetModel(self): return self.RuleSetModel
    def set_RuleSetModel(self, RuleSetModel): self.RuleSetModel = RuleSetModel
    def get_SequenceModel(self): return self.SequenceModel
    def set_SequenceModel(self, SequenceModel): self.SequenceModel = SequenceModel
    def get_Scorecard(self): return self.Scorecard
    def set_Scorecard(self, Scorecard): self.Scorecard = Scorecard
    def get_SupportVectorMachineModel(self): return self.SupportVectorMachineModel
    def set_SupportVectorMachineModel(self, SupportVectorMachineModel): self.SupportVectorMachineModel = SupportVectorMachineModel
    def get_TextModel(self): return self.TextModel
    def set_TextModel(self, TextModel): self.TextModel = TextModel
    def get_TimeSeriesModel(self): return self.TimeSeriesModel
    def set_TimeSeriesModel(self, TimeSeriesModel): self.TimeSeriesModel = TimeSeriesModel
    def get_TreeModel(self): return self.TreeModel
    def set_TreeModel(self, TreeModel): self.TreeModel = TreeModel
    def get_VariableWeight(self): return self.VariableWeight
    def set_VariableWeight(self, VariableWeight): self.VariableWeight = VariableWeight
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_weight(self): return self.weight
    def set_weight(self, weight): self.weight = weight
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.SimplePredicate is not None or
            self.CompoundPredicate is not None or
            self.SimpleSetPredicate is not None or
            self.True_ is not None or
            self.False_ is not None or
            self.AnomalyDetectionModel is not None or
            self.AssociationModel is not None or
            self.BayesianNetworkModel is not None or
            self.BaselineModel is not None or
            self.ClusteringModel is not None or
            self.GaussianProcessModel is not None or
            self.GeneralRegressionModel is not None or
            self.MiningModel is not None or
            self.NaiveBayesModel is not None or
            self.NearestNeighborModel is not None or
            self.NeuralNetwork is not None or
            self.RegressionModel is not None or
            self.RuleSetModel is not None or
            self.SequenceModel is not None or
            self.Scorecard is not None or
            self.SupportVectorMachineModel is not None or
            self.TextModel is not None or
            self.TimeSeriesModel is not None or
            self.TreeModel is not None or
            self.VariableWeight is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Segment', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Segment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Segment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Segment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Segment'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.weight != 1 and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight=%s' % (quote_attrib(self.weight), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Segment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.SimplePredicate is not None:
            self.SimplePredicate.export(outfile, level, namespace_, name_='SimplePredicate', pretty_print=pretty_print)
        if self.CompoundPredicate is not None:
            self.CompoundPredicate.export(outfile, level, namespace_, name_='CompoundPredicate', pretty_print=pretty_print)
        if self.SimpleSetPredicate is not None:
            self.SimpleSetPredicate.export(outfile, level, namespace_, name_='SimpleSetPredicate', pretty_print=pretty_print)
        if self.True_ is not None:
            self.True_.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False_ is not None:
            self.False_.export(outfile, level, namespace_, name_='False', pretty_print=pretty_print)
        if self.AnomalyDetectionModel is not None:
            self.AnomalyDetectionModel.export(outfile, level, namespace_, name_='AnomalyDetectionModel', pretty_print=pretty_print)
        if self.AssociationModel is not None:
            self.AssociationModel.export(outfile, level, namespace_, name_='AssociationModel', pretty_print=pretty_print)
        if self.BayesianNetworkModel is not None:
            self.BayesianNetworkModel.export(outfile, level, namespace_, name_='BayesianNetworkModel', pretty_print=pretty_print)
        if self.BaselineModel is not None:
            self.BaselineModel.export(outfile, level, namespace_, name_='BaselineModel', pretty_print=pretty_print)
        if self.ClusteringModel is not None:
            self.ClusteringModel.export(outfile, level, namespace_, name_='ClusteringModel', pretty_print=pretty_print)
        if self.GaussianProcessModel is not None:
            self.GaussianProcessModel.export(outfile, level, namespace_, name_='GaussianProcessModel', pretty_print=pretty_print)
        if self.GeneralRegressionModel is not None:
            self.GeneralRegressionModel.export(outfile, level, namespace_, name_='GeneralRegressionModel', pretty_print=pretty_print)
        if self.MiningModel is not None:
            self.MiningModel.export(outfile, level, namespace_, name_='MiningModel', pretty_print=pretty_print)
        if self.NaiveBayesModel is not None:
            self.NaiveBayesModel.export(outfile, level, namespace_, name_='NaiveBayesModel', pretty_print=pretty_print)
        if self.NearestNeighborModel is not None:
            self.NearestNeighborModel.export(outfile, level, namespace_, name_='NearestNeighborModel', pretty_print=pretty_print)
        if self.NeuralNetwork is not None:
            self.NeuralNetwork.export(outfile, level, namespace_, name_='NeuralNetwork', pretty_print=pretty_print)
        if self.RegressionModel is not None:
            self.RegressionModel.export(outfile, level, namespace_, name_='RegressionModel', pretty_print=pretty_print)
        if self.RuleSetModel is not None:
            self.RuleSetModel.export(outfile, level, namespace_, name_='RuleSetModel', pretty_print=pretty_print)
        if self.SequenceModel is not None:
            self.SequenceModel.export(outfile, level, namespace_, name_='SequenceModel', pretty_print=pretty_print)
        if self.Scorecard is not None:
            self.Scorecard.export(outfile, level, namespace_, name_='Scorecard', pretty_print=pretty_print)
        if self.SupportVectorMachineModel is not None:
            self.SupportVectorMachineModel.export(outfile, level, namespace_, name_='SupportVectorMachineModel', pretty_print=pretty_print)
        if self.TextModel is not None:
            self.TextModel.export(outfile, level, namespace_, name_='TextModel', pretty_print=pretty_print)
        if self.TimeSeriesModel is not None:
            self.TimeSeriesModel.export(outfile, level, namespace_, name_='TimeSeriesModel', pretty_print=pretty_print)
        if self.TreeModel is not None:
            self.TreeModel.export(outfile, level, namespace_, name_='TreeModel', pretty_print=pretty_print)
        if self.VariableWeight is not None:
            self.VariableWeight.export(outfile, level, namespace_, name_='VariableWeight', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Segment', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.weight is not None:
            element.set('weight', self.weight)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.SimplePredicate is not None:
            SimplePredicate_ = self.SimplePredicate
            SimplePredicate_.to_etree(element, name_='SimplePredicate', mapping_=mapping_)
        if self.CompoundPredicate is not None:
            CompoundPredicate_ = self.CompoundPredicate
            CompoundPredicate_.to_etree(element, name_='CompoundPredicate', mapping_=mapping_)
        if self.SimpleSetPredicate is not None:
            SimpleSetPredicate_ = self.SimpleSetPredicate
            SimpleSetPredicate_.to_etree(element, name_='SimpleSetPredicate', mapping_=mapping_)
        if self.True_ is not None:
            True__ = self.True_
            True__.to_etree(element, name_='True', mapping_=mapping_)
        if self.False_ is not None:
            False__ = self.False_
            False__.to_etree(element, name_='False', mapping_=mapping_)
        if self.AnomalyDetectionModel is not None:
            AnomalyDetectionModel_ = self.AnomalyDetectionModel
            AnomalyDetectionModel_.to_etree(element, name_='AnomalyDetectionModel', mapping_=mapping_)
        if self.AssociationModel is not None:
            AssociationModel_ = self.AssociationModel
            AssociationModel_.to_etree(element, name_='AssociationModel', mapping_=mapping_)
        if self.BayesianNetworkModel is not None:
            BayesianNetworkModel_ = self.BayesianNetworkModel
            BayesianNetworkModel_.to_etree(element, name_='BayesianNetworkModel', mapping_=mapping_)
        if self.BaselineModel is not None:
            BaselineModel_ = self.BaselineModel
            BaselineModel_.to_etree(element, name_='BaselineModel', mapping_=mapping_)
        if self.ClusteringModel is not None:
            ClusteringModel_ = self.ClusteringModel
            ClusteringModel_.to_etree(element, name_='ClusteringModel', mapping_=mapping_)
        if self.GaussianProcessModel is not None:
            GaussianProcessModel_ = self.GaussianProcessModel
            GaussianProcessModel_.to_etree(element, name_='GaussianProcessModel', mapping_=mapping_)
        if self.GeneralRegressionModel is not None:
            GeneralRegressionModel_ = self.GeneralRegressionModel
            GeneralRegressionModel_.to_etree(element, name_='GeneralRegressionModel', mapping_=mapping_)
        if self.MiningModel is not None:
            MiningModel_ = self.MiningModel
            MiningModel_.to_etree(element, name_='MiningModel', mapping_=mapping_)
        if self.NaiveBayesModel is not None:
            NaiveBayesModel_ = self.NaiveBayesModel
            NaiveBayesModel_.to_etree(element, name_='NaiveBayesModel', mapping_=mapping_)
        if self.NearestNeighborModel is not None:
            NearestNeighborModel_ = self.NearestNeighborModel
            NearestNeighborModel_.to_etree(element, name_='NearestNeighborModel', mapping_=mapping_)
        if self.NeuralNetwork is not None:
            NeuralNetwork_ = self.NeuralNetwork
            NeuralNetwork_.to_etree(element, name_='NeuralNetwork', mapping_=mapping_)
        if self.RegressionModel is not None:
            RegressionModel_ = self.RegressionModel
            RegressionModel_.to_etree(element, name_='RegressionModel', mapping_=mapping_)
        if self.RuleSetModel is not None:
            RuleSetModel_ = self.RuleSetModel
            RuleSetModel_.to_etree(element, name_='RuleSetModel', mapping_=mapping_)
        if self.SequenceModel is not None:
            SequenceModel_ = self.SequenceModel
            SequenceModel_.to_etree(element, name_='SequenceModel', mapping_=mapping_)
        if self.Scorecard is not None:
            Scorecard_ = self.Scorecard
            Scorecard_.to_etree(element, name_='Scorecard', mapping_=mapping_)
        if self.SupportVectorMachineModel is not None:
            SupportVectorMachineModel_ = self.SupportVectorMachineModel
            SupportVectorMachineModel_.to_etree(element, name_='SupportVectorMachineModel', mapping_=mapping_)
        if self.TextModel is not None:
            TextModel_ = self.TextModel
            TextModel_.to_etree(element, name_='TextModel', mapping_=mapping_)
        if self.TimeSeriesModel is not None:
            TimeSeriesModel_ = self.TimeSeriesModel
            TimeSeriesModel_.to_etree(element, name_='TimeSeriesModel', mapping_=mapping_)
        if self.TreeModel is not None:
            TreeModel_ = self.TreeModel
            TreeModel_.to_etree(element, name_='TreeModel', mapping_=mapping_)
        if self.VariableWeight is not None:
            VariableWeight_ = self.VariableWeight
            VariableWeight_.to_etree(element, name_='VariableWeight', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Segment'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            showIndent(outfile, level)
            outfile.write('weight=%e,\n' % (self.weight,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SimplePredicate is not None:
            showIndent(outfile, level)
            outfile.write('SimplePredicate=model_.SimplePredicate(\n')
            self.SimplePredicate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CompoundPredicate is not None:
            showIndent(outfile, level)
            outfile.write('CompoundPredicate=model_.CompoundPredicate(\n')
            self.CompoundPredicate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SimpleSetPredicate is not None:
            showIndent(outfile, level)
            outfile.write('SimpleSetPredicate=model_.SimpleSetPredicate(\n')
            self.SimpleSetPredicate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.True_ is not None:
            showIndent(outfile, level)
            outfile.write('True_=model_.True_(\n')
            self.True_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.False_ is not None:
            showIndent(outfile, level)
            outfile.write('False_=model_.False_(\n')
            self.False_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AnomalyDetectionModel is not None:
            showIndent(outfile, level)
            outfile.write('AnomalyDetectionModel=model_.AnomalyDetectionModel(\n')
            self.AnomalyDetectionModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AssociationModel is not None:
            showIndent(outfile, level)
            outfile.write('AssociationModel=model_.AssociationModel(\n')
            self.AssociationModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BayesianNetworkModel is not None:
            showIndent(outfile, level)
            outfile.write('BayesianNetworkModel=model_.BayesianNetworkModel(\n')
            self.BayesianNetworkModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BaselineModel is not None:
            showIndent(outfile, level)
            outfile.write('BaselineModel=model_.BaselineModel(\n')
            self.BaselineModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ClusteringModel is not None:
            showIndent(outfile, level)
            outfile.write('ClusteringModel=model_.ClusteringModel(\n')
            self.ClusteringModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GaussianProcessModel is not None:
            showIndent(outfile, level)
            outfile.write('GaussianProcessModel=model_.GaussianProcessModel(\n')
            self.GaussianProcessModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GeneralRegressionModel is not None:
            showIndent(outfile, level)
            outfile.write('GeneralRegressionModel=model_.GeneralRegressionModel(\n')
            self.GeneralRegressionModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MiningModel is not None:
            showIndent(outfile, level)
            outfile.write('MiningModel=model_.MiningModel(\n')
            self.MiningModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NaiveBayesModel is not None:
            showIndent(outfile, level)
            outfile.write('NaiveBayesModel=model_.NaiveBayesModel(\n')
            self.NaiveBayesModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NearestNeighborModel is not None:
            showIndent(outfile, level)
            outfile.write('NearestNeighborModel=model_.NearestNeighborModel(\n')
            self.NearestNeighborModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NeuralNetwork is not None:
            showIndent(outfile, level)
            outfile.write('NeuralNetwork=model_.NeuralNetwork(\n')
            self.NeuralNetwork.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RegressionModel is not None:
            showIndent(outfile, level)
            outfile.write('RegressionModel=model_.RegressionModel(\n')
            self.RegressionModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RuleSetModel is not None:
            showIndent(outfile, level)
            outfile.write('RuleSetModel=model_.RuleSetModel(\n')
            self.RuleSetModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SequenceModel is not None:
            showIndent(outfile, level)
            outfile.write('SequenceModel=model_.SequenceModel(\n')
            self.SequenceModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Scorecard is not None:
            showIndent(outfile, level)
            outfile.write('Scorecard=model_.Scorecard(\n')
            self.Scorecard.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SupportVectorMachineModel is not None:
            showIndent(outfile, level)
            outfile.write('SupportVectorMachineModel=model_.SupportVectorMachineModel(\n')
            self.SupportVectorMachineModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextModel is not None:
            showIndent(outfile, level)
            outfile.write('TextModel=model_.TextModel(\n')
            self.TextModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TimeSeriesModel is not None:
            showIndent(outfile, level)
            outfile.write('TimeSeriesModel=model_.TimeSeriesModel(\n')
            self.TimeSeriesModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TreeModel is not None:
            showIndent(outfile, level)
            outfile.write('TreeModel=model_.TreeModel(\n')
            self.TreeModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VariableWeight is not None:
            showIndent(outfile, level)
            outfile.write('VariableWeight=model_.VariableWeight(\n')
            self.VariableWeight.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            try:
                self.weight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (weight): %s' % exp)
            self.validate_NUMBER(self.weight)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'SimplePredicate':
            obj_ = SimplePredicate.factory()
            obj_.build(child_)
            self.SimplePredicate = obj_
            obj_.original_tagname_ = 'SimplePredicate'
        elif nodeName_ == 'CompoundPredicate':
            obj_ = CompoundPredicate.factory()
            obj_.build(child_)
            self.CompoundPredicate = obj_
            obj_.original_tagname_ = 'CompoundPredicate'
        elif nodeName_ == 'SimpleSetPredicate':
            obj_ = SimpleSetPredicate.factory()
            obj_.build(child_)
            self.SimpleSetPredicate = obj_
            obj_.original_tagname_ = 'SimpleSetPredicate'
        elif nodeName_ == 'True':
            obj_ = True_.factory()
            obj_.build(child_)
            self.True_ = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            obj_ = False_.factory()
            obj_.build(child_)
            self.False_ = obj_
            obj_.original_tagname_ = 'False'
        elif nodeName_ == 'AnomalyDetectionModel':
            obj_ = AnomalyDetectionModel.factory()
            obj_.build(child_)
            self.AnomalyDetectionModel = obj_
            obj_.original_tagname_ = 'AnomalyDetectionModel'
        elif nodeName_ == 'AssociationModel':
            obj_ = AssociationModel.factory()
            obj_.build(child_)
            self.AssociationModel = obj_
            obj_.original_tagname_ = 'AssociationModel'
        elif nodeName_ == 'BayesianNetworkModel':
            obj_ = BayesianNetworkModel.factory()
            obj_.build(child_)
            self.BayesianNetworkModel = obj_
            obj_.original_tagname_ = 'BayesianNetworkModel'
        elif nodeName_ == 'BaselineModel':
            obj_ = BaselineModel.factory()
            obj_.build(child_)
            self.BaselineModel = obj_
            obj_.original_tagname_ = 'BaselineModel'
        elif nodeName_ == 'ClusteringModel':
            obj_ = ClusteringModel.factory()
            obj_.build(child_)
            self.ClusteringModel = obj_
            obj_.original_tagname_ = 'ClusteringModel'
        elif nodeName_ == 'GaussianProcessModel':
            obj_ = GaussianProcessModel.factory()
            obj_.build(child_)
            self.GaussianProcessModel = obj_
            obj_.original_tagname_ = 'GaussianProcessModel'
        elif nodeName_ == 'GeneralRegressionModel':
            obj_ = GeneralRegressionModel.factory()
            obj_.build(child_)
            self.GeneralRegressionModel = obj_
            obj_.original_tagname_ = 'GeneralRegressionModel'
        elif nodeName_ == 'MiningModel':
            obj_ = MiningModel.factory()
            obj_.build(child_)
            self.MiningModel = obj_
            obj_.original_tagname_ = 'MiningModel'
        elif nodeName_ == 'NaiveBayesModel':
            obj_ = NaiveBayesModel.factory()
            obj_.build(child_)
            self.NaiveBayesModel = obj_
            obj_.original_tagname_ = 'NaiveBayesModel'
        elif nodeName_ == 'NearestNeighborModel':
            obj_ = NearestNeighborModel.factory()
            obj_.build(child_)
            self.NearestNeighborModel = obj_
            obj_.original_tagname_ = 'NearestNeighborModel'
        elif nodeName_ == 'NeuralNetwork':
            obj_ = NeuralNetwork.factory()
            obj_.build(child_)
            self.NeuralNetwork = obj_
            obj_.original_tagname_ = 'NeuralNetwork'
        elif nodeName_ == 'RegressionModel':
            obj_ = RegressionModel.factory()
            obj_.build(child_)
            self.RegressionModel = obj_
            obj_.original_tagname_ = 'RegressionModel'
        elif nodeName_ == 'RuleSetModel':
            obj_ = RuleSetModel.factory()
            obj_.build(child_)
            self.RuleSetModel = obj_
            obj_.original_tagname_ = 'RuleSetModel'
        elif nodeName_ == 'SequenceModel':
            obj_ = SequenceModel.factory()
            obj_.build(child_)
            self.SequenceModel = obj_
            obj_.original_tagname_ = 'SequenceModel'
        elif nodeName_ == 'Scorecard':
            obj_ = Scorecard.factory()
            obj_.build(child_)
            self.Scorecard = obj_
            obj_.original_tagname_ = 'Scorecard'
        elif nodeName_ == 'SupportVectorMachineModel':
            obj_ = SupportVectorMachineModel.factory()
            obj_.build(child_)
            self.SupportVectorMachineModel = obj_
            obj_.original_tagname_ = 'SupportVectorMachineModel'
        elif nodeName_ == 'TextModel':
            obj_ = TextModel.factory()
            obj_.build(child_)
            self.TextModel = obj_
            obj_.original_tagname_ = 'TextModel'
        elif nodeName_ == 'TimeSeriesModel':
            obj_ = TimeSeriesModel.factory()
            obj_.build(child_)
            self.TimeSeriesModel = obj_
            obj_.original_tagname_ = 'TimeSeriesModel'
        elif nodeName_ == 'TreeModel':
            obj_ = TreeModel.factory()
            obj_.build(child_)
            self.TreeModel = obj_
            obj_.original_tagname_ = 'TreeModel'
        elif nodeName_ == 'VariableWeight':
            obj_ = VariableWeight.factory()
            obj_.build(child_)
            self.VariableWeight = obj_
            obj_.original_tagname_ = 'VariableWeight'
# end class Segment


class VariableWeight(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, Extension=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableWeight)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableWeight.subclass:
            return VariableWeight.subclass(*args_, **kwargs_)
        else:
            return VariableWeight(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VariableWeight', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VariableWeight')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VariableWeight')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VariableWeight', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VariableWeight'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VariableWeight', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='VariableWeight', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='VariableWeight'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class VariableWeight


class ResultField(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, optype=None, dataType=None, feature=None, value=None, Extension=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.displayName = _cast(None, displayName)
        self.optype = _cast(None, optype)
        self.dataType = _cast(None, dataType)
        self.feature = _cast(None, feature)
        self.value = _cast(None, value)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResultField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResultField.subclass:
            return ResultField.subclass(*args_, **kwargs_)
        else:
            return ResultField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_optype(self): return self.optype
    def set_optype(self, optype): self.optype = optype
    def get_dataType(self): return self.dataType
    def set_dataType(self, dataType): self.dataType = dataType
    def get_feature(self): return self.feature
    def set_feature(self, feature): self.feature = feature
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_OPTYPE(self, value):
        # Validate type OPTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['categorical', 'ordinal', 'continuous']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OPTYPE' % {"value" : value.encode("utf-8")} )
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DATATYPE' % {"value" : value.encode("utf-8")} )
    def validate_RESULT_FEATURE(self, value):
        # Validate type RESULT-FEATURE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['predictedValue', 'predictedDisplayValue', 'transformedValue', 'decision', 'probability', 'affinity', 'residual', 'standardError', 'standardDeviation', 'clusterId', 'clusterAffinity', 'entityId', 'entityAffinity', 'warning', 'ruleValue', 'reasonCode', 'antecedent', 'consequent', 'rule', 'ruleId', 'confidence', 'support', 'lift', 'leverage', 'confidenceIntervalLower', 'confidenceIntervalUpper']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RESULT-FEATURE' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResultField', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResultField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResultField')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResultField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResultField'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            outfile.write(' optype=%s' % (quote_attrib(self.optype), ))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (quote_attrib(self.dataType), ))
        if self.feature is not None and 'feature' not in already_processed:
            already_processed.add('feature')
            outfile.write(' feature=%s' % (quote_attrib(self.feature), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ResultField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ResultField', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.name)
        if self.displayName is not None:
            element.set('displayName', self.gds_format_string(self.displayName))
        if self.optype is not None:
            element.set('optype', self.optype)
        if self.dataType is not None:
            element.set('dataType', self.dataType)
        if self.feature is not None:
            element.set('feature', self.feature)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ResultField'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            showIndent(outfile, level)
            outfile.write('displayName="%s",\n' % (self.displayName,))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            showIndent(outfile, level)
            outfile.write('optype="%s",\n' % (self.optype,))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            showIndent(outfile, level)
            outfile.write('dataType="%s",\n' % (self.dataType,))
        if self.feature is not None and 'feature' not in already_processed:
            already_processed.add('feature')
            showIndent(outfile, level)
            outfile.write('feature="%s",\n' % (self.feature,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
        value = find_attr_value_('optype', node)
        if value is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            self.optype = value
            self.validate_OPTYPE(self.optype)    # validate type OPTYPE
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
        value = find_attr_value_('feature', node)
        if value is not None and 'feature' not in already_processed:
            already_processed.add('feature')
            self.feature = value
            self.validate_RESULT_FEATURE(self.feature)    # validate type RESULT-FEATURE
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class ResultField


class Regression(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, normalizationMethod='none', Extension=None, Output=None, ModelStats=None, Targets=None, LocalTransformations=None, ResultField=None, RegressionTable=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.normalizationMethod = _cast(None, normalizationMethod)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Output = Output
        self.ModelStats = ModelStats
        self.Targets = Targets
        self.LocalTransformations = LocalTransformations
        if ResultField is None:
            self.ResultField = []
        else:
            self.ResultField = ResultField
        if RegressionTable is None:
            self.RegressionTable = []
        else:
            self.RegressionTable = RegressionTable
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Regression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Regression.subclass:
            return Regression.subclass(*args_, **kwargs_)
        else:
            return Regression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_Targets(self): return self.Targets
    def set_Targets(self, Targets): self.Targets = Targets
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_ResultField(self): return self.ResultField
    def set_ResultField(self, ResultField): self.ResultField = ResultField
    def add_ResultField(self, value): self.ResultField.append(value)
    def insert_ResultField_at(self, index, value): self.ResultField.insert(index, value)
    def replace_ResultField_at(self, index, value): self.ResultField[index] = value
    def get_RegressionTable(self): return self.RegressionTable
    def set_RegressionTable(self, RegressionTable): self.RegressionTable = RegressionTable
    def add_RegressionTable(self, value): self.RegressionTable.append(value)
    def insert_RegressionTable_at(self, index, value): self.RegressionTable.insert(index, value)
    def replace_RegressionTable_at(self, index, value): self.RegressionTable[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_normalizationMethod(self): return self.normalizationMethod
    def set_normalizationMethod(self, normalizationMethod): self.normalizationMethod = normalizationMethod
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_REGRESSIONNORMALIZATIONMETHOD(self, value):
        # Validate type REGRESSIONNORMALIZATIONMETHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'simplemax', 'softmax', 'logit', 'probit', 'cloglog', 'exp', 'loglog', 'cauchit']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on REGRESSIONNORMALIZATIONMETHOD' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Extension or
            self.Output is not None or
            self.ModelStats is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.ResultField or
            self.RegressionTable
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Regression', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Regression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Regression')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Regression', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Regression'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.normalizationMethod != "none" and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            outfile.write(' normalizationMethod=%s' % (quote_attrib(self.normalizationMethod), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Regression', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.Targets is not None:
            self.Targets.export(outfile, level, namespace_, name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        for ResultField_ in self.ResultField:
            ResultField_.export(outfile, level, namespace_, name_='ResultField', pretty_print=pretty_print)
        for RegressionTable_ in self.RegressionTable:
            RegressionTable_.export(outfile, level, namespace_, name_='RegressionTable', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Regression', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.normalizationMethod is not None:
            element.set('normalizationMethod', self.normalizationMethod)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.Targets is not None:
            Targets_ = self.Targets
            Targets_.to_etree(element, name_='Targets', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        for ResultField_ in self.ResultField:
            ResultField_.to_etree(element, name_='ResultField', mapping_=mapping_)
        for RegressionTable_ in self.RegressionTable:
            RegressionTable_.to_etree(element, name_='RegressionTable', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Regression'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.normalizationMethod is not None and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            showIndent(outfile, level)
            outfile.write('normalizationMethod="%s",\n' % (self.normalizationMethod,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targets is not None:
            showIndent(outfile, level)
            outfile.write('Targets=model_.Targets(\n')
            self.Targets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ResultField=[\n')
        level += 1
        for ResultField_ in self.ResultField:
            showIndent(outfile, level)
            outfile.write('model_.ResultField(\n')
            ResultField_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RegressionTable=[\n')
        level += 1
        for RegressionTable_ in self.RegressionTable:
            showIndent(outfile, level)
            outfile.write('model_.RegressionTable(\n')
            RegressionTable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('normalizationMethod', node)
        if value is not None and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            self.normalizationMethod = value
            self.validate_REGRESSIONNORMALIZATIONMETHOD(self.normalizationMethod)    # validate type REGRESSIONNORMALIZATIONMETHOD
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory()
            obj_.build(child_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'ResultField':
            obj_ = ResultField.factory()
            obj_.build(child_)
            self.ResultField.append(obj_)
            obj_.original_tagname_ = 'ResultField'
        elif nodeName_ == 'RegressionTable':
            obj_ = RegressionTable.factory()
            obj_.build(child_)
            self.RegressionTable.append(obj_)
            obj_.original_tagname_ = 'RegressionTable'
# end class Regression


class DecisionTree(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, missingValueStrategy='none', missingValuePenalty='1.0', noTrueChildStrategy='returnNullPrediction', splitCharacteristic='multiSplit', Extension=None, Output=None, ModelStats=None, Targets=None, LocalTransformations=None, ResultField=None, Node=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.missingValueStrategy = _cast(None, missingValueStrategy)
        self.missingValuePenalty = _cast(None, missingValuePenalty)
        self.noTrueChildStrategy = _cast(None, noTrueChildStrategy)
        self.splitCharacteristic = _cast(None, splitCharacteristic)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Output = Output
        self.ModelStats = ModelStats
        self.Targets = Targets
        self.LocalTransformations = LocalTransformations
        if ResultField is None:
            self.ResultField = []
        else:
            self.ResultField = ResultField
        self.Node = Node
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DecisionTree)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DecisionTree.subclass:
            return DecisionTree.subclass(*args_, **kwargs_)
        else:
            return DecisionTree(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_Targets(self): return self.Targets
    def set_Targets(self, Targets): self.Targets = Targets
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_ResultField(self): return self.ResultField
    def set_ResultField(self, ResultField): self.ResultField = ResultField
    def add_ResultField(self, value): self.ResultField.append(value)
    def insert_ResultField_at(self, index, value): self.ResultField.insert(index, value)
    def replace_ResultField_at(self, index, value): self.ResultField[index] = value
    def get_Node(self): return self.Node
    def set_Node(self, Node): self.Node = Node
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_missingValueStrategy(self): return self.missingValueStrategy
    def set_missingValueStrategy(self, missingValueStrategy): self.missingValueStrategy = missingValueStrategy
    def get_missingValuePenalty(self): return self.missingValuePenalty
    def set_missingValuePenalty(self, missingValuePenalty): self.missingValuePenalty = missingValuePenalty
    def get_noTrueChildStrategy(self): return self.noTrueChildStrategy
    def set_noTrueChildStrategy(self, noTrueChildStrategy): self.noTrueChildStrategy = noTrueChildStrategy
    def get_splitCharacteristic(self): return self.splitCharacteristic
    def set_splitCharacteristic(self, splitCharacteristic): self.splitCharacteristic = splitCharacteristic
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_MISSING_VALUE_STRATEGY(self, value):
        # Validate type MISSING-VALUE-STRATEGY, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['lastPrediction', 'nullPrediction', 'defaultChild', 'weightedConfidence', 'aggregateNodes', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MISSING-VALUE-STRATEGY' % {"value" : value.encode("utf-8")} )
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_NO_TRUE_CHILD_STRATEGY(self, value):
        # Validate type NO-TRUE-CHILD-STRATEGY, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['returnNullPrediction', 'returnLastPrediction']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NO-TRUE-CHILD-STRATEGY' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Extension or
            self.Output is not None or
            self.ModelStats is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.ResultField or
            self.Node is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DecisionTree', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DecisionTree')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DecisionTree')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DecisionTree', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DecisionTree'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.missingValueStrategy != "none" and 'missingValueStrategy' not in already_processed:
            already_processed.add('missingValueStrategy')
            outfile.write(' missingValueStrategy=%s' % (quote_attrib(self.missingValueStrategy), ))
        if self.missingValuePenalty != 1.0 and 'missingValuePenalty' not in already_processed:
            already_processed.add('missingValuePenalty')
            outfile.write(' missingValuePenalty=%s' % (quote_attrib(self.missingValuePenalty), ))
        if self.noTrueChildStrategy != "returnNullPrediction" and 'noTrueChildStrategy' not in already_processed:
            already_processed.add('noTrueChildStrategy')
            outfile.write(' noTrueChildStrategy=%s' % (quote_attrib(self.noTrueChildStrategy), ))
        if self.splitCharacteristic != "multiSplit" and 'splitCharacteristic' not in already_processed:
            already_processed.add('splitCharacteristic')
            outfile.write(' splitCharacteristic=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.splitCharacteristic), input_name='splitCharacteristic')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DecisionTree', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.Targets is not None:
            self.Targets.export(outfile, level, namespace_, name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        for ResultField_ in self.ResultField:
            ResultField_.export(outfile, level, namespace_, name_='ResultField', pretty_print=pretty_print)
        if self.Node is not None:
            self.Node.export(outfile, level, namespace_, name_='Node', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DecisionTree', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.missingValueStrategy is not None:
            element.set('missingValueStrategy', self.missingValueStrategy)
        if self.missingValuePenalty is not None:
            element.set('missingValuePenalty', self.missingValuePenalty)
        if self.noTrueChildStrategy is not None:
            element.set('noTrueChildStrategy', self.noTrueChildStrategy)
        if self.splitCharacteristic is not None:
            element.set('splitCharacteristic', self.gds_format_string(self.splitCharacteristic))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.Targets is not None:
            Targets_ = self.Targets
            Targets_.to_etree(element, name_='Targets', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        for ResultField_ in self.ResultField:
            ResultField_.to_etree(element, name_='ResultField', mapping_=mapping_)
        if self.Node is not None:
            Node_ = self.Node
            Node_.to_etree(element, name_='Node', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DecisionTree'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.missingValueStrategy is not None and 'missingValueStrategy' not in already_processed:
            already_processed.add('missingValueStrategy')
            showIndent(outfile, level)
            outfile.write('missingValueStrategy="%s",\n' % (self.missingValueStrategy,))
        if self.missingValuePenalty is not None and 'missingValuePenalty' not in already_processed:
            already_processed.add('missingValuePenalty')
            showIndent(outfile, level)
            outfile.write('missingValuePenalty=%e,\n' % (self.missingValuePenalty,))
        if self.noTrueChildStrategy is not None and 'noTrueChildStrategy' not in already_processed:
            already_processed.add('noTrueChildStrategy')
            showIndent(outfile, level)
            outfile.write('noTrueChildStrategy="%s",\n' % (self.noTrueChildStrategy,))
        if self.splitCharacteristic is not None and 'splitCharacteristic' not in already_processed:
            already_processed.add('splitCharacteristic')
            showIndent(outfile, level)
            outfile.write('splitCharacteristic="%s",\n' % (self.splitCharacteristic,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targets is not None:
            showIndent(outfile, level)
            outfile.write('Targets=model_.Targets(\n')
            self.Targets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ResultField=[\n')
        level += 1
        for ResultField_ in self.ResultField:
            showIndent(outfile, level)
            outfile.write('model_.ResultField(\n')
            ResultField_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Node is not None:
            showIndent(outfile, level)
            outfile.write('Node=model_.Node(\n')
            self.Node.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('missingValueStrategy', node)
        if value is not None and 'missingValueStrategy' not in already_processed:
            already_processed.add('missingValueStrategy')
            self.missingValueStrategy = value
            self.validate_MISSING_VALUE_STRATEGY(self.missingValueStrategy)    # validate type MISSING-VALUE-STRATEGY
        value = find_attr_value_('missingValuePenalty', node)
        if value is not None and 'missingValuePenalty' not in already_processed:
            already_processed.add('missingValuePenalty')
            try:
                self.missingValuePenalty = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (missingValuePenalty): %s' % exp)
            self.validate_PROB_NUMBER(self.missingValuePenalty)    # validate type PROB-NUMBER
        value = find_attr_value_('noTrueChildStrategy', node)
        if value is not None and 'noTrueChildStrategy' not in already_processed:
            already_processed.add('noTrueChildStrategy')
            self.noTrueChildStrategy = value
            self.validate_NO_TRUE_CHILD_STRATEGY(self.noTrueChildStrategy)    # validate type NO-TRUE-CHILD-STRATEGY
        value = find_attr_value_('splitCharacteristic', node)
        if value is not None and 'splitCharacteristic' not in already_processed:
            already_processed.add('splitCharacteristic')
            self.splitCharacteristic = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory()
            obj_.build(child_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'ResultField':
            obj_ = ResultField.factory()
            obj_.build(child_)
            self.ResultField.append(obj_)
            obj_.original_tagname_ = 'ResultField'
        elif nodeName_ == 'Node':
            obj_ = Node.factory()
            obj_.build(child_)
            self.Node = obj_
            obj_.original_tagname_ = 'Node'
# end class DecisionTree


class SupportVectorMachineModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, threshold='0', svmRepresentation='SupportVectors', classificationMethod='OneAgainstAll', maxWins=False, isScorable=True, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, LinearKernelType=None, PolynomialKernelType=None, RadialBasisKernelType=None, SigmoidKernelType=None, VectorDictionary=None, SupportVectorMachine=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.threshold = _cast(None, threshold)
        self.svmRepresentation = _cast(None, svmRepresentation)
        self.classificationMethod = _cast(None, classificationMethod)
        self.maxWins = _cast(bool, maxWins)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.ModelExplanation = ModelExplanation
        self.Targets = Targets
        self.LocalTransformations = LocalTransformations
        self.LinearKernelType = LinearKernelType
        self.PolynomialKernelType = PolynomialKernelType
        self.RadialBasisKernelType = RadialBasisKernelType
        self.SigmoidKernelType = SigmoidKernelType
        self.VectorDictionary = VectorDictionary
        if SupportVectorMachine is None:
            self.SupportVectorMachine = []
        else:
            self.SupportVectorMachine = SupportVectorMachine
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupportVectorMachineModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupportVectorMachineModel.subclass:
            return SupportVectorMachineModel.subclass(*args_, **kwargs_)
        else:
            return SupportVectorMachineModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_ModelExplanation(self): return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation): self.ModelExplanation = ModelExplanation
    def get_Targets(self): return self.Targets
    def set_Targets(self, Targets): self.Targets = Targets
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_LinearKernelType(self): return self.LinearKernelType
    def set_LinearKernelType(self, LinearKernelType): self.LinearKernelType = LinearKernelType
    def get_PolynomialKernelType(self): return self.PolynomialKernelType
    def set_PolynomialKernelType(self, PolynomialKernelType): self.PolynomialKernelType = PolynomialKernelType
    def get_RadialBasisKernelType(self): return self.RadialBasisKernelType
    def set_RadialBasisKernelType(self, RadialBasisKernelType): self.RadialBasisKernelType = RadialBasisKernelType
    def get_SigmoidKernelType(self): return self.SigmoidKernelType
    def set_SigmoidKernelType(self, SigmoidKernelType): self.SigmoidKernelType = SigmoidKernelType
    def get_VectorDictionary(self): return self.VectorDictionary
    def set_VectorDictionary(self, VectorDictionary): self.VectorDictionary = VectorDictionary
    def get_SupportVectorMachine(self): return self.SupportVectorMachine
    def set_SupportVectorMachine(self, SupportVectorMachine): self.SupportVectorMachine = SupportVectorMachine
    def add_SupportVectorMachine(self, value): self.SupportVectorMachine.append(value)
    def insert_SupportVectorMachine_at(self, index, value): self.SupportVectorMachine.insert(index, value)
    def replace_SupportVectorMachine_at(self, index, value): self.SupportVectorMachine[index] = value
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_threshold(self): return self.threshold
    def set_threshold(self, threshold): self.threshold = threshold
    def get_svmRepresentation(self): return self.svmRepresentation
    def set_svmRepresentation(self, svmRepresentation): self.svmRepresentation = svmRepresentation
    def get_classificationMethod(self): return self.classificationMethod
    def set_classificationMethod(self, classificationMethod): self.classificationMethod = classificationMethod
    def get_maxWins(self): return self.maxWins
    def set_maxWins(self, maxWins): self.maxWins = maxWins
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_SVM_REPRESENTATION(self, value):
        # Validate type SVM-REPRESENTATION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SupportVectors', 'Coefficients']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SVM-REPRESENTATION' % {"value" : value.encode("utf-8")} )
    def validate_SVM_CLASSIFICATION_METHOD(self, value):
        # Validate type SVM-CLASSIFICATION-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['OneAgainstAll', 'OneAgainstOne']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SVM-CLASSIFICATION-METHOD' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.LinearKernelType is not None or
            self.PolynomialKernelType is not None or
            self.RadialBasisKernelType is not None or
            self.SigmoidKernelType is not None or
            self.VectorDictionary is not None or
            self.SupportVectorMachine or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupportVectorMachineModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupportVectorMachineModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupportVectorMachineModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupportVectorMachineModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupportVectorMachineModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.threshold != 0 and 'threshold' not in already_processed:
            already_processed.add('threshold')
            outfile.write(' threshold=%s' % (quote_attrib(self.threshold), ))
        if self.svmRepresentation != "SupportVectors" and 'svmRepresentation' not in already_processed:
            already_processed.add('svmRepresentation')
            outfile.write(' svmRepresentation=%s' % (quote_attrib(self.svmRepresentation), ))
        if self.classificationMethod != "OneAgainstAll" and 'classificationMethod' not in already_processed:
            already_processed.add('classificationMethod')
            outfile.write(' classificationMethod=%s' % (quote_attrib(self.classificationMethod), ))
        if self.maxWins and 'maxWins' not in already_processed:
            already_processed.add('maxWins')
            outfile.write(' maxWins="%s"' % self.gds_format_boolean(self.maxWins, input_name='maxWins'))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='SupportVectorMachineModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            self.ModelExplanation.export(outfile, level, namespace_, name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            self.Targets.export(outfile, level, namespace_, name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        if self.LinearKernelType is not None:
            self.LinearKernelType.export(outfile, level, namespace_, name_='LinearKernelType', pretty_print=pretty_print)
        if self.PolynomialKernelType is not None:
            self.PolynomialKernelType.export(outfile, level, namespace_, name_='PolynomialKernelType', pretty_print=pretty_print)
        if self.RadialBasisKernelType is not None:
            self.RadialBasisKernelType.export(outfile, level, namespace_, name_='RadialBasisKernelType', pretty_print=pretty_print)
        if self.SigmoidKernelType is not None:
            self.SigmoidKernelType.export(outfile, level, namespace_, name_='SigmoidKernelType', pretty_print=pretty_print)
        if self.VectorDictionary is not None:
            self.VectorDictionary.export(outfile, level, namespace_, name_='VectorDictionary', pretty_print=pretty_print)
        for SupportVectorMachine_ in self.SupportVectorMachine:
            SupportVectorMachine_.export(outfile, level, namespace_, name_='SupportVectorMachine', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SupportVectorMachineModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.threshold is not None:
            element.set('threshold', self.threshold)
        if self.svmRepresentation is not None:
            element.set('svmRepresentation', self.svmRepresentation)
        if self.classificationMethod is not None:
            element.set('classificationMethod', self.classificationMethod)
        if self.maxWins is not None:
            element.set('maxWins', self.gds_format_boolean(self.maxWins))
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.ModelExplanation is not None:
            ModelExplanation_ = self.ModelExplanation
            ModelExplanation_.to_etree(element, name_='ModelExplanation', mapping_=mapping_)
        if self.Targets is not None:
            Targets_ = self.Targets
            Targets_.to_etree(element, name_='Targets', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        if self.LinearKernelType is not None:
            LinearKernelType_ = self.LinearKernelType
            LinearKernelType_.to_etree(element, name_='LinearKernelType', mapping_=mapping_)
        if self.PolynomialKernelType is not None:
            PolynomialKernelType_ = self.PolynomialKernelType
            PolynomialKernelType_.to_etree(element, name_='PolynomialKernelType', mapping_=mapping_)
        if self.RadialBasisKernelType is not None:
            RadialBasisKernelType_ = self.RadialBasisKernelType
            RadialBasisKernelType_.to_etree(element, name_='RadialBasisKernelType', mapping_=mapping_)
        if self.SigmoidKernelType is not None:
            SigmoidKernelType_ = self.SigmoidKernelType
            SigmoidKernelType_.to_etree(element, name_='SigmoidKernelType', mapping_=mapping_)
        if self.VectorDictionary is not None:
            VectorDictionary_ = self.VectorDictionary
            VectorDictionary_.to_etree(element, name_='VectorDictionary', mapping_=mapping_)
        for SupportVectorMachine_ in self.SupportVectorMachine:
            SupportVectorMachine_.to_etree(element, name_='SupportVectorMachine', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SupportVectorMachineModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.threshold is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            showIndent(outfile, level)
            outfile.write('threshold=%e,\n' % (self.threshold,))
        if self.svmRepresentation is not None and 'svmRepresentation' not in already_processed:
            already_processed.add('svmRepresentation')
            showIndent(outfile, level)
            outfile.write('svmRepresentation="%s",\n' % (self.svmRepresentation,))
        if self.classificationMethod is not None and 'classificationMethod' not in already_processed:
            already_processed.add('classificationMethod')
            showIndent(outfile, level)
            outfile.write('classificationMethod="%s",\n' % (self.classificationMethod,))
        if self.maxWins is not None and 'maxWins' not in already_processed:
            already_processed.add('maxWins')
            showIndent(outfile, level)
            outfile.write('maxWins=%s,\n' % (self.maxWins,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelExplanation is not None:
            showIndent(outfile, level)
            outfile.write('ModelExplanation=model_.ModelExplanation(\n')
            self.ModelExplanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targets is not None:
            showIndent(outfile, level)
            outfile.write('Targets=model_.Targets(\n')
            self.Targets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LinearKernelType is not None:
            showIndent(outfile, level)
            outfile.write('LinearKernelType=model_.LinearKernelType(\n')
            self.LinearKernelType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PolynomialKernelType is not None:
            showIndent(outfile, level)
            outfile.write('PolynomialKernelType=model_.PolynomialKernelType(\n')
            self.PolynomialKernelType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RadialBasisKernelType is not None:
            showIndent(outfile, level)
            outfile.write('RadialBasisKernelType=model_.RadialBasisKernelType(\n')
            self.RadialBasisKernelType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SigmoidKernelType is not None:
            showIndent(outfile, level)
            outfile.write('SigmoidKernelType=model_.SigmoidKernelType(\n')
            self.SigmoidKernelType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VectorDictionary is not None:
            showIndent(outfile, level)
            outfile.write('VectorDictionary=model_.VectorDictionary(\n')
            self.VectorDictionary.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('SupportVectorMachine=[\n')
        level += 1
        for SupportVectorMachine_ in self.SupportVectorMachine:
            showIndent(outfile, level)
            outfile.write('model_.SupportVectorMachine(\n')
            SupportVectorMachine_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('threshold', node)
        if value is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            try:
                self.threshold = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (threshold): %s' % exp)
            self.validate_REAL_NUMBER(self.threshold)    # validate type REAL-NUMBER
        value = find_attr_value_('svmRepresentation', node)
        if value is not None and 'svmRepresentation' not in already_processed:
            already_processed.add('svmRepresentation')
            self.svmRepresentation = value
            self.validate_SVM_REPRESENTATION(self.svmRepresentation)    # validate type SVM-REPRESENTATION
        value = find_attr_value_('classificationMethod', node)
        if value is not None and 'classificationMethod' not in already_processed:
            already_processed.add('classificationMethod')
            self.classificationMethod = value
            self.validate_SVM_CLASSIFICATION_METHOD(self.classificationMethod)    # validate type SVM-CLASSIFICATION-METHOD
        value = find_attr_value_('maxWins', node)
        if value is not None and 'maxWins' not in already_processed:
            already_processed.add('maxWins')
            if value in ('true', '1'):
                self.maxWins = True
            elif value in ('false', '0'):
                self.maxWins = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory()
            obj_.build(child_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory()
            obj_.build(child_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'LinearKernelType':
            obj_ = LinearKernelType.factory()
            obj_.build(child_)
            self.LinearKernelType = obj_
            obj_.original_tagname_ = 'LinearKernelType'
        elif nodeName_ == 'PolynomialKernelType':
            obj_ = PolynomialKernelType.factory()
            obj_.build(child_)
            self.PolynomialKernelType = obj_
            obj_.original_tagname_ = 'PolynomialKernelType'
        elif nodeName_ == 'RadialBasisKernelType':
            obj_ = RadialBasisKernelType.factory()
            obj_.build(child_)
            self.RadialBasisKernelType = obj_
            obj_.original_tagname_ = 'RadialBasisKernelType'
        elif nodeName_ == 'SigmoidKernelType':
            obj_ = SigmoidKernelType.factory()
            obj_.build(child_)
            self.SigmoidKernelType = obj_
            obj_.original_tagname_ = 'SigmoidKernelType'
        elif nodeName_ == 'VectorDictionary':
            obj_ = VectorDictionary.factory()
            obj_.build(child_)
            self.VectorDictionary = obj_
            obj_.original_tagname_ = 'VectorDictionary'
        elif nodeName_ == 'SupportVectorMachine':
            obj_ = SupportVectorMachine.factory()
            obj_.build(child_)
            self.SupportVectorMachine.append(obj_)
            obj_.original_tagname_ = 'SupportVectorMachine'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class SupportVectorMachineModel


class LinearKernelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, Extension=None):
        self.original_tagname_ = None
        self.description = _cast(None, description)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinearKernelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinearKernelType.subclass:
            return LinearKernelType.subclass(*args_, **kwargs_)
        else:
            return LinearKernelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinearKernelType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LinearKernelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearKernelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinearKernelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinearKernelType'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LinearKernelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='LinearKernelType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='LinearKernelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            showIndent(outfile, level)
            outfile.write('description="%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class LinearKernelType


class PolynomialKernelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, gamma='1', coef0='1', degree='1', Extension=None):
        self.original_tagname_ = None
        self.description = _cast(None, description)
        self.gamma = _cast(None, gamma)
        self.coef0 = _cast(None, coef0)
        self.degree = _cast(None, degree)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PolynomialKernelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PolynomialKernelType.subclass:
            return PolynomialKernelType.subclass(*args_, **kwargs_)
        else:
            return PolynomialKernelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_gamma(self): return self.gamma
    def set_gamma(self, gamma): self.gamma = gamma
    def get_coef0(self): return self.coef0
    def set_coef0(self, coef0): self.coef0 = coef0
    def get_degree(self): return self.degree
    def set_degree(self, degree): self.degree = degree
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PolynomialKernelType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PolynomialKernelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PolynomialKernelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PolynomialKernelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PolynomialKernelType'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.gamma != 1 and 'gamma' not in already_processed:
            already_processed.add('gamma')
            outfile.write(' gamma=%s' % (quote_attrib(self.gamma), ))
        if self.coef0 != 1 and 'coef0' not in already_processed:
            already_processed.add('coef0')
            outfile.write(' coef0=%s' % (quote_attrib(self.coef0), ))
        if self.degree != 1 and 'degree' not in already_processed:
            already_processed.add('degree')
            outfile.write(' degree=%s' % (quote_attrib(self.degree), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PolynomialKernelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PolynomialKernelType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        if self.gamma is not None:
            element.set('gamma', self.gamma)
        if self.coef0 is not None:
            element.set('coef0', self.coef0)
        if self.degree is not None:
            element.set('degree', self.degree)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PolynomialKernelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            showIndent(outfile, level)
            outfile.write('description="%s",\n' % (self.description,))
        if self.gamma is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            showIndent(outfile, level)
            outfile.write('gamma=%e,\n' % (self.gamma,))
        if self.coef0 is not None and 'coef0' not in already_processed:
            already_processed.add('coef0')
            showIndent(outfile, level)
            outfile.write('coef0=%e,\n' % (self.coef0,))
        if self.degree is not None and 'degree' not in already_processed:
            already_processed.add('degree')
            showIndent(outfile, level)
            outfile.write('degree=%e,\n' % (self.degree,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('gamma', node)
        if value is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            try:
                self.gamma = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (gamma): %s' % exp)
            self.validate_REAL_NUMBER(self.gamma)    # validate type REAL-NUMBER
        value = find_attr_value_('coef0', node)
        if value is not None and 'coef0' not in already_processed:
            already_processed.add('coef0')
            try:
                self.coef0 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coef0): %s' % exp)
            self.validate_REAL_NUMBER(self.coef0)    # validate type REAL-NUMBER
        value = find_attr_value_('degree', node)
        if value is not None and 'degree' not in already_processed:
            already_processed.add('degree')
            try:
                self.degree = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (degree): %s' % exp)
            self.validate_REAL_NUMBER(self.degree)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class PolynomialKernelType


class RadialBasisKernelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, gamma='1', Extension=None):
        self.original_tagname_ = None
        self.description = _cast(None, description)
        self.gamma = _cast(None, gamma)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RadialBasisKernelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RadialBasisKernelType.subclass:
            return RadialBasisKernelType.subclass(*args_, **kwargs_)
        else:
            return RadialBasisKernelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_gamma(self): return self.gamma
    def set_gamma(self, gamma): self.gamma = gamma
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RadialBasisKernelType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RadialBasisKernelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RadialBasisKernelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RadialBasisKernelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RadialBasisKernelType'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.gamma != 1 and 'gamma' not in already_processed:
            already_processed.add('gamma')
            outfile.write(' gamma=%s' % (quote_attrib(self.gamma), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RadialBasisKernelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='RadialBasisKernelType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        if self.gamma is not None:
            element.set('gamma', self.gamma)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='RadialBasisKernelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            showIndent(outfile, level)
            outfile.write('description="%s",\n' % (self.description,))
        if self.gamma is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            showIndent(outfile, level)
            outfile.write('gamma=%e,\n' % (self.gamma,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('gamma', node)
        if value is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            try:
                self.gamma = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (gamma): %s' % exp)
            self.validate_REAL_NUMBER(self.gamma)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class RadialBasisKernelType


class SigmoidKernelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, gamma='1', coef0='1', Extension=None):
        self.original_tagname_ = None
        self.description = _cast(None, description)
        self.gamma = _cast(None, gamma)
        self.coef0 = _cast(None, coef0)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SigmoidKernelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SigmoidKernelType.subclass:
            return SigmoidKernelType.subclass(*args_, **kwargs_)
        else:
            return SigmoidKernelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_gamma(self): return self.gamma
    def set_gamma(self, gamma): self.gamma = gamma
    def get_coef0(self): return self.coef0
    def set_coef0(self, coef0): self.coef0 = coef0
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SigmoidKernelType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SigmoidKernelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SigmoidKernelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SigmoidKernelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SigmoidKernelType'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.gamma != 1 and 'gamma' not in already_processed:
            already_processed.add('gamma')
            outfile.write(' gamma=%s' % (quote_attrib(self.gamma), ))
        if self.coef0 != 1 and 'coef0' not in already_processed:
            already_processed.add('coef0')
            outfile.write(' coef0=%s' % (quote_attrib(self.coef0), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SigmoidKernelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SigmoidKernelType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        if self.gamma is not None:
            element.set('gamma', self.gamma)
        if self.coef0 is not None:
            element.set('coef0', self.coef0)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SigmoidKernelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            showIndent(outfile, level)
            outfile.write('description="%s",\n' % (self.description,))
        if self.gamma is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            showIndent(outfile, level)
            outfile.write('gamma=%e,\n' % (self.gamma,))
        if self.coef0 is not None and 'coef0' not in already_processed:
            already_processed.add('coef0')
            showIndent(outfile, level)
            outfile.write('coef0=%e,\n' % (self.coef0,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('gamma', node)
        if value is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            try:
                self.gamma = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (gamma): %s' % exp)
            self.validate_REAL_NUMBER(self.gamma)    # validate type REAL-NUMBER
        value = find_attr_value_('coef0', node)
        if value is not None and 'coef0' not in already_processed:
            already_processed.add('coef0')
            try:
                self.coef0 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coef0): %s' % exp)
            self.validate_REAL_NUMBER(self.coef0)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class SigmoidKernelType


class VectorDictionary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numberOfVectors=None, Extension=None, VectorFields=None, VectorInstance=None):
        self.original_tagname_ = None
        self.numberOfVectors = _cast(int, numberOfVectors)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.VectorFields = VectorFields
        if VectorInstance is None:
            self.VectorInstance = []
        else:
            self.VectorInstance = VectorInstance
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VectorDictionary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VectorDictionary.subclass:
            return VectorDictionary.subclass(*args_, **kwargs_)
        else:
            return VectorDictionary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_VectorFields(self): return self.VectorFields
    def set_VectorFields(self, VectorFields): self.VectorFields = VectorFields
    def get_VectorInstance(self): return self.VectorInstance
    def set_VectorInstance(self, VectorInstance): self.VectorInstance = VectorInstance
    def add_VectorInstance(self, value): self.VectorInstance.append(value)
    def insert_VectorInstance_at(self, index, value): self.VectorInstance.insert(index, value)
    def replace_VectorInstance_at(self, index, value): self.VectorInstance[index] = value
    def get_numberOfVectors(self): return self.numberOfVectors
    def set_numberOfVectors(self, numberOfVectors): self.numberOfVectors = numberOfVectors
    def hasContent_(self):
        if (
            self.Extension or
            self.VectorFields is not None or
            self.VectorInstance
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VectorDictionary', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VectorDictionary')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VectorDictionary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VectorDictionary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VectorDictionary'):
        if self.numberOfVectors is not None and 'numberOfVectors' not in already_processed:
            already_processed.add('numberOfVectors')
            outfile.write(' numberOfVectors="%s"' % self.gds_format_integer(self.numberOfVectors, input_name='numberOfVectors'))
    def exportChildren(self, outfile, level, namespace_='', name_='VectorDictionary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.VectorFields is not None:
            self.VectorFields.export(outfile, level, namespace_, name_='VectorFields', pretty_print=pretty_print)
        for VectorInstance_ in self.VectorInstance:
            VectorInstance_.export(outfile, level, namespace_, name_='VectorInstance', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='VectorDictionary', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.numberOfVectors is not None:
            element.set('numberOfVectors', self.gds_format_integer(self.numberOfVectors))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.VectorFields is not None:
            VectorFields_ = self.VectorFields
            VectorFields_.to_etree(element, name_='VectorFields', mapping_=mapping_)
        for VectorInstance_ in self.VectorInstance:
            VectorInstance_.to_etree(element, name_='VectorInstance', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='VectorDictionary'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfVectors is not None and 'numberOfVectors' not in already_processed:
            already_processed.add('numberOfVectors')
            showIndent(outfile, level)
            outfile.write('numberOfVectors=%d,\n' % (self.numberOfVectors,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.VectorFields is not None:
            showIndent(outfile, level)
            outfile.write('VectorFields=model_.VectorFields(\n')
            self.VectorFields.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('VectorInstance=[\n')
        level += 1
        for VectorInstance_ in self.VectorInstance:
            showIndent(outfile, level)
            outfile.write('model_.VectorInstance(\n')
            VectorInstance_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfVectors', node)
        if value is not None and 'numberOfVectors' not in already_processed:
            already_processed.add('numberOfVectors')
            try:
                self.numberOfVectors = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfVectors < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'VectorFields':
            obj_ = VectorFields.factory()
            obj_.build(child_)
            self.VectorFields = obj_
            obj_.original_tagname_ = 'VectorFields'
        elif nodeName_ == 'VectorInstance':
            obj_ = VectorInstance.factory()
            obj_.build(child_)
            self.VectorInstance.append(obj_)
            obj_.original_tagname_ = 'VectorInstance'
# end class VectorDictionary


class VectorFields(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numberOfFields=None, Extension=None, FieldRef=None, CategoricalPredictor=None):
        self.original_tagname_ = None
        self.numberOfFields = _cast(int, numberOfFields)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if FieldRef is None:
            self.FieldRef = []
        else:
            self.FieldRef = FieldRef
        if CategoricalPredictor is None:
            self.CategoricalPredictor = []
        else:
            self.CategoricalPredictor = CategoricalPredictor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VectorFields)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VectorFields.subclass:
            return VectorFields.subclass(*args_, **kwargs_)
        else:
            return VectorFields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_FieldRef(self): return self.FieldRef
    def set_FieldRef(self, FieldRef): self.FieldRef = FieldRef
    def add_FieldRef(self, value): self.FieldRef.append(value)
    def insert_FieldRef_at(self, index, value): self.FieldRef.insert(index, value)
    def replace_FieldRef_at(self, index, value): self.FieldRef[index] = value
    def get_CategoricalPredictor(self): return self.CategoricalPredictor
    def set_CategoricalPredictor(self, CategoricalPredictor): self.CategoricalPredictor = CategoricalPredictor
    def add_CategoricalPredictor(self, value): self.CategoricalPredictor.append(value)
    def insert_CategoricalPredictor_at(self, index, value): self.CategoricalPredictor.insert(index, value)
    def replace_CategoricalPredictor_at(self, index, value): self.CategoricalPredictor[index] = value
    def get_numberOfFields(self): return self.numberOfFields
    def set_numberOfFields(self, numberOfFields): self.numberOfFields = numberOfFields
    def hasContent_(self):
        if (
            self.Extension or
            self.FieldRef or
            self.CategoricalPredictor
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VectorFields', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VectorFields')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VectorFields')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VectorFields', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VectorFields'):
        if self.numberOfFields is not None and 'numberOfFields' not in already_processed:
            already_processed.add('numberOfFields')
            outfile.write(' numberOfFields="%s"' % self.gds_format_integer(self.numberOfFields, input_name='numberOfFields'))
    def exportChildren(self, outfile, level, namespace_='', name_='VectorFields', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for FieldRef_ in self.FieldRef:
            FieldRef_.export(outfile, level, namespace_, name_='FieldRef', pretty_print=pretty_print)
        for CategoricalPredictor_ in self.CategoricalPredictor:
            CategoricalPredictor_.export(outfile, level, namespace_, name_='CategoricalPredictor', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='VectorFields', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.numberOfFields is not None:
            element.set('numberOfFields', self.gds_format_integer(self.numberOfFields))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for FieldRef_ in self.FieldRef:
            FieldRef_.to_etree(element, name_='FieldRef', mapping_=mapping_)
        for CategoricalPredictor_ in self.CategoricalPredictor:
            CategoricalPredictor_.to_etree(element, name_='CategoricalPredictor', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='VectorFields'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfFields is not None and 'numberOfFields' not in already_processed:
            already_processed.add('numberOfFields')
            showIndent(outfile, level)
            outfile.write('numberOfFields=%d,\n' % (self.numberOfFields,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FieldRef=[\n')
        level += 1
        for FieldRef_ in self.FieldRef:
            showIndent(outfile, level)
            outfile.write('model_.FieldRef(\n')
            FieldRef_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CategoricalPredictor=[\n')
        level += 1
        for CategoricalPredictor_ in self.CategoricalPredictor:
            showIndent(outfile, level)
            outfile.write('model_.CategoricalPredictor(\n')
            CategoricalPredictor_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfFields', node)
        if value is not None and 'numberOfFields' not in already_processed:
            already_processed.add('numberOfFields')
            try:
                self.numberOfFields = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfFields < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory()
            obj_.build(child_)
            self.FieldRef.append(obj_)
            obj_.original_tagname_ = 'FieldRef'
        elif nodeName_ == 'CategoricalPredictor':
            obj_ = CategoricalPredictor.factory()
            obj_.build(child_)
            self.CategoricalPredictor.append(obj_)
            obj_.original_tagname_ = 'CategoricalPredictor'
# end class VectorFields


class VectorInstance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, Extension=None, REAL_SparseArray=None, Array=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.REAL_SparseArray = REAL_SparseArray
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VectorInstance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VectorInstance.subclass:
            return VectorInstance.subclass(*args_, **kwargs_)
        else:
            return VectorInstance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_REAL_SparseArray(self): return self.REAL_SparseArray
    def set_REAL_SparseArray(self, REAL_SparseArray): self.REAL_SparseArray = REAL_SparseArray
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_VECTOR_ID(self, value):
        # Validate type VECTOR-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.REAL_SparseArray is not None or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VectorInstance', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VectorInstance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VectorInstance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VectorInstance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VectorInstance'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VectorInstance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.REAL_SparseArray is not None:
            self.REAL_SparseArray.export(outfile, level, namespace_, name_='REAL-SparseArray', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='VectorInstance', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.id is not None:
            element.set('id', self.id)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.REAL_SparseArray is not None:
            REAL_SparseArray_ = self.REAL_SparseArray
            REAL_SparseArray_.to_etree(element, name_='REAL-SparseArray', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='VectorInstance'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.REAL_SparseArray is not None:
            showIndent(outfile, level)
            outfile.write('REAL_SparseArray=model_.REAL_SparseArray(\n')
            self.REAL_SparseArray.exportLiteral(outfile, level, name_='REAL_SparseArray')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_VECTOR_ID(self.id)    # validate type VECTOR-ID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'REAL-SparseArray':
            obj_ = REAL_SparseArray.factory()
            obj_.build(child_)
            self.REAL_SparseArray = obj_
            obj_.original_tagname_ = 'REAL-SparseArray'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class VectorInstance


class SupportVectorMachine(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, targetCategory=None, alternateTargetCategory=None, threshold=None, Extension=None, SupportVectors=None, Coefficients=None):
        self.original_tagname_ = None
        self.targetCategory = _cast(None, targetCategory)
        self.alternateTargetCategory = _cast(None, alternateTargetCategory)
        self.threshold = _cast(None, threshold)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.SupportVectors = SupportVectors
        self.Coefficients = Coefficients
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupportVectorMachine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupportVectorMachine.subclass:
            return SupportVectorMachine.subclass(*args_, **kwargs_)
        else:
            return SupportVectorMachine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_SupportVectors(self): return self.SupportVectors
    def set_SupportVectors(self, SupportVectors): self.SupportVectors = SupportVectors
    def get_Coefficients(self): return self.Coefficients
    def set_Coefficients(self, Coefficients): self.Coefficients = Coefficients
    def get_targetCategory(self): return self.targetCategory
    def set_targetCategory(self, targetCategory): self.targetCategory = targetCategory
    def get_alternateTargetCategory(self): return self.alternateTargetCategory
    def set_alternateTargetCategory(self, alternateTargetCategory): self.alternateTargetCategory = alternateTargetCategory
    def get_threshold(self): return self.threshold
    def set_threshold(self, threshold): self.threshold = threshold
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.SupportVectors is not None or
            self.Coefficients is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupportVectorMachine', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupportVectorMachine')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupportVectorMachine')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupportVectorMachine', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupportVectorMachine'):
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            outfile.write(' targetCategory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetCategory), input_name='targetCategory')), ))
        if self.alternateTargetCategory is not None and 'alternateTargetCategory' not in already_processed:
            already_processed.add('alternateTargetCategory')
            outfile.write(' alternateTargetCategory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alternateTargetCategory), input_name='alternateTargetCategory')), ))
        if self.threshold is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            outfile.write(' threshold=%s' % (quote_attrib(self.threshold), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SupportVectorMachine', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.SupportVectors is not None:
            self.SupportVectors.export(outfile, level, namespace_, name_='SupportVectors', pretty_print=pretty_print)
        if self.Coefficients is not None:
            self.Coefficients.export(outfile, level, namespace_, name_='Coefficients', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SupportVectorMachine', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.targetCategory is not None:
            element.set('targetCategory', self.gds_format_string(self.targetCategory))
        if self.alternateTargetCategory is not None:
            element.set('alternateTargetCategory', self.gds_format_string(self.alternateTargetCategory))
        if self.threshold is not None:
            element.set('threshold', self.threshold)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.SupportVectors is not None:
            SupportVectors_ = self.SupportVectors
            SupportVectors_.to_etree(element, name_='SupportVectors', mapping_=mapping_)
        if self.Coefficients is not None:
            Coefficients_ = self.Coefficients
            Coefficients_.to_etree(element, name_='Coefficients', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SupportVectorMachine'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            showIndent(outfile, level)
            outfile.write('targetCategory="%s",\n' % (self.targetCategory,))
        if self.alternateTargetCategory is not None and 'alternateTargetCategory' not in already_processed:
            already_processed.add('alternateTargetCategory')
            showIndent(outfile, level)
            outfile.write('alternateTargetCategory="%s",\n' % (self.alternateTargetCategory,))
        if self.threshold is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            showIndent(outfile, level)
            outfile.write('threshold=%e,\n' % (self.threshold,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SupportVectors is not None:
            showIndent(outfile, level)
            outfile.write('SupportVectors=model_.SupportVectors(\n')
            self.SupportVectors.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Coefficients is not None:
            showIndent(outfile, level)
            outfile.write('Coefficients=model_.Coefficients(\n')
            self.Coefficients.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('targetCategory', node)
        if value is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            self.targetCategory = value
        value = find_attr_value_('alternateTargetCategory', node)
        if value is not None and 'alternateTargetCategory' not in already_processed:
            already_processed.add('alternateTargetCategory')
            self.alternateTargetCategory = value
        value = find_attr_value_('threshold', node)
        if value is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            try:
                self.threshold = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (threshold): %s' % exp)
            self.validate_REAL_NUMBER(self.threshold)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'SupportVectors':
            obj_ = SupportVectors.factory()
            obj_.build(child_)
            self.SupportVectors = obj_
            obj_.original_tagname_ = 'SupportVectors'
        elif nodeName_ == 'Coefficients':
            obj_ = Coefficients.factory()
            obj_.build(child_)
            self.Coefficients = obj_
            obj_.original_tagname_ = 'Coefficients'
# end class SupportVectorMachine


class SupportVectors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numberOfSupportVectors=None, numberOfAttributes=None, Extension=None, SupportVector=None):
        self.original_tagname_ = None
        self.numberOfSupportVectors = _cast(int, numberOfSupportVectors)
        self.numberOfAttributes = _cast(int, numberOfAttributes)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if SupportVector is None:
            self.SupportVector = []
        else:
            self.SupportVector = SupportVector
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupportVectors)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupportVectors.subclass:
            return SupportVectors.subclass(*args_, **kwargs_)
        else:
            return SupportVectors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_SupportVector(self): return self.SupportVector
    def set_SupportVector(self, SupportVector): self.SupportVector = SupportVector
    def add_SupportVector(self, value): self.SupportVector.append(value)
    def insert_SupportVector_at(self, index, value): self.SupportVector.insert(index, value)
    def replace_SupportVector_at(self, index, value): self.SupportVector[index] = value
    def get_numberOfSupportVectors(self): return self.numberOfSupportVectors
    def set_numberOfSupportVectors(self, numberOfSupportVectors): self.numberOfSupportVectors = numberOfSupportVectors
    def get_numberOfAttributes(self): return self.numberOfAttributes
    def set_numberOfAttributes(self, numberOfAttributes): self.numberOfAttributes = numberOfAttributes
    def hasContent_(self):
        if (
            self.Extension or
            self.SupportVector
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupportVectors', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupportVectors')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupportVectors')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupportVectors', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupportVectors'):
        if self.numberOfSupportVectors is not None and 'numberOfSupportVectors' not in already_processed:
            already_processed.add('numberOfSupportVectors')
            outfile.write(' numberOfSupportVectors="%s"' % self.gds_format_integer(self.numberOfSupportVectors, input_name='numberOfSupportVectors'))
        if self.numberOfAttributes is not None and 'numberOfAttributes' not in already_processed:
            already_processed.add('numberOfAttributes')
            outfile.write(' numberOfAttributes="%s"' % self.gds_format_integer(self.numberOfAttributes, input_name='numberOfAttributes'))
    def exportChildren(self, outfile, level, namespace_='', name_='SupportVectors', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for SupportVector_ in self.SupportVector:
            SupportVector_.export(outfile, level, namespace_, name_='SupportVector', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SupportVectors', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.numberOfSupportVectors is not None:
            element.set('numberOfSupportVectors', self.gds_format_integer(self.numberOfSupportVectors))
        if self.numberOfAttributes is not None:
            element.set('numberOfAttributes', self.gds_format_integer(self.numberOfAttributes))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for SupportVector_ in self.SupportVector:
            SupportVector_.to_etree(element, name_='SupportVector', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SupportVectors'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfSupportVectors is not None and 'numberOfSupportVectors' not in already_processed:
            already_processed.add('numberOfSupportVectors')
            showIndent(outfile, level)
            outfile.write('numberOfSupportVectors=%d,\n' % (self.numberOfSupportVectors,))
        if self.numberOfAttributes is not None and 'numberOfAttributes' not in already_processed:
            already_processed.add('numberOfAttributes')
            showIndent(outfile, level)
            outfile.write('numberOfAttributes=%d,\n' % (self.numberOfAttributes,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SupportVector=[\n')
        level += 1
        for SupportVector_ in self.SupportVector:
            showIndent(outfile, level)
            outfile.write('model_.SupportVector(\n')
            SupportVector_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfSupportVectors', node)
        if value is not None and 'numberOfSupportVectors' not in already_processed:
            already_processed.add('numberOfSupportVectors')
            try:
                self.numberOfSupportVectors = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfSupportVectors < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('numberOfAttributes', node)
        if value is not None and 'numberOfAttributes' not in already_processed:
            already_processed.add('numberOfAttributes')
            try:
                self.numberOfAttributes = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfAttributes < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'SupportVector':
            obj_ = SupportVector.factory()
            obj_.build(child_)
            self.SupportVector.append(obj_)
            obj_.original_tagname_ = 'SupportVector'
# end class SupportVectors


class SupportVector(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vectorId=None, Extension=None):
        self.original_tagname_ = None
        self.vectorId = _cast(None, vectorId)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupportVector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupportVector.subclass:
            return SupportVector.subclass(*args_, **kwargs_)
        else:
            return SupportVector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_vectorId(self): return self.vectorId
    def set_vectorId(self, vectorId): self.vectorId = vectorId
    def validate_VECTOR_ID(self, value):
        # Validate type VECTOR-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupportVector', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupportVector')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupportVector')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupportVector', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupportVector'):
        if self.vectorId is not None and 'vectorId' not in already_processed:
            already_processed.add('vectorId')
            outfile.write(' vectorId=%s' % (quote_attrib(self.vectorId), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SupportVector', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SupportVector', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.vectorId is not None:
            element.set('vectorId', self.vectorId)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SupportVector'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vectorId is not None and 'vectorId' not in already_processed:
            already_processed.add('vectorId')
            showIndent(outfile, level)
            outfile.write('vectorId="%s",\n' % (self.vectorId,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vectorId', node)
        if value is not None and 'vectorId' not in already_processed:
            already_processed.add('vectorId')
            self.vectorId = value
            self.validate_VECTOR_ID(self.vectorId)    # validate type VECTOR-ID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class SupportVector


class Coefficients(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numberOfCoefficients=None, absoluteValue='0', Extension=None, Coefficient=None):
        self.original_tagname_ = None
        self.numberOfCoefficients = _cast(int, numberOfCoefficients)
        self.absoluteValue = _cast(None, absoluteValue)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Coefficient is None:
            self.Coefficient = []
        else:
            self.Coefficient = Coefficient
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Coefficients)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Coefficients.subclass:
            return Coefficients.subclass(*args_, **kwargs_)
        else:
            return Coefficients(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Coefficient(self): return self.Coefficient
    def set_Coefficient(self, Coefficient): self.Coefficient = Coefficient
    def add_Coefficient(self, value): self.Coefficient.append(value)
    def insert_Coefficient_at(self, index, value): self.Coefficient.insert(index, value)
    def replace_Coefficient_at(self, index, value): self.Coefficient[index] = value
    def get_numberOfCoefficients(self): return self.numberOfCoefficients
    def set_numberOfCoefficients(self, numberOfCoefficients): self.numberOfCoefficients = numberOfCoefficients
    def get_absoluteValue(self): return self.absoluteValue
    def set_absoluteValue(self, absoluteValue): self.absoluteValue = absoluteValue
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Coefficient
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Coefficients', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Coefficients')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Coefficients')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Coefficients', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Coefficients'):
        if self.numberOfCoefficients is not None and 'numberOfCoefficients' not in already_processed:
            already_processed.add('numberOfCoefficients')
            outfile.write(' numberOfCoefficients="%s"' % self.gds_format_integer(self.numberOfCoefficients, input_name='numberOfCoefficients'))
        if self.absoluteValue != 0 and 'absoluteValue' not in already_processed:
            already_processed.add('absoluteValue')
            outfile.write(' absoluteValue=%s' % (quote_attrib(self.absoluteValue), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Coefficients', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Coefficient_ in self.Coefficient:
            Coefficient_.export(outfile, level, namespace_, name_='Coefficient', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Coefficients', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.numberOfCoefficients is not None:
            element.set('numberOfCoefficients', self.gds_format_integer(self.numberOfCoefficients))
        if self.absoluteValue is not None:
            element.set('absoluteValue', self.absoluteValue)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Coefficient_ in self.Coefficient:
            Coefficient_.to_etree(element, name_='Coefficient', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Coefficients'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfCoefficients is not None and 'numberOfCoefficients' not in already_processed:
            already_processed.add('numberOfCoefficients')
            showIndent(outfile, level)
            outfile.write('numberOfCoefficients=%d,\n' % (self.numberOfCoefficients,))
        if self.absoluteValue is not None and 'absoluteValue' not in already_processed:
            already_processed.add('absoluteValue')
            showIndent(outfile, level)
            outfile.write('absoluteValue=%e,\n' % (self.absoluteValue,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Coefficient=[\n')
        level += 1
        for Coefficient_ in self.Coefficient:
            showIndent(outfile, level)
            outfile.write('model_.Coefficient(\n')
            Coefficient_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfCoefficients', node)
        if value is not None and 'numberOfCoefficients' not in already_processed:
            already_processed.add('numberOfCoefficients')
            try:
                self.numberOfCoefficients = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfCoefficients < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('absoluteValue', node)
        if value is not None and 'absoluteValue' not in already_processed:
            already_processed.add('absoluteValue')
            try:
                self.absoluteValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (absoluteValue): %s' % exp)
            self.validate_REAL_NUMBER(self.absoluteValue)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Coefficient':
            obj_ = Coefficient.factory()
            obj_.build(child_)
            self.Coefficient.append(obj_)
            obj_.original_tagname_ = 'Coefficient'
# end class Coefficients


class Coefficient(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value='0', Extension=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Coefficient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Coefficient.subclass:
            return Coefficient.subclass(*args_, **kwargs_)
        else:
            return Coefficient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Coefficient', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Coefficient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Coefficient')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Coefficient', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Coefficient'):
        if self.value != 0 and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Coefficient', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Coefficient', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.value is not None:
            element.set('value', self.value)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Coefficient'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value=%e,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
            self.validate_REAL_NUMBER(self.value)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Coefficient


class PMML(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, Header=None, MiningBuildTask=None, DataDictionary=None, TransformationDictionary=None, AnomalyDetectionModel=None, AssociationModel=None, BayesianNetworkModel=None, BaselineModel=None, ClusteringModel=None, GaussianProcessModel=None, GeneralRegressionModel=None, MiningModel=None, NaiveBayesModel=None, NearestNeighborModel=None, NeuralNetwork=None, RegressionModel=None, RuleSetModel=None, SequenceModel=None, Scorecard=None, SupportVectorMachineModel=None, TextModel=None, TimeSeriesModel=None, TreeModel=None, Extension=None):
        self.original_tagname_ = None
        self.version = _cast(None, version)
        self.Header = Header
        self.MiningBuildTask = MiningBuildTask
        self.DataDictionary = DataDictionary
        self.TransformationDictionary = TransformationDictionary
        if AnomalyDetectionModel is None:
            self.AnomalyDetectionModel = []
        else:
            self.AnomalyDetectionModel = AnomalyDetectionModel
        if AssociationModel is None:
            self.AssociationModel = []
        else:
            self.AssociationModel = AssociationModel
        if BayesianNetworkModel is None:
            self.BayesianNetworkModel = []
        else:
            self.BayesianNetworkModel = BayesianNetworkModel
        if BaselineModel is None:
            self.BaselineModel = []
        else:
            self.BaselineModel = BaselineModel
        if ClusteringModel is None:
            self.ClusteringModel = []
        else:
            self.ClusteringModel = ClusteringModel
        if GaussianProcessModel is None:
            self.GaussianProcessModel = []
        else:
            self.GaussianProcessModel = GaussianProcessModel
        if GeneralRegressionModel is None:
            self.GeneralRegressionModel = []
        else:
            self.GeneralRegressionModel = GeneralRegressionModel
        if MiningModel is None:
            self.MiningModel = []
        else:
            self.MiningModel = MiningModel
        if NaiveBayesModel is None:
            self.NaiveBayesModel = []
        else:
            self.NaiveBayesModel = NaiveBayesModel
        if NearestNeighborModel is None:
            self.NearestNeighborModel = []
        else:
            self.NearestNeighborModel = NearestNeighborModel
        if NeuralNetwork is None:
            self.NeuralNetwork = []
        else:
            self.NeuralNetwork = NeuralNetwork
        if RegressionModel is None:
            self.RegressionModel = []
        else:
            self.RegressionModel = RegressionModel
        if RuleSetModel is None:
            self.RuleSetModel = []
        else:
            self.RuleSetModel = RuleSetModel
        if SequenceModel is None:
            self.SequenceModel = []
        else:
            self.SequenceModel = SequenceModel
        if Scorecard is None:
            self.Scorecard = []
        else:
            self.Scorecard = Scorecard
        if SupportVectorMachineModel is None:
            self.SupportVectorMachineModel = []
        else:
            self.SupportVectorMachineModel = SupportVectorMachineModel
        if TextModel is None:
            self.TextModel = []
        else:
            self.TextModel = TextModel
        if TimeSeriesModel is None:
            self.TimeSeriesModel = []
        else:
            self.TimeSeriesModel = TimeSeriesModel
        if TreeModel is None:
            self.TreeModel = []
        else:
            self.TreeModel = TreeModel
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PMML)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PMML.subclass:
            return PMML.subclass(*args_, **kwargs_)
        else:
            return PMML(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Header(self): return self.Header
    def set_Header(self, Header): self.Header = Header
    def get_MiningBuildTask(self): return self.MiningBuildTask
    def set_MiningBuildTask(self, MiningBuildTask): self.MiningBuildTask = MiningBuildTask
    def get_DataDictionary(self): return self.DataDictionary
    def set_DataDictionary(self, DataDictionary): self.DataDictionary = DataDictionary
    def get_TransformationDictionary(self): return self.TransformationDictionary
    def set_TransformationDictionary(self, TransformationDictionary): self.TransformationDictionary = TransformationDictionary
    def get_AnomalyDetectionModel(self): return self.AnomalyDetectionModel
    def set_AnomalyDetectionModel(self, AnomalyDetectionModel): self.AnomalyDetectionModel = AnomalyDetectionModel
    def add_AnomalyDetectionModel(self, value): self.AnomalyDetectionModel.append(value)
    def insert_AnomalyDetectionModel_at(self, index, value): self.AnomalyDetectionModel.insert(index, value)
    def replace_AnomalyDetectionModel_at(self, index, value): self.AnomalyDetectionModel[index] = value
    def get_AssociationModel(self): return self.AssociationModel
    def set_AssociationModel(self, AssociationModel): self.AssociationModel = AssociationModel
    def add_AssociationModel(self, value): self.AssociationModel.append(value)
    def insert_AssociationModel_at(self, index, value): self.AssociationModel.insert(index, value)
    def replace_AssociationModel_at(self, index, value): self.AssociationModel[index] = value
    def get_BayesianNetworkModel(self): return self.BayesianNetworkModel
    def set_BayesianNetworkModel(self, BayesianNetworkModel): self.BayesianNetworkModel = BayesianNetworkModel
    def add_BayesianNetworkModel(self, value): self.BayesianNetworkModel.append(value)
    def insert_BayesianNetworkModel_at(self, index, value): self.BayesianNetworkModel.insert(index, value)
    def replace_BayesianNetworkModel_at(self, index, value): self.BayesianNetworkModel[index] = value
    def get_BaselineModel(self): return self.BaselineModel
    def set_BaselineModel(self, BaselineModel): self.BaselineModel = BaselineModel
    def add_BaselineModel(self, value): self.BaselineModel.append(value)
    def insert_BaselineModel_at(self, index, value): self.BaselineModel.insert(index, value)
    def replace_BaselineModel_at(self, index, value): self.BaselineModel[index] = value
    def get_ClusteringModel(self): return self.ClusteringModel
    def set_ClusteringModel(self, ClusteringModel): self.ClusteringModel = ClusteringModel
    def add_ClusteringModel(self, value): self.ClusteringModel.append(value)
    def insert_ClusteringModel_at(self, index, value): self.ClusteringModel.insert(index, value)
    def replace_ClusteringModel_at(self, index, value): self.ClusteringModel[index] = value
    def get_GaussianProcessModel(self): return self.GaussianProcessModel
    def set_GaussianProcessModel(self, GaussianProcessModel): self.GaussianProcessModel = GaussianProcessModel
    def add_GaussianProcessModel(self, value): self.GaussianProcessModel.append(value)
    def insert_GaussianProcessModel_at(self, index, value): self.GaussianProcessModel.insert(index, value)
    def replace_GaussianProcessModel_at(self, index, value): self.GaussianProcessModel[index] = value
    def get_GeneralRegressionModel(self): return self.GeneralRegressionModel
    def set_GeneralRegressionModel(self, GeneralRegressionModel): self.GeneralRegressionModel = GeneralRegressionModel
    def add_GeneralRegressionModel(self, value): self.GeneralRegressionModel.append(value)
    def insert_GeneralRegressionModel_at(self, index, value): self.GeneralRegressionModel.insert(index, value)
    def replace_GeneralRegressionModel_at(self, index, value): self.GeneralRegressionModel[index] = value
    def get_MiningModel(self): return self.MiningModel
    def set_MiningModel(self, MiningModel): self.MiningModel = MiningModel
    def add_MiningModel(self, value): self.MiningModel.append(value)
    def insert_MiningModel_at(self, index, value): self.MiningModel.insert(index, value)
    def replace_MiningModel_at(self, index, value): self.MiningModel[index] = value
    def get_NaiveBayesModel(self): return self.NaiveBayesModel
    def set_NaiveBayesModel(self, NaiveBayesModel): self.NaiveBayesModel = NaiveBayesModel
    def add_NaiveBayesModel(self, value): self.NaiveBayesModel.append(value)
    def insert_NaiveBayesModel_at(self, index, value): self.NaiveBayesModel.insert(index, value)
    def replace_NaiveBayesModel_at(self, index, value): self.NaiveBayesModel[index] = value
    def get_NearestNeighborModel(self): return self.NearestNeighborModel
    def set_NearestNeighborModel(self, NearestNeighborModel): self.NearestNeighborModel = NearestNeighborModel
    def add_NearestNeighborModel(self, value): self.NearestNeighborModel.append(value)
    def insert_NearestNeighborModel_at(self, index, value): self.NearestNeighborModel.insert(index, value)
    def replace_NearestNeighborModel_at(self, index, value): self.NearestNeighborModel[index] = value
    def get_NeuralNetwork(self): return self.NeuralNetwork
    def set_NeuralNetwork(self, NeuralNetwork): self.NeuralNetwork = NeuralNetwork
    def add_NeuralNetwork(self, value): self.NeuralNetwork.append(value)
    def insert_NeuralNetwork_at(self, index, value): self.NeuralNetwork.insert(index, value)
    def replace_NeuralNetwork_at(self, index, value): self.NeuralNetwork[index] = value
    def get_RegressionModel(self): return self.RegressionModel
    def set_RegressionModel(self, RegressionModel): self.RegressionModel = RegressionModel
    def add_RegressionModel(self, value): self.RegressionModel.append(value)
    def insert_RegressionModel_at(self, index, value): self.RegressionModel.insert(index, value)
    def replace_RegressionModel_at(self, index, value): self.RegressionModel[index] = value
    def get_RuleSetModel(self): return self.RuleSetModel
    def set_RuleSetModel(self, RuleSetModel): self.RuleSetModel = RuleSetModel
    def add_RuleSetModel(self, value): self.RuleSetModel.append(value)
    def insert_RuleSetModel_at(self, index, value): self.RuleSetModel.insert(index, value)
    def replace_RuleSetModel_at(self, index, value): self.RuleSetModel[index] = value
    def get_SequenceModel(self): return self.SequenceModel
    def set_SequenceModel(self, SequenceModel): self.SequenceModel = SequenceModel
    def add_SequenceModel(self, value): self.SequenceModel.append(value)
    def insert_SequenceModel_at(self, index, value): self.SequenceModel.insert(index, value)
    def replace_SequenceModel_at(self, index, value): self.SequenceModel[index] = value
    def get_Scorecard(self): return self.Scorecard
    def set_Scorecard(self, Scorecard): self.Scorecard = Scorecard
    def add_Scorecard(self, value): self.Scorecard.append(value)
    def insert_Scorecard_at(self, index, value): self.Scorecard.insert(index, value)
    def replace_Scorecard_at(self, index, value): self.Scorecard[index] = value
    def get_SupportVectorMachineModel(self): return self.SupportVectorMachineModel
    def set_SupportVectorMachineModel(self, SupportVectorMachineModel): self.SupportVectorMachineModel = SupportVectorMachineModel
    def add_SupportVectorMachineModel(self, value): self.SupportVectorMachineModel.append(value)
    def insert_SupportVectorMachineModel_at(self, index, value): self.SupportVectorMachineModel.insert(index, value)
    def replace_SupportVectorMachineModel_at(self, index, value): self.SupportVectorMachineModel[index] = value
    def get_TextModel(self): return self.TextModel
    def set_TextModel(self, TextModel): self.TextModel = TextModel
    def add_TextModel(self, value): self.TextModel.append(value)
    def insert_TextModel_at(self, index, value): self.TextModel.insert(index, value)
    def replace_TextModel_at(self, index, value): self.TextModel[index] = value
    def get_TimeSeriesModel(self): return self.TimeSeriesModel
    def set_TimeSeriesModel(self, TimeSeriesModel): self.TimeSeriesModel = TimeSeriesModel
    def add_TimeSeriesModel(self, value): self.TimeSeriesModel.append(value)
    def insert_TimeSeriesModel_at(self, index, value): self.TimeSeriesModel.insert(index, value)
    def replace_TimeSeriesModel_at(self, index, value): self.TimeSeriesModel[index] = value
    def get_TreeModel(self): return self.TreeModel
    def set_TreeModel(self, TreeModel): self.TreeModel = TreeModel
    def add_TreeModel(self, value): self.TreeModel.append(value)
    def insert_TreeModel_at(self, index, value): self.TreeModel.insert(index, value)
    def replace_TreeModel_at(self, index, value): self.TreeModel[index] = value
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (
            self.Header is not None or
            self.MiningBuildTask is not None or
            self.DataDictionary is not None or
            self.TransformationDictionary is not None or
            self.AnomalyDetectionModel or
            self.AssociationModel or
            self.BayesianNetworkModel or
            self.BaselineModel or
            self.ClusteringModel or
            self.GaussianProcessModel or
            self.GeneralRegressionModel or
            self.MiningModel or
            self.NaiveBayesModel or
            self.NearestNeighborModel or
            self.NeuralNetwork or
            self.RegressionModel or
            self.RuleSetModel or
            self.SequenceModel or
            self.Scorecard or
            self.SupportVectorMachineModel or
            self.TextModel or
            self.TimeSeriesModel or
            self.TreeModel or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PMML', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PMML')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PMML')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PMML', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PMML'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PMML', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Header is not None:
            self.Header.export(outfile, level, namespace_, name_='Header', pretty_print=pretty_print)
        if self.MiningBuildTask is not None:
            self.MiningBuildTask.export(outfile, level, namespace_, name_='MiningBuildTask', pretty_print=pretty_print)
        if self.DataDictionary is not None:
            self.DataDictionary.export(outfile, level, namespace_, name_='DataDictionary', pretty_print=pretty_print)
        if self.TransformationDictionary is not None:
            self.TransformationDictionary.export(outfile, level, namespace_, name_='TransformationDictionary', pretty_print=pretty_print)
        for AnomalyDetectionModel_ in self.AnomalyDetectionModel:
            AnomalyDetectionModel_.export(outfile, level, namespace_, name_='AnomalyDetectionModel', pretty_print=pretty_print)
        for AssociationModel_ in self.AssociationModel:
            AssociationModel_.export(outfile, level, namespace_, name_='AssociationModel', pretty_print=pretty_print)
        for BayesianNetworkModel_ in self.BayesianNetworkModel:
            BayesianNetworkModel_.export(outfile, level, namespace_, name_='BayesianNetworkModel', pretty_print=pretty_print)
        for BaselineModel_ in self.BaselineModel:
            BaselineModel_.export(outfile, level, namespace_, name_='BaselineModel', pretty_print=pretty_print)
        for ClusteringModel_ in self.ClusteringModel:
            ClusteringModel_.export(outfile, level, namespace_, name_='ClusteringModel', pretty_print=pretty_print)
        for GaussianProcessModel_ in self.GaussianProcessModel:
            GaussianProcessModel_.export(outfile, level, namespace_, name_='GaussianProcessModel', pretty_print=pretty_print)
        for GeneralRegressionModel_ in self.GeneralRegressionModel:
            GeneralRegressionModel_.export(outfile, level, namespace_, name_='GeneralRegressionModel', pretty_print=pretty_print)
        for MiningModel_ in self.MiningModel:
            MiningModel_.export(outfile, level, namespace_, name_='MiningModel', pretty_print=pretty_print)
        for NaiveBayesModel_ in self.NaiveBayesModel:
            NaiveBayesModel_.export(outfile, level, namespace_, name_='NaiveBayesModel', pretty_print=pretty_print)
        for NearestNeighborModel_ in self.NearestNeighborModel:
            NearestNeighborModel_.export(outfile, level, namespace_, name_='NearestNeighborModel', pretty_print=pretty_print)
        for NeuralNetwork_ in self.NeuralNetwork:
            NeuralNetwork_.export(outfile, level, namespace_, name_='NeuralNetwork', pretty_print=pretty_print)
        for RegressionModel_ in self.RegressionModel:
            RegressionModel_.export(outfile, level, namespace_, name_='RegressionModel', pretty_print=pretty_print)
        for RuleSetModel_ in self.RuleSetModel:
            RuleSetModel_.export(outfile, level, namespace_, name_='RuleSetModel', pretty_print=pretty_print)
        for SequenceModel_ in self.SequenceModel:
            SequenceModel_.export(outfile, level, namespace_, name_='SequenceModel', pretty_print=pretty_print)
        for Scorecard_ in self.Scorecard:
            Scorecard_.export(outfile, level, namespace_, name_='Scorecard', pretty_print=pretty_print)
        for SupportVectorMachineModel_ in self.SupportVectorMachineModel:
            SupportVectorMachineModel_.export(outfile, level, namespace_, name_='SupportVectorMachineModel', pretty_print=pretty_print)
        for TextModel_ in self.TextModel:
            TextModel_.export(outfile, level, namespace_, name_='TextModel', pretty_print=pretty_print)
        for TimeSeriesModel_ in self.TimeSeriesModel:
            TimeSeriesModel_.export(outfile, level, namespace_, name_='TimeSeriesModel', pretty_print=pretty_print)
        for TreeModel_ in self.TreeModel:
            TreeModel_.export(outfile, level, namespace_, name_='TreeModel', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PMML', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.version is not None:
            element.set('version', self.gds_format_string(self.version))
        if self.Header is not None:
            Header_ = self.Header
            Header_.to_etree(element, name_='Header', mapping_=mapping_)
        if self.MiningBuildTask is not None:
            MiningBuildTask_ = self.MiningBuildTask
            MiningBuildTask_.to_etree(element, name_='MiningBuildTask', mapping_=mapping_)
        if self.DataDictionary is not None:
            DataDictionary_ = self.DataDictionary
            DataDictionary_.to_etree(element, name_='DataDictionary', mapping_=mapping_)
        if self.TransformationDictionary is not None:
            TransformationDictionary_ = self.TransformationDictionary
            TransformationDictionary_.to_etree(element, name_='TransformationDictionary', mapping_=mapping_)
        for AnomalyDetectionModel_ in self.AnomalyDetectionModel:
            AnomalyDetectionModel_.to_etree(element, name_='AnomalyDetectionModel', mapping_=mapping_)
        for AssociationModel_ in self.AssociationModel:
            AssociationModel_.to_etree(element, name_='AssociationModel', mapping_=mapping_)
        for BayesianNetworkModel_ in self.BayesianNetworkModel:
            BayesianNetworkModel_.to_etree(element, name_='BayesianNetworkModel', mapping_=mapping_)
        for BaselineModel_ in self.BaselineModel:
            BaselineModel_.to_etree(element, name_='BaselineModel', mapping_=mapping_)
        for ClusteringModel_ in self.ClusteringModel:
            ClusteringModel_.to_etree(element, name_='ClusteringModel', mapping_=mapping_)
        for GaussianProcessModel_ in self.GaussianProcessModel:
            GaussianProcessModel_.to_etree(element, name_='GaussianProcessModel', mapping_=mapping_)
        for GeneralRegressionModel_ in self.GeneralRegressionModel:
            GeneralRegressionModel_.to_etree(element, name_='GeneralRegressionModel', mapping_=mapping_)
        for MiningModel_ in self.MiningModel:
            MiningModel_.to_etree(element, name_='MiningModel', mapping_=mapping_)
        for NaiveBayesModel_ in self.NaiveBayesModel:
            NaiveBayesModel_.to_etree(element, name_='NaiveBayesModel', mapping_=mapping_)
        for NearestNeighborModel_ in self.NearestNeighborModel:
            NearestNeighborModel_.to_etree(element, name_='NearestNeighborModel', mapping_=mapping_)
        for NeuralNetwork_ in self.NeuralNetwork:
            NeuralNetwork_.to_etree(element, name_='NeuralNetwork', mapping_=mapping_)
        for RegressionModel_ in self.RegressionModel:
            RegressionModel_.to_etree(element, name_='RegressionModel', mapping_=mapping_)
        for RuleSetModel_ in self.RuleSetModel:
            RuleSetModel_.to_etree(element, name_='RuleSetModel', mapping_=mapping_)
        for SequenceModel_ in self.SequenceModel:
            SequenceModel_.to_etree(element, name_='SequenceModel', mapping_=mapping_)
        for Scorecard_ in self.Scorecard:
            Scorecard_.to_etree(element, name_='Scorecard', mapping_=mapping_)
        for SupportVectorMachineModel_ in self.SupportVectorMachineModel:
            SupportVectorMachineModel_.to_etree(element, name_='SupportVectorMachineModel', mapping_=mapping_)
        for TextModel_ in self.TextModel:
            TextModel_.to_etree(element, name_='TextModel', mapping_=mapping_)
        for TimeSeriesModel_ in self.TimeSeriesModel:
            TimeSeriesModel_.to_etree(element, name_='TimeSeriesModel', mapping_=mapping_)
        for TreeModel_ in self.TreeModel:
            TreeModel_.to_etree(element, name_='TreeModel', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PMML'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Header is not None:
            showIndent(outfile, level)
            outfile.write('Header=model_.Header(\n')
            self.Header.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MiningBuildTask is not None:
            showIndent(outfile, level)
            outfile.write('MiningBuildTask=model_.MiningBuildTask(\n')
            self.MiningBuildTask.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataDictionary is not None:
            showIndent(outfile, level)
            outfile.write('DataDictionary=model_.DataDictionary(\n')
            self.DataDictionary.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TransformationDictionary is not None:
            showIndent(outfile, level)
            outfile.write('TransformationDictionary=model_.TransformationDictionary(\n')
            self.TransformationDictionary.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('AnomalyDetectionModel=[\n')
        level += 1
        for AnomalyDetectionModel_ in self.AnomalyDetectionModel:
            showIndent(outfile, level)
            outfile.write('model_.AnomalyDetectionModel(\n')
            AnomalyDetectionModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AssociationModel=[\n')
        level += 1
        for AssociationModel_ in self.AssociationModel:
            showIndent(outfile, level)
            outfile.write('model_.AssociationModel(\n')
            AssociationModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BayesianNetworkModel=[\n')
        level += 1
        for BayesianNetworkModel_ in self.BayesianNetworkModel:
            showIndent(outfile, level)
            outfile.write('model_.BayesianNetworkModel(\n')
            BayesianNetworkModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BaselineModel=[\n')
        level += 1
        for BaselineModel_ in self.BaselineModel:
            showIndent(outfile, level)
            outfile.write('model_.BaselineModel(\n')
            BaselineModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ClusteringModel=[\n')
        level += 1
        for ClusteringModel_ in self.ClusteringModel:
            showIndent(outfile, level)
            outfile.write('model_.ClusteringModel(\n')
            ClusteringModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaussianProcessModel=[\n')
        level += 1
        for GaussianProcessModel_ in self.GaussianProcessModel:
            showIndent(outfile, level)
            outfile.write('model_.GaussianProcessModel(\n')
            GaussianProcessModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GeneralRegressionModel=[\n')
        level += 1
        for GeneralRegressionModel_ in self.GeneralRegressionModel:
            showIndent(outfile, level)
            outfile.write('model_.GeneralRegressionModel(\n')
            GeneralRegressionModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MiningModel=[\n')
        level += 1
        for MiningModel_ in self.MiningModel:
            showIndent(outfile, level)
            outfile.write('model_.MiningModel(\n')
            MiningModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NaiveBayesModel=[\n')
        level += 1
        for NaiveBayesModel_ in self.NaiveBayesModel:
            showIndent(outfile, level)
            outfile.write('model_.NaiveBayesModel(\n')
            NaiveBayesModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NearestNeighborModel=[\n')
        level += 1
        for NearestNeighborModel_ in self.NearestNeighborModel:
            showIndent(outfile, level)
            outfile.write('model_.NearestNeighborModel(\n')
            NearestNeighborModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NeuralNetwork=[\n')
        level += 1
        for NeuralNetwork_ in self.NeuralNetwork:
            showIndent(outfile, level)
            outfile.write('model_.NeuralNetwork(\n')
            NeuralNetwork_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RegressionModel=[\n')
        level += 1
        for RegressionModel_ in self.RegressionModel:
            showIndent(outfile, level)
            outfile.write('model_.RegressionModel(\n')
            RegressionModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RuleSetModel=[\n')
        level += 1
        for RuleSetModel_ in self.RuleSetModel:
            showIndent(outfile, level)
            outfile.write('model_.RuleSetModel(\n')
            RuleSetModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SequenceModel=[\n')
        level += 1
        for SequenceModel_ in self.SequenceModel:
            showIndent(outfile, level)
            outfile.write('model_.SequenceModel(\n')
            SequenceModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Scorecard=[\n')
        level += 1
        for Scorecard_ in self.Scorecard:
            showIndent(outfile, level)
            outfile.write('model_.Scorecard(\n')
            Scorecard_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SupportVectorMachineModel=[\n')
        level += 1
        for SupportVectorMachineModel_ in self.SupportVectorMachineModel:
            showIndent(outfile, level)
            outfile.write('model_.SupportVectorMachineModel(\n')
            SupportVectorMachineModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TextModel=[\n')
        level += 1
        for TextModel_ in self.TextModel:
            showIndent(outfile, level)
            outfile.write('model_.TextModel(\n')
            TextModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TimeSeriesModel=[\n')
        level += 1
        for TimeSeriesModel_ in self.TimeSeriesModel:
            showIndent(outfile, level)
            outfile.write('model_.TimeSeriesModel(\n')
            TimeSeriesModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TreeModel=[\n')
        level += 1
        for TreeModel_ in self.TreeModel:
            showIndent(outfile, level)
            outfile.write('model_.TreeModel(\n')
            TreeModel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Header':
            obj_ = Header.factory()
            obj_.build(child_)
            self.Header = obj_
            obj_.original_tagname_ = 'Header'
        elif nodeName_ == 'MiningBuildTask':
            obj_ = MiningBuildTask.factory()
            obj_.build(child_)
            self.MiningBuildTask = obj_
            obj_.original_tagname_ = 'MiningBuildTask'
        elif nodeName_ == 'DataDictionary':
            obj_ = DataDictionary.factory()
            obj_.build(child_)
            self.DataDictionary = obj_
            obj_.original_tagname_ = 'DataDictionary'
        elif nodeName_ == 'TransformationDictionary':
            obj_ = TransformationDictionary.factory()
            obj_.build(child_)
            self.TransformationDictionary = obj_
            obj_.original_tagname_ = 'TransformationDictionary'
        elif nodeName_ == 'AnomalyDetectionModel':
            obj_ = AnomalyDetectionModel.factory()
            obj_.build(child_)
            self.AnomalyDetectionModel.append(obj_)
            obj_.original_tagname_ = 'AnomalyDetectionModel'
        elif nodeName_ == 'AssociationModel':
            obj_ = AssociationModel.factory()
            obj_.build(child_)
            self.AssociationModel.append(obj_)
            obj_.original_tagname_ = 'AssociationModel'
        elif nodeName_ == 'BayesianNetworkModel':
            obj_ = BayesianNetworkModel.factory()
            obj_.build(child_)
            self.BayesianNetworkModel.append(obj_)
            obj_.original_tagname_ = 'BayesianNetworkModel'
        elif nodeName_ == 'BaselineModel':
            obj_ = BaselineModel.factory()
            obj_.build(child_)
            self.BaselineModel.append(obj_)
            obj_.original_tagname_ = 'BaselineModel'
        elif nodeName_ == 'ClusteringModel':
            obj_ = ClusteringModel.factory()
            obj_.build(child_)
            self.ClusteringModel.append(obj_)
            obj_.original_tagname_ = 'ClusteringModel'
        elif nodeName_ == 'GaussianProcessModel':
            obj_ = GaussianProcessModel.factory()
            obj_.build(child_)
            self.GaussianProcessModel.append(obj_)
            obj_.original_tagname_ = 'GaussianProcessModel'
        elif nodeName_ == 'GeneralRegressionModel':
            obj_ = GeneralRegressionModel.factory()
            obj_.build(child_)
            self.GeneralRegressionModel.append(obj_)
            obj_.original_tagname_ = 'GeneralRegressionModel'
        elif nodeName_ == 'MiningModel':
            obj_ = MiningModel.factory()
            obj_.build(child_)
            self.MiningModel.append(obj_)
            obj_.original_tagname_ = 'MiningModel'
        elif nodeName_ == 'NaiveBayesModel':
            obj_ = NaiveBayesModel.factory()
            obj_.build(child_)
            self.NaiveBayesModel.append(obj_)
            obj_.original_tagname_ = 'NaiveBayesModel'
        elif nodeName_ == 'NearestNeighborModel':
            obj_ = NearestNeighborModel.factory()
            obj_.build(child_)
            self.NearestNeighborModel.append(obj_)
            obj_.original_tagname_ = 'NearestNeighborModel'
        elif nodeName_ == 'NeuralNetwork':
            obj_ = NeuralNetwork.factory()
            obj_.build(child_)
            self.NeuralNetwork.append(obj_)
            obj_.original_tagname_ = 'NeuralNetwork'
        elif nodeName_ == 'RegressionModel':
            obj_ = RegressionModel.factory()
            obj_.build(child_)
            self.RegressionModel.append(obj_)
            obj_.original_tagname_ = 'RegressionModel'
        elif nodeName_ == 'RuleSetModel':
            obj_ = RuleSetModel.factory()
            obj_.build(child_)
            self.RuleSetModel.append(obj_)
            obj_.original_tagname_ = 'RuleSetModel'
        elif nodeName_ == 'SequenceModel':
            obj_ = SequenceModel.factory()
            obj_.build(child_)
            self.SequenceModel.append(obj_)
            obj_.original_tagname_ = 'SequenceModel'
        elif nodeName_ == 'Scorecard':
            obj_ = Scorecard.factory()
            obj_.build(child_)
            self.Scorecard.append(obj_)
            obj_.original_tagname_ = 'Scorecard'
        elif nodeName_ == 'SupportVectorMachineModel':
            obj_ = SupportVectorMachineModel.factory()
            obj_.build(child_)
            self.SupportVectorMachineModel.append(obj_)
            obj_.original_tagname_ = 'SupportVectorMachineModel'
        elif nodeName_ == 'TextModel':
            obj_ = TextModel.factory()
            obj_.build(child_)
            self.TextModel.append(obj_)
            obj_.original_tagname_ = 'TextModel'
        elif nodeName_ == 'TimeSeriesModel':
            obj_ = TimeSeriesModel.factory()
            obj_.build(child_)
            self.TimeSeriesModel.append(obj_)
            obj_.original_tagname_ = 'TimeSeriesModel'
        elif nodeName_ == 'TreeModel':
            obj_ = TreeModel.factory()
            obj_.build(child_)
            self.TreeModel.append(obj_)
            obj_.original_tagname_ = 'TreeModel'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class PMML


class MiningBuildTask(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MiningBuildTask)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MiningBuildTask.subclass:
            return MiningBuildTask.subclass(*args_, **kwargs_)
        else:
            return MiningBuildTask(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MiningBuildTask', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MiningBuildTask')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MiningBuildTask')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MiningBuildTask', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MiningBuildTask'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MiningBuildTask', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MiningBuildTask', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MiningBuildTask'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class MiningBuildTask


class Extension(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extender=None, name=None, value=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.extender = _cast(None, extender)
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.elementobjs_ = []
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Extension)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Extension.subclass:
            return Extension.subclass(*args_, **kwargs_)
        else:
            return Extension(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_extender(self): return self.extender
    def set_extender(self, extender): self.extender = extender
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.anytypeobjs_ or self.elementobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Extension', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Extension')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Extension')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Extension', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Extension'):
        if self.extender is not None and 'extender' not in already_processed:
            already_processed.add('extender')
            outfile.write(' extender=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.extender), input_name='extender')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Extension', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            try:
                obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
            except:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write(eol_)
        for objName_ in self.elementobjs_:
            obj_ = eval("self." + objName_)
            if eval("isinstance(obj_, list)"):
                for s in obj_:
                    showIndent(outfile, level, pretty_print)
                    outfile.write("<" + objName_ + ">" + str(s) + "</" + objName_ + ">")
                    outfile.write(eol_)
            else:
                showIndent(outfile, level, pretty_print)
                outfile.write("<" + objName_ + ">" + str(obj_) + "</" + objName_ + ">")
                outfile.write(eol_)
    def to_etree(self, parent_element=None, name_='Extension', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.extender is not None:
            element.set('extender', self.gds_format_string(self.extender))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        for obj_ in self.anytypeobjs_:
            obj_.to_etree(element)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Extension'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.extender is not None and 'extender' not in already_processed:
            already_processed.add('extender')
            showIndent(outfile, level)
            outfile.write('extender="%s",\n' % (self.extender,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        if self.anytypeobjs_ == []:
            self.anytypeobjs_ = list(filter(None, [obj_.lstrip(' ') for obj_ in node.text.split('\n')]))
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('extender', node)
        if value is not None and 'extender' not in already_processed:
            already_processed.add('extender')
            self.extender = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not hasattr(self, "elementobjs_"):
            self.elementobjs_ = []
        if hasattr(self, nodeName_) and nodeName_ not in self.elementobjs_:
            nodeName_ += '_'
        if nodeName_ not in self.elementobjs_:
            self.elementobjs_.append(nodeName_)
        if not eval("hasattr(self, '" + nodeName_ + "')"):
            exec("self." + nodeName_ + " = " + list(filter(None, [obj_.lstrip(' ') for obj_ in child_.text.split('\n')]))[0])
        else:
            exec("self." + nodeName_ + " = list(self." + nodeName_ + ")")
            exec("self." + nodeName_ + ".append(" + list(filter(None, [obj_.lstrip(' ') for obj_ in child_.text.split('\n')]))[0] + ")")
# end class Extension


class ArrayType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, n=None, type_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.n = _cast(None, n)
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArrayType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArrayType.subclass:
            return ArrayType.subclass(*args_, **kwargs_)
        else:
            return ArrayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_n(self): return self.n
    def set_n(self, n): self.n = n
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ArrayType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArrayType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArrayType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArrayType'):
        if self.n is not None and 'n' not in already_processed:
            already_processed.add('n')
            outfile.write(' n=%s' % (quote_attrib(self.n), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ArrayType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='ArrayType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.n is not None:
            element.set('n', self.n)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ArrayType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.n is not None and 'n' not in already_processed:
            already_processed.add('n')
            showIndent(outfile, level)
            outfile.write('n=%d,\n' % (self.n,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('n', node)
        if value is not None and 'n' not in already_processed:
            already_processed.add('n')
            try:
                self.n = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.n)    # validate type INT-NUMBER
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class ArrayType


class INT_SparseArray(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, n=None, defaultValue='0', Indices=None, INT_Entries=None):
        self.original_tagname_ = None
        self.n = _cast(None, n)
        self.defaultValue = _cast(None, defaultValue)
        self.Indices = Indices
        self.validate_Indices(self.Indices)
        self.INT_Entries = INT_Entries
        self.validate_INT_Entries(self.INT_Entries)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INT_SparseArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INT_SparseArray.subclass:
            return INT_SparseArray.subclass(*args_, **kwargs_)
        else:
            return INT_SparseArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Indices(self): return self.Indices
    def set_Indices(self, Indices): self.Indices = Indices
    def get_INT_Entries(self): return self.INT_Entries
    def set_INT_Entries(self, INT_Entries): self.INT_Entries = INT_Entries
    def get_n(self): return self.n
    def set_n(self, n): self.n = n
    def get_defaultValue(self): return self.defaultValue
    def set_defaultValue(self, defaultValue): self.defaultValue = defaultValue
    def validate_Indices(self, value):
        # Validate type Indices, a restriction on xs:int.
        pass
    def validate_INT_Entries(self, value):
        # Validate type INT-Entries, a restriction on xs:int.
        pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Indices is not None or
            self.INT_Entries is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='INT-SparseArray', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INT-SparseArray')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='INT-SparseArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='INT-SparseArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='INT-SparseArray'):
        if self.n is not None and 'n' not in already_processed:
            already_processed.add('n')
            outfile.write(' n=%s' % (quote_attrib(self.n), ))
        if self.defaultValue != 0 and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            outfile.write(' defaultValue=%s' % (quote_attrib(self.defaultValue), ))
    def exportChildren(self, outfile, level, namespace_='', name_='INT-SparseArray', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Indices is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndices>%s</%sIndices>%s' % (namespace_, self.gds_format_integer_list(self.Indices, input_name='Indices'), namespace_, eol_))
        if self.INT_Entries is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINT-Entries>%s</%sINT-Entries>%s' % (namespace_, self.gds_format_integer_list(self.INT_Entries, input_name='INT-Entries'), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='INT-SparseArray', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.n is not None:
            element.set('n', self.n)
        if self.defaultValue is not None:
            element.set('defaultValue', self.defaultValue)
        if self.Indices is not None:
            Indices_ = self.Indices
            etree_.SubElement(element, '{http://www.dmg.org/PMML-4_4}Indices').text = self.gds_format_integer_list(Indices_)
        if self.INT_Entries is not None:
            INT_Entries_ = self.INT_Entries
            etree_.SubElement(element, '{http://www.dmg.org/PMML-4_4}INT-Entries').text = self.gds_format_integer_list(INT_Entries_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='INT-SparseArray'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.n is not None and 'n' not in already_processed:
            already_processed.add('n')
            showIndent(outfile, level)
            outfile.write('n=%d,\n' % (self.n,))
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            showIndent(outfile, level)
            outfile.write('defaultValue=%d,\n' % (self.defaultValue,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Indices is not None:
            showIndent(outfile, level)
            outfile.write('Indices=%d,\n' % self.Indices)
        if self.INT_Entries is not None:
            showIndent(outfile, level)
            outfile.write('INT_Entries=%d,\n' % self.INT_Entries)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('n', node)
        if value is not None and 'n' not in already_processed:
            already_processed.add('n')
            try:
                self.n = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.n)    # validate type INT-NUMBER
        value = find_attr_value_('defaultValue', node)
        if value is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            try:
                self.defaultValue = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.defaultValue)    # validate type INT-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Indices':
            Indices_ = child_.text
            Indices_ = self.gds_validate_integer_list(Indices_, node, 'Indices')
            self.Indices = Indices_
            # validate type Indices
            self.validate_Indices(self.Indices)
        elif nodeName_ == 'INT-Entries':
            INT_Entries_ = child_.text
            INT_Entries_ = self.gds_validate_integer_list(INT_Entries_, node, 'INT_Entries')
            self.INT_Entries = INT_Entries_
            # validate type INT-Entries
            self.validate_INT_Entries(self.INT_Entries)
# end class INT_SparseArray


class REAL_SparseArray(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, n=None, defaultValue='0', Indices=None, REAL_Entries=None):
        self.original_tagname_ = None
        self.n = _cast(None, n)
        self.defaultValue = _cast(None, defaultValue)
        self.Indices = Indices
        self.validate_Indices(self.Indices)
        self.REAL_Entries = REAL_Entries
        self.validate_REAL_Entries(self.REAL_Entries)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, REAL_SparseArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if REAL_SparseArray.subclass:
            return REAL_SparseArray.subclass(*args_, **kwargs_)
        else:
            return REAL_SparseArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Indices(self): return self.Indices
    def set_Indices(self, Indices): self.Indices = Indices
    def get_REAL_Entries(self): return self.REAL_Entries
    def set_REAL_Entries(self, REAL_Entries): self.REAL_Entries = REAL_Entries
    def get_n(self): return self.n
    def set_n(self, n): self.n = n
    def get_defaultValue(self): return self.defaultValue
    def set_defaultValue(self, defaultValue): self.defaultValue = defaultValue
    def validate_Indices(self, value):
        # Validate type Indices, a restriction on xs:int.
        pass
    def validate_REAL_Entries(self, value):
        # Validate type REAL-Entries, a restriction on xs:double.
        pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Indices is not None or
            self.REAL_Entries is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='REAL-SparseArray', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('REAL-SparseArray')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='REAL-SparseArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='REAL-SparseArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='REAL-SparseArray'):
        if self.n is not None and 'n' not in already_processed:
            already_processed.add('n')
            outfile.write(' n=%s' % (quote_attrib(self.n), ))
        if self.defaultValue != 0 and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            outfile.write(' defaultValue=%s' % (quote_attrib(self.defaultValue), ))
    def exportChildren(self, outfile, level, namespace_='', name_='REAL-SparseArray', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Indices is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndices>%s</%sIndices>%s' % (namespace_, self.gds_format_integer_list(self.Indices, input_name='Indices'), namespace_, eol_))
        if self.REAL_Entries is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAL-Entries>%s</%sREAL-Entries>%s' % (namespace_, self.gds_format_double_list(self.REAL_Entries, input_name='REAL-Entries'), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='REAL-SparseArray', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.n is not None:
            element.set('n', self.n)
        if self.defaultValue is not None:
            element.set('defaultValue', self.defaultValue)
        if self.Indices is not None:
            Indices_ = self.Indices
            etree_.SubElement(element, '{http://www.dmg.org/PMML-4_4}Indices').text = self.gds_format_integer_list(Indices_)
        if self.REAL_Entries is not None:
            REAL_Entries_ = self.REAL_Entries
            etree_.SubElement(element, '{http://www.dmg.org/PMML-4_4}REAL-Entries').text = self.gds_format_double_list(REAL_Entries_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='REAL-SparseArray'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.n is not None and 'n' not in already_processed:
            already_processed.add('n')
            showIndent(outfile, level)
            outfile.write('n=%d,\n' % (self.n,))
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            showIndent(outfile, level)
            outfile.write('defaultValue=%e,\n' % (self.defaultValue,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Indices is not None:
            showIndent(outfile, level)
            outfile.write('Indices=%d,\n' % self.Indices)
        if self.REAL_Entries is not None:
            showIndent(outfile, level)
            outfile.write('REAL_Entries=%e,\n' % self.REAL_Entries)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('n', node)
        if value is not None and 'n' not in already_processed:
            already_processed.add('n')
            try:
                self.n = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.n)    # validate type INT-NUMBER
        value = find_attr_value_('defaultValue', node)
        if value is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            try:
                self.defaultValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (defaultValue): %s' % exp)
            self.validate_REAL_NUMBER(self.defaultValue)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Indices':
            Indices_ = child_.text
            Indices_ = self.gds_validate_integer_list(Indices_, node, 'Indices')
            self.Indices = Indices_
            # validate type Indices
            self.validate_Indices(self.Indices)
        elif nodeName_ == 'REAL-Entries':
            REAL_Entries_ = child_.text
            REAL_Entries_ = self.gds_validate_double_list(REAL_Entries_, node, 'REAL_Entries')
            self.REAL_Entries = REAL_Entries_
            # validate type REAL-Entries
            self.validate_REAL_Entries(self.REAL_Entries)
# end class REAL_SparseArray


class Indices(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Indices)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Indices.subclass:
            return Indices.subclass(*args_, **kwargs_)
        else:
            return Indices(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Indices', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Indices')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Indices')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Indices', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Indices'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Indices', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='Indices', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Indices'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Indices


class INT_Entries(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INT_Entries)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INT_Entries.subclass:
            return INT_Entries.subclass(*args_, **kwargs_)
        else:
            return INT_Entries(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='INT-Entries', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INT-Entries')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='INT-Entries')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='INT-Entries', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='INT-Entries'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='INT-Entries', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='INT-Entries', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='INT-Entries'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class INT_Entries


class REAL_Entries(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, REAL_Entries)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if REAL_Entries.subclass:
            return REAL_Entries.subclass(*args_, **kwargs_)
        else:
            return REAL_Entries(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='REAL-Entries', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('REAL-Entries')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='REAL-Entries')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='REAL-Entries', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='REAL-Entries'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='REAL-Entries', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='REAL-Entries', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='REAL-Entries'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class REAL_Entries


class Matrix(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, kind='any', nbRows=None, nbCols=None, diagDefault=None, offDiagDefault=None, Array=None, MatCell=None):
        self.original_tagname_ = None
        self.kind = _cast(None, kind)
        self.nbRows = _cast(None, nbRows)
        self.nbCols = _cast(None, nbCols)
        self.diagDefault = _cast(None, diagDefault)
        self.offDiagDefault = _cast(None, offDiagDefault)
        if Array is None:
            self.Array = []
        else:
            self.Array = Array
        if MatCell is None:
            self.MatCell = []
        else:
            self.MatCell = MatCell
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Matrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Matrix.subclass:
            return Matrix.subclass(*args_, **kwargs_)
        else:
            return Matrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def add_Array(self, value): self.Array.append(value)
    def insert_Array_at(self, index, value): self.Array.insert(index, value)
    def replace_Array_at(self, index, value): self.Array[index] = value
    def get_MatCell(self): return self.MatCell
    def set_MatCell(self, MatCell): self.MatCell = MatCell
    def add_MatCell(self, value): self.MatCell.append(value)
    def insert_MatCell_at(self, index, value): self.MatCell.insert(index, value)
    def replace_MatCell_at(self, index, value): self.MatCell[index] = value
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    def get_nbRows(self): return self.nbRows
    def set_nbRows(self, nbRows): self.nbRows = nbRows
    def get_nbCols(self): return self.nbCols
    def set_nbCols(self, nbCols): self.nbCols = nbCols
    def get_diagDefault(self): return self.diagDefault
    def set_diagDefault(self, diagDefault): self.diagDefault = diagDefault
    def get_offDiagDefault(self): return self.offDiagDefault
    def set_offDiagDefault(self, offDiagDefault): self.offDiagDefault = offDiagDefault
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Array or
            self.MatCell
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Matrix', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Matrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Matrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Matrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Matrix'):
        if self.kind != "any" and 'kind' not in already_processed:
            already_processed.add('kind')
            outfile.write(' kind=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.kind), input_name='kind')), ))
        if self.nbRows is not None and 'nbRows' not in already_processed:
            already_processed.add('nbRows')
            outfile.write(' nbRows=%s' % (quote_attrib(self.nbRows), ))
        if self.nbCols is not None and 'nbCols' not in already_processed:
            already_processed.add('nbCols')
            outfile.write(' nbCols=%s' % (quote_attrib(self.nbCols), ))
        if self.diagDefault is not None and 'diagDefault' not in already_processed:
            already_processed.add('diagDefault')
            outfile.write(' diagDefault=%s' % (quote_attrib(self.diagDefault), ))
        if self.offDiagDefault is not None and 'offDiagDefault' not in already_processed:
            already_processed.add('offDiagDefault')
            outfile.write(' offDiagDefault=%s' % (quote_attrib(self.offDiagDefault), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Matrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Array_ in self.Array:
            Array_.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
        for MatCell_ in self.MatCell:
            MatCell_.export(outfile, level, namespace_, name_='MatCell', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Matrix', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.kind is not None:
            element.set('kind', self.gds_format_string(self.kind))
        if self.nbRows is not None:
            element.set('nbRows', self.nbRows)
        if self.nbCols is not None:
            element.set('nbCols', self.nbCols)
        if self.diagDefault is not None:
            element.set('diagDefault', self.diagDefault)
        if self.offDiagDefault is not None:
            element.set('offDiagDefault', self.offDiagDefault)
        for Array_ in self.Array:
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        for MatCell_ in self.MatCell:
            MatCell_.to_etree(element, name_='MatCell', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Matrix'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            showIndent(outfile, level)
            outfile.write('kind="%s",\n' % (self.kind,))
        if self.nbRows is not None and 'nbRows' not in already_processed:
            already_processed.add('nbRows')
            showIndent(outfile, level)
            outfile.write('nbRows=%d,\n' % (self.nbRows,))
        if self.nbCols is not None and 'nbCols' not in already_processed:
            already_processed.add('nbCols')
            showIndent(outfile, level)
            outfile.write('nbCols=%d,\n' % (self.nbCols,))
        if self.diagDefault is not None and 'diagDefault' not in already_processed:
            already_processed.add('diagDefault')
            showIndent(outfile, level)
            outfile.write('diagDefault=%e,\n' % (self.diagDefault,))
        if self.offDiagDefault is not None and 'offDiagDefault' not in already_processed:
            already_processed.add('offDiagDefault')
            showIndent(outfile, level)
            outfile.write('offDiagDefault=%e,\n' % (self.offDiagDefault,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Array=[\n')
        level += 1
        for Array_ in self.Array:
            showIndent(outfile, level)
            outfile.write('model_.Array(\n')
            Array_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MatCell=[\n')
        level += 1
        for MatCell_ in self.MatCell:
            showIndent(outfile, level)
            outfile.write('model_.MatCell(\n')
            MatCell_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('kind', node)
        if value is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            self.kind = value
        value = find_attr_value_('nbRows', node)
        if value is not None and 'nbRows' not in already_processed:
            already_processed.add('nbRows')
            try:
                self.nbRows = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.nbRows)    # validate type INT-NUMBER
        value = find_attr_value_('nbCols', node)
        if value is not None and 'nbCols' not in already_processed:
            already_processed.add('nbCols')
            try:
                self.nbCols = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.nbCols)    # validate type INT-NUMBER
        value = find_attr_value_('diagDefault', node)
        if value is not None and 'diagDefault' not in already_processed:
            already_processed.add('diagDefault')
            try:
                self.diagDefault = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (diagDefault): %s' % exp)
            self.validate_REAL_NUMBER(self.diagDefault)    # validate type REAL-NUMBER
        value = find_attr_value_('offDiagDefault', node)
        if value is not None and 'offDiagDefault' not in already_processed:
            already_processed.add('offDiagDefault')
            try:
                self.offDiagDefault = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (offDiagDefault): %s' % exp)
            self.validate_REAL_NUMBER(self.offDiagDefault)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array.append(obj_)
            obj_.original_tagname_ = 'Array'
        elif nodeName_ == 'MatCell':
            obj_ = MatCell.factory()
            obj_.build(child_)
            self.MatCell.append(obj_)
            obj_.original_tagname_ = 'MatCell'
# end class Matrix


class MatCell(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, row=None, col=None, valueOf_=None):
        self.original_tagname_ = None
        self.row = _cast(None, row)
        self.col = _cast(None, col)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MatCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MatCell.subclass:
            return MatCell.subclass(*args_, **kwargs_)
        else:
            return MatCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def get_col(self): return self.col
    def set_col(self, col): self.col = col
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MatCell', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MatCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MatCell')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MatCell', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MatCell'):
        if self.row is not None and 'row' not in already_processed:
            already_processed.add('row')
            outfile.write(' row=%s' % (quote_attrib(self.row), ))
        if self.col is not None and 'col' not in already_processed:
            already_processed.add('col')
            outfile.write(' col=%s' % (quote_attrib(self.col), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MatCell', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='MatCell', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.row is not None:
            element.set('row', self.row)
        if self.col is not None:
            element.set('col', self.col)
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MatCell'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.row is not None and 'row' not in already_processed:
            already_processed.add('row')
            showIndent(outfile, level)
            outfile.write('row=%d,\n' % (self.row,))
        if self.col is not None and 'col' not in already_processed:
            already_processed.add('col')
            showIndent(outfile, level)
            outfile.write('col=%d,\n' % (self.col,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('row', node)
        if value is not None and 'row' not in already_processed:
            already_processed.add('row')
            try:
                self.row = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.row)    # validate type INT-NUMBER
        value = find_attr_value_('col', node)
        if value is not None and 'col' not in already_processed:
            already_processed.add('col')
            try:
                self.col = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.col)    # validate type INT-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MatCell


class RegressionModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, modelType=None, targetFieldName=None, normalizationMethod='none', isScorable=True, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, RegressionTable=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.modelType = _cast(None, modelType)
        self.targetFieldName = _cast(None, targetFieldName)
        self.normalizationMethod = _cast(None, normalizationMethod)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.ModelExplanation = ModelExplanation
        self.Targets = Targets
        self.LocalTransformations = LocalTransformations
        if RegressionTable is None:
            self.RegressionTable = []
        else:
            self.RegressionTable = RegressionTable
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegressionModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegressionModel.subclass:
            return RegressionModel.subclass(*args_, **kwargs_)
        else:
            return RegressionModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_ModelExplanation(self): return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation): self.ModelExplanation = ModelExplanation
    def get_Targets(self): return self.Targets
    def set_Targets(self, Targets): self.Targets = Targets
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_RegressionTable(self): return self.RegressionTable
    def set_RegressionTable(self, RegressionTable): self.RegressionTable = RegressionTable
    def add_RegressionTable(self, value): self.RegressionTable.append(value)
    def insert_RegressionTable_at(self, index, value): self.RegressionTable.insert(index, value)
    def replace_RegressionTable_at(self, index, value): self.RegressionTable[index] = value
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_modelType(self): return self.modelType
    def set_modelType(self, modelType): self.modelType = modelType
    def get_targetFieldName(self): return self.targetFieldName
    def set_targetFieldName(self, targetFieldName): self.targetFieldName = targetFieldName
    def get_normalizationMethod(self): return self.normalizationMethod
    def set_normalizationMethod(self, normalizationMethod): self.normalizationMethod = normalizationMethod
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REGRESSIONNORMALIZATIONMETHOD(self, value):
        # Validate type REGRESSIONNORMALIZATIONMETHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'simplemax', 'softmax', 'logit', 'probit', 'cloglog', 'exp', 'loglog', 'cauchit']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on REGRESSIONNORMALIZATIONMETHOD' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.RegressionTable or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RegressionModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RegressionModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegressionModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RegressionModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegressionModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.modelType is not None and 'modelType' not in already_processed:
            already_processed.add('modelType')
            outfile.write(' modelType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelType), input_name='modelType')), ))
        if self.targetFieldName is not None and 'targetFieldName' not in already_processed:
            already_processed.add('targetFieldName')
            outfile.write(' targetFieldName=%s' % (quote_attrib(self.targetFieldName), ))
        if self.normalizationMethod != "none" and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            outfile.write(' normalizationMethod=%s' % (quote_attrib(self.normalizationMethod), ))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='RegressionModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            self.ModelExplanation.export(outfile, level, namespace_, name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            self.Targets.export(outfile, level, namespace_, name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        for RegressionTable_ in self.RegressionTable:
            RegressionTable_.export(outfile, level, namespace_, name_='RegressionTable', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='RegressionModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.modelType is not None:
            element.set('modelType', self.gds_format_string(self.modelType))
        if self.targetFieldName is not None:
            element.set('targetFieldName', self.targetFieldName)
        if self.normalizationMethod is not None:
            element.set('normalizationMethod', self.normalizationMethod)
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.ModelExplanation is not None:
            ModelExplanation_ = self.ModelExplanation
            ModelExplanation_.to_etree(element, name_='ModelExplanation', mapping_=mapping_)
        if self.Targets is not None:
            Targets_ = self.Targets
            Targets_.to_etree(element, name_='Targets', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        for RegressionTable_ in self.RegressionTable:
            RegressionTable_.to_etree(element, name_='RegressionTable', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='RegressionModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.modelType is not None and 'modelType' not in already_processed:
            already_processed.add('modelType')
            showIndent(outfile, level)
            outfile.write('modelType="%s",\n' % (self.modelType,))
        if self.targetFieldName is not None and 'targetFieldName' not in already_processed:
            already_processed.add('targetFieldName')
            showIndent(outfile, level)
            outfile.write('targetFieldName="%s",\n' % (self.targetFieldName,))
        if self.normalizationMethod is not None and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            showIndent(outfile, level)
            outfile.write('normalizationMethod="%s",\n' % (self.normalizationMethod,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelExplanation is not None:
            showIndent(outfile, level)
            outfile.write('ModelExplanation=model_.ModelExplanation(\n')
            self.ModelExplanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targets is not None:
            showIndent(outfile, level)
            outfile.write('Targets=model_.Targets(\n')
            self.Targets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('RegressionTable=[\n')
        level += 1
        for RegressionTable_ in self.RegressionTable:
            showIndent(outfile, level)
            outfile.write('model_.RegressionTable(\n')
            RegressionTable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('modelType', node)
        if value is not None and 'modelType' not in already_processed:
            already_processed.add('modelType')
            self.modelType = value
        value = find_attr_value_('targetFieldName', node)
        if value is not None and 'targetFieldName' not in already_processed:
            already_processed.add('targetFieldName')
            self.targetFieldName = value
            self.validate_FIELD_NAME(self.targetFieldName)    # validate type FIELD-NAME
        value = find_attr_value_('normalizationMethod', node)
        if value is not None and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            self.normalizationMethod = value
            self.validate_REGRESSIONNORMALIZATIONMETHOD(self.normalizationMethod)    # validate type REGRESSIONNORMALIZATIONMETHOD
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory()
            obj_.build(child_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory()
            obj_.build(child_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'RegressionTable':
            obj_ = RegressionTable.factory()
            obj_.build(child_)
            self.RegressionTable.append(obj_)
            obj_.original_tagname_ = 'RegressionTable'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class RegressionModel


class RegressionTable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, intercept=None, targetCategory=None, Extension=None, NumericPredictor=None, CategoricalPredictor=None, PredictorTerm=None):
        self.original_tagname_ = None
        self.intercept = _cast(None, intercept)
        self.targetCategory = _cast(None, targetCategory)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if NumericPredictor is None:
            self.NumericPredictor = []
        else:
            self.NumericPredictor = NumericPredictor
        if CategoricalPredictor is None:
            self.CategoricalPredictor = []
        else:
            self.CategoricalPredictor = CategoricalPredictor
        if PredictorTerm is None:
            self.PredictorTerm = []
        else:
            self.PredictorTerm = PredictorTerm
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegressionTable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegressionTable.subclass:
            return RegressionTable.subclass(*args_, **kwargs_)
        else:
            return RegressionTable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_NumericPredictor(self): return self.NumericPredictor
    def set_NumericPredictor(self, NumericPredictor): self.NumericPredictor = NumericPredictor
    def add_NumericPredictor(self, value): self.NumericPredictor.append(value)
    def insert_NumericPredictor_at(self, index, value): self.NumericPredictor.insert(index, value)
    def replace_NumericPredictor_at(self, index, value): self.NumericPredictor[index] = value
    def get_CategoricalPredictor(self): return self.CategoricalPredictor
    def set_CategoricalPredictor(self, CategoricalPredictor): self.CategoricalPredictor = CategoricalPredictor
    def add_CategoricalPredictor(self, value): self.CategoricalPredictor.append(value)
    def insert_CategoricalPredictor_at(self, index, value): self.CategoricalPredictor.insert(index, value)
    def replace_CategoricalPredictor_at(self, index, value): self.CategoricalPredictor[index] = value
    def get_PredictorTerm(self): return self.PredictorTerm
    def set_PredictorTerm(self, PredictorTerm): self.PredictorTerm = PredictorTerm
    def add_PredictorTerm(self, value): self.PredictorTerm.append(value)
    def insert_PredictorTerm_at(self, index, value): self.PredictorTerm.insert(index, value)
    def replace_PredictorTerm_at(self, index, value): self.PredictorTerm[index] = value
    def get_intercept(self): return self.intercept
    def set_intercept(self, intercept): self.intercept = intercept
    def get_targetCategory(self): return self.targetCategory
    def set_targetCategory(self, targetCategory): self.targetCategory = targetCategory
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.NumericPredictor or
            self.CategoricalPredictor or
            self.PredictorTerm
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RegressionTable', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RegressionTable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegressionTable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RegressionTable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegressionTable'):
        if self.intercept is not None and 'intercept' not in already_processed:
            already_processed.add('intercept')
            outfile.write(' intercept=%s' % (quote_attrib(self.intercept), ))
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            outfile.write(' targetCategory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetCategory), input_name='targetCategory')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RegressionTable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for NumericPredictor_ in self.NumericPredictor:
            NumericPredictor_.export(outfile, level, namespace_, name_='NumericPredictor', pretty_print=pretty_print)
        for CategoricalPredictor_ in self.CategoricalPredictor:
            CategoricalPredictor_.export(outfile, level, namespace_, name_='CategoricalPredictor', pretty_print=pretty_print)
        for PredictorTerm_ in self.PredictorTerm:
            PredictorTerm_.export(outfile, level, namespace_, name_='PredictorTerm', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='RegressionTable', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.intercept is not None:
            element.set('intercept', self.intercept)
        if self.targetCategory is not None:
            element.set('targetCategory', self.gds_format_string(self.targetCategory))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for NumericPredictor_ in self.NumericPredictor:
            NumericPredictor_.to_etree(element, name_='NumericPredictor', mapping_=mapping_)
        for CategoricalPredictor_ in self.CategoricalPredictor:
            CategoricalPredictor_.to_etree(element, name_='CategoricalPredictor', mapping_=mapping_)
        for PredictorTerm_ in self.PredictorTerm:
            PredictorTerm_.to_etree(element, name_='PredictorTerm', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='RegressionTable'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.intercept is not None and 'intercept' not in already_processed:
            already_processed.add('intercept')
            showIndent(outfile, level)
            outfile.write('intercept=%e,\n' % (self.intercept,))
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            showIndent(outfile, level)
            outfile.write('targetCategory="%s",\n' % (self.targetCategory,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NumericPredictor=[\n')
        level += 1
        for NumericPredictor_ in self.NumericPredictor:
            showIndent(outfile, level)
            outfile.write('model_.NumericPredictor(\n')
            NumericPredictor_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CategoricalPredictor=[\n')
        level += 1
        for CategoricalPredictor_ in self.CategoricalPredictor:
            showIndent(outfile, level)
            outfile.write('model_.CategoricalPredictor(\n')
            CategoricalPredictor_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PredictorTerm=[\n')
        level += 1
        for PredictorTerm_ in self.PredictorTerm:
            showIndent(outfile, level)
            outfile.write('model_.PredictorTerm(\n')
            PredictorTerm_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('intercept', node)
        if value is not None and 'intercept' not in already_processed:
            already_processed.add('intercept')
            try:
                self.intercept = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (intercept): %s' % exp)
            self.validate_REAL_NUMBER(self.intercept)    # validate type REAL-NUMBER
        value = find_attr_value_('targetCategory', node)
        if value is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            self.targetCategory = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'NumericPredictor':
            obj_ = NumericPredictor.factory()
            obj_.build(child_)
            self.NumericPredictor.append(obj_)
            obj_.original_tagname_ = 'NumericPredictor'
        elif nodeName_ == 'CategoricalPredictor':
            obj_ = CategoricalPredictor.factory()
            obj_.build(child_)
            self.CategoricalPredictor.append(obj_)
            obj_.original_tagname_ = 'CategoricalPredictor'
        elif nodeName_ == 'PredictorTerm':
            obj_ = PredictorTerm.factory()
            obj_.build(child_)
            self.PredictorTerm.append(obj_)
            obj_.original_tagname_ = 'PredictorTerm'
# end class RegressionTable


class NumericPredictor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, exponent='1', coefficient=None, Extension=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.exponent = _cast(None, exponent)
        self.coefficient = _cast(None, coefficient)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumericPredictor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumericPredictor.subclass:
            return NumericPredictor.subclass(*args_, **kwargs_)
        else:
            return NumericPredictor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_exponent(self): return self.exponent
    def set_exponent(self, exponent): self.exponent = exponent
    def get_coefficient(self): return self.coefficient
    def set_coefficient(self, coefficient): self.coefficient = coefficient
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NumericPredictor', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NumericPredictor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumericPredictor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NumericPredictor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NumericPredictor'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.exponent != 1 and 'exponent' not in already_processed:
            already_processed.add('exponent')
            outfile.write(' exponent=%s' % (quote_attrib(self.exponent), ))
        if self.coefficient is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            outfile.write(' coefficient=%s' % (quote_attrib(self.coefficient), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NumericPredictor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NumericPredictor', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.name)
        if self.exponent is not None:
            element.set('exponent', self.exponent)
        if self.coefficient is not None:
            element.set('coefficient', self.coefficient)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NumericPredictor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.exponent is not None and 'exponent' not in already_processed:
            already_processed.add('exponent')
            showIndent(outfile, level)
            outfile.write('exponent=%d,\n' % (self.exponent,))
        if self.coefficient is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            showIndent(outfile, level)
            outfile.write('coefficient=%e,\n' % (self.coefficient,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('exponent', node)
        if value is not None and 'exponent' not in already_processed:
            already_processed.add('exponent')
            try:
                self.exponent = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.exponent)    # validate type INT-NUMBER
        value = find_attr_value_('coefficient', node)
        if value is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            try:
                self.coefficient = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coefficient): %s' % exp)
            self.validate_REAL_NUMBER(self.coefficient)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class NumericPredictor


class CategoricalPredictor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, coefficient=None, Extension=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        self.coefficient = _cast(None, coefficient)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategoricalPredictor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategoricalPredictor.subclass:
            return CategoricalPredictor.subclass(*args_, **kwargs_)
        else:
            return CategoricalPredictor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_coefficient(self): return self.coefficient
    def set_coefficient(self, coefficient): self.coefficient = coefficient
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CategoricalPredictor', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CategoricalPredictor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CategoricalPredictor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CategoricalPredictor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CategoricalPredictor'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.coefficient is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            outfile.write(' coefficient=%s' % (quote_attrib(self.coefficient), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CategoricalPredictor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='CategoricalPredictor', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.name)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.coefficient is not None:
            element.set('coefficient', self.coefficient)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CategoricalPredictor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.coefficient is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            showIndent(outfile, level)
            outfile.write('coefficient=%e,\n' % (self.coefficient,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('coefficient', node)
        if value is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            try:
                self.coefficient = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coefficient): %s' % exp)
            self.validate_REAL_NUMBER(self.coefficient)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class CategoricalPredictor


class PredictorTerm(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, coefficient=None, Extension=None, FieldRef=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.coefficient = _cast(None, coefficient)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if FieldRef is None:
            self.FieldRef = []
        else:
            self.FieldRef = FieldRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PredictorTerm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PredictorTerm.subclass:
            return PredictorTerm.subclass(*args_, **kwargs_)
        else:
            return PredictorTerm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_FieldRef(self): return self.FieldRef
    def set_FieldRef(self, FieldRef): self.FieldRef = FieldRef
    def add_FieldRef(self, value): self.FieldRef.append(value)
    def insert_FieldRef_at(self, index, value): self.FieldRef.insert(index, value)
    def replace_FieldRef_at(self, index, value): self.FieldRef[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_coefficient(self): return self.coefficient
    def set_coefficient(self, coefficient): self.coefficient = coefficient
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.FieldRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PredictorTerm', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PredictorTerm')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PredictorTerm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PredictorTerm', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PredictorTerm'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.coefficient is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            outfile.write(' coefficient=%s' % (quote_attrib(self.coefficient), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PredictorTerm', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for FieldRef_ in self.FieldRef:
            FieldRef_.export(outfile, level, namespace_, name_='FieldRef', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PredictorTerm', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.name)
        if self.coefficient is not None:
            element.set('coefficient', self.coefficient)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for FieldRef_ in self.FieldRef:
            FieldRef_.to_etree(element, name_='FieldRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PredictorTerm'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.coefficient is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            showIndent(outfile, level)
            outfile.write('coefficient=%e,\n' % (self.coefficient,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FieldRef=[\n')
        level += 1
        for FieldRef_ in self.FieldRef:
            showIndent(outfile, level)
            outfile.write('model_.FieldRef(\n')
            FieldRef_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('coefficient', node)
        if value is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            try:
                self.coefficient = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coefficient): %s' % exp)
            self.validate_REAL_NUMBER(self.coefficient)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory()
            obj_.build(child_)
            self.FieldRef.append(obj_)
            obj_.original_tagname_ = 'FieldRef'
# end class PredictorTerm


class RuleSetModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, isScorable=True, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, RuleSet=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.ModelExplanation = ModelExplanation
        self.Targets = Targets
        self.LocalTransformations = LocalTransformations
        self.RuleSet = RuleSet
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RuleSetModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RuleSetModel.subclass:
            return RuleSetModel.subclass(*args_, **kwargs_)
        else:
            return RuleSetModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_ModelExplanation(self): return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation): self.ModelExplanation = ModelExplanation
    def get_Targets(self): return self.Targets
    def set_Targets(self, Targets): self.Targets = Targets
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_RuleSet(self): return self.RuleSet
    def set_RuleSet(self, RuleSet): self.RuleSet = RuleSet
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.RuleSet is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RuleSetModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RuleSetModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RuleSetModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RuleSetModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RuleSetModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='RuleSetModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            self.ModelExplanation.export(outfile, level, namespace_, name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            self.Targets.export(outfile, level, namespace_, name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        if self.RuleSet is not None:
            self.RuleSet.export(outfile, level, namespace_, name_='RuleSet', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='RuleSetModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.ModelExplanation is not None:
            ModelExplanation_ = self.ModelExplanation
            ModelExplanation_.to_etree(element, name_='ModelExplanation', mapping_=mapping_)
        if self.Targets is not None:
            Targets_ = self.Targets
            Targets_.to_etree(element, name_='Targets', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        if self.RuleSet is not None:
            RuleSet_ = self.RuleSet
            RuleSet_.to_etree(element, name_='RuleSet', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='RuleSetModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelExplanation is not None:
            showIndent(outfile, level)
            outfile.write('ModelExplanation=model_.ModelExplanation(\n')
            self.ModelExplanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targets is not None:
            showIndent(outfile, level)
            outfile.write('Targets=model_.Targets(\n')
            self.Targets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RuleSet is not None:
            showIndent(outfile, level)
            outfile.write('RuleSet=model_.RuleSet(\n')
            self.RuleSet.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory()
            obj_.build(child_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory()
            obj_.build(child_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'RuleSet':
            obj_ = RuleSet.factory()
            obj_.build(child_)
            self.RuleSet = obj_
            obj_.original_tagname_ = 'RuleSet'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class RuleSetModel


class RuleSet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, recordCount=None, nbCorrect=None, defaultScore=None, defaultConfidence=None, Extension=None, RuleSelectionMethod=None, ScoreDistribution=None, SimpleRule=None, CompoundRule=None):
        self.original_tagname_ = None
        self.recordCount = _cast(None, recordCount)
        self.nbCorrect = _cast(None, nbCorrect)
        self.defaultScore = _cast(None, defaultScore)
        self.defaultConfidence = _cast(None, defaultConfidence)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if RuleSelectionMethod is None:
            self.RuleSelectionMethod = []
        else:
            self.RuleSelectionMethod = RuleSelectionMethod
        if ScoreDistribution is None:
            self.ScoreDistribution = []
        else:
            self.ScoreDistribution = ScoreDistribution
        if SimpleRule is None:
            self.SimpleRule = []
        else:
            self.SimpleRule = SimpleRule
        if CompoundRule is None:
            self.CompoundRule = []
        else:
            self.CompoundRule = CompoundRule
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RuleSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RuleSet.subclass:
            return RuleSet.subclass(*args_, **kwargs_)
        else:
            return RuleSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_RuleSelectionMethod(self): return self.RuleSelectionMethod
    def set_RuleSelectionMethod(self, RuleSelectionMethod): self.RuleSelectionMethod = RuleSelectionMethod
    def add_RuleSelectionMethod(self, value): self.RuleSelectionMethod.append(value)
    def insert_RuleSelectionMethod_at(self, index, value): self.RuleSelectionMethod.insert(index, value)
    def replace_RuleSelectionMethod_at(self, index, value): self.RuleSelectionMethod[index] = value
    def get_ScoreDistribution(self): return self.ScoreDistribution
    def set_ScoreDistribution(self, ScoreDistribution): self.ScoreDistribution = ScoreDistribution
    def add_ScoreDistribution(self, value): self.ScoreDistribution.append(value)
    def insert_ScoreDistribution_at(self, index, value): self.ScoreDistribution.insert(index, value)
    def replace_ScoreDistribution_at(self, index, value): self.ScoreDistribution[index] = value
    def get_SimpleRule(self): return self.SimpleRule
    def set_SimpleRule(self, SimpleRule): self.SimpleRule = SimpleRule
    def add_SimpleRule(self, value): self.SimpleRule.append(value)
    def insert_SimpleRule_at(self, index, value): self.SimpleRule.insert(index, value)
    def replace_SimpleRule_at(self, index, value): self.SimpleRule[index] = value
    def get_CompoundRule(self): return self.CompoundRule
    def set_CompoundRule(self, CompoundRule): self.CompoundRule = CompoundRule
    def add_CompoundRule(self, value): self.CompoundRule.append(value)
    def insert_CompoundRule_at(self, index, value): self.CompoundRule.insert(index, value)
    def replace_CompoundRule_at(self, index, value): self.CompoundRule[index] = value
    def get_recordCount(self): return self.recordCount
    def set_recordCount(self, recordCount): self.recordCount = recordCount
    def get_nbCorrect(self): return self.nbCorrect
    def set_nbCorrect(self, nbCorrect): self.nbCorrect = nbCorrect
    def get_defaultScore(self): return self.defaultScore
    def set_defaultScore(self, defaultScore): self.defaultScore = defaultScore
    def get_defaultConfidence(self): return self.defaultConfidence
    def set_defaultConfidence(self, defaultConfidence): self.defaultConfidence = defaultConfidence
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.RuleSelectionMethod or
            self.ScoreDistribution or
            self.SimpleRule or
            self.CompoundRule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RuleSet', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RuleSet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RuleSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RuleSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RuleSet'):
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            outfile.write(' recordCount=%s' % (quote_attrib(self.recordCount), ))
        if self.nbCorrect is not None and 'nbCorrect' not in already_processed:
            already_processed.add('nbCorrect')
            outfile.write(' nbCorrect=%s' % (quote_attrib(self.nbCorrect), ))
        if self.defaultScore is not None and 'defaultScore' not in already_processed:
            already_processed.add('defaultScore')
            outfile.write(' defaultScore=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.defaultScore), input_name='defaultScore')), ))
        if self.defaultConfidence is not None and 'defaultConfidence' not in already_processed:
            already_processed.add('defaultConfidence')
            outfile.write(' defaultConfidence=%s' % (quote_attrib(self.defaultConfidence), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RuleSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for RuleSelectionMethod_ in self.RuleSelectionMethod:
            RuleSelectionMethod_.export(outfile, level, namespace_, name_='RuleSelectionMethod', pretty_print=pretty_print)
        for ScoreDistribution_ in self.ScoreDistribution:
            ScoreDistribution_.export(outfile, level, namespace_, name_='ScoreDistribution', pretty_print=pretty_print)
        for SimpleRule_ in self.SimpleRule:
            SimpleRule_.export(outfile, level, namespace_, name_='SimpleRule', pretty_print=pretty_print)
        for CompoundRule_ in self.CompoundRule:
            CompoundRule_.export(outfile, level, namespace_, name_='CompoundRule', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='RuleSet', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.recordCount is not None:
            element.set('recordCount', self.recordCount)
        if self.nbCorrect is not None:
            element.set('nbCorrect', self.nbCorrect)
        if self.defaultScore is not None:
            element.set('defaultScore', self.gds_format_string(self.defaultScore))
        if self.defaultConfidence is not None:
            element.set('defaultConfidence', self.defaultConfidence)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for RuleSelectionMethod_ in self.RuleSelectionMethod:
            RuleSelectionMethod_.to_etree(element, name_='RuleSelectionMethod', mapping_=mapping_)
        for ScoreDistribution_ in self.ScoreDistribution:
            ScoreDistribution_.to_etree(element, name_='ScoreDistribution', mapping_=mapping_)
        for SimpleRule_ in self.SimpleRule:
            SimpleRule_.to_etree(element, name_='SimpleRule', mapping_=mapping_)
        for CompoundRule_ in self.CompoundRule:
            CompoundRule_.to_etree(element, name_='CompoundRule', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='RuleSet'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            showIndent(outfile, level)
            outfile.write('recordCount=%e,\n' % (self.recordCount,))
        if self.nbCorrect is not None and 'nbCorrect' not in already_processed:
            already_processed.add('nbCorrect')
            showIndent(outfile, level)
            outfile.write('nbCorrect=%e,\n' % (self.nbCorrect,))
        if self.defaultScore is not None and 'defaultScore' not in already_processed:
            already_processed.add('defaultScore')
            showIndent(outfile, level)
            outfile.write('defaultScore="%s",\n' % (self.defaultScore,))
        if self.defaultConfidence is not None and 'defaultConfidence' not in already_processed:
            already_processed.add('defaultConfidence')
            showIndent(outfile, level)
            outfile.write('defaultConfidence=%e,\n' % (self.defaultConfidence,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RuleSelectionMethod=[\n')
        level += 1
        for RuleSelectionMethod_ in self.RuleSelectionMethod:
            showIndent(outfile, level)
            outfile.write('model_.RuleSelectionMethod(\n')
            RuleSelectionMethod_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ScoreDistribution=[\n')
        level += 1
        for ScoreDistribution_ in self.ScoreDistribution:
            showIndent(outfile, level)
            outfile.write('model_.ScoreDistribution(\n')
            ScoreDistribution_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SimpleRule=[\n')
        level += 1
        for SimpleRule_ in self.SimpleRule:
            showIndent(outfile, level)
            outfile.write('model_.SimpleRule(\n')
            SimpleRule_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CompoundRule=[\n')
        level += 1
        for CompoundRule_ in self.CompoundRule:
            showIndent(outfile, level)
            outfile.write('model_.CompoundRule(\n')
            CompoundRule_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('recordCount', node)
        if value is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            try:
                self.recordCount = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (recordCount): %s' % exp)
            self.validate_NUMBER(self.recordCount)    # validate type NUMBER
        value = find_attr_value_('nbCorrect', node)
        if value is not None and 'nbCorrect' not in already_processed:
            already_processed.add('nbCorrect')
            try:
                self.nbCorrect = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (nbCorrect): %s' % exp)
            self.validate_NUMBER(self.nbCorrect)    # validate type NUMBER
        value = find_attr_value_('defaultScore', node)
        if value is not None and 'defaultScore' not in already_processed:
            already_processed.add('defaultScore')
            self.defaultScore = value
        value = find_attr_value_('defaultConfidence', node)
        if value is not None and 'defaultConfidence' not in already_processed:
            already_processed.add('defaultConfidence')
            try:
                self.defaultConfidence = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (defaultConfidence): %s' % exp)
            self.validate_NUMBER(self.defaultConfidence)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'RuleSelectionMethod':
            obj_ = RuleSelectionMethod.factory()
            obj_.build(child_)
            self.RuleSelectionMethod.append(obj_)
            obj_.original_tagname_ = 'RuleSelectionMethod'
        elif nodeName_ == 'ScoreDistribution':
            obj_ = ScoreDistribution.factory()
            obj_.build(child_)
            self.ScoreDistribution.append(obj_)
            obj_.original_tagname_ = 'ScoreDistribution'
        elif nodeName_ == 'SimpleRule':
            obj_ = SimpleRule.factory()
            obj_.build(child_)
            self.SimpleRule.append(obj_)
            obj_.original_tagname_ = 'SimpleRule'
        elif nodeName_ == 'CompoundRule':
            obj_ = CompoundRule.factory()
            obj_.build(child_)
            self.CompoundRule.append(obj_)
            obj_.original_tagname_ = 'CompoundRule'
# end class RuleSet


class RuleSelectionMethod(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, criterion=None, Extension=None):
        self.original_tagname_ = None
        self.criterion = _cast(None, criterion)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RuleSelectionMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RuleSelectionMethod.subclass:
            return RuleSelectionMethod.subclass(*args_, **kwargs_)
        else:
            return RuleSelectionMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_criterion(self): return self.criterion
    def set_criterion(self, criterion): self.criterion = criterion
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RuleSelectionMethod', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RuleSelectionMethod')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RuleSelectionMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RuleSelectionMethod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RuleSelectionMethod'):
        if self.criterion is not None and 'criterion' not in already_processed:
            already_processed.add('criterion')
            outfile.write(' criterion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.criterion), input_name='criterion')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RuleSelectionMethod', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='RuleSelectionMethod', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.criterion is not None:
            element.set('criterion', self.gds_format_string(self.criterion))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='RuleSelectionMethod'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.criterion is not None and 'criterion' not in already_processed:
            already_processed.add('criterion')
            showIndent(outfile, level)
            outfile.write('criterion="%s",\n' % (self.criterion,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('criterion', node)
        if value is not None and 'criterion' not in already_processed:
            already_processed.add('criterion')
            self.criterion = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class RuleSelectionMethod


class SimpleRule(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, score=None, recordCount=None, nbCorrect=None, confidence='1', weight='1', Extension=None, SimplePredicate=None, CompoundPredicate=None, SimpleSetPredicate=None, True_=None, False_=None, ScoreDistribution=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.score = _cast(None, score)
        self.recordCount = _cast(None, recordCount)
        self.nbCorrect = _cast(None, nbCorrect)
        self.confidence = _cast(None, confidence)
        self.weight = _cast(None, weight)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.SimplePredicate = SimplePredicate
        self.CompoundPredicate = CompoundPredicate
        self.SimpleSetPredicate = SimpleSetPredicate
        self.True_ = True_
        self.False_ = False_
        if ScoreDistribution is None:
            self.ScoreDistribution = []
        else:
            self.ScoreDistribution = ScoreDistribution
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleRule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleRule.subclass:
            return SimpleRule.subclass(*args_, **kwargs_)
        else:
            return SimpleRule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_SimplePredicate(self): return self.SimplePredicate
    def set_SimplePredicate(self, SimplePredicate): self.SimplePredicate = SimplePredicate
    def get_CompoundPredicate(self): return self.CompoundPredicate
    def set_CompoundPredicate(self, CompoundPredicate): self.CompoundPredicate = CompoundPredicate
    def get_SimpleSetPredicate(self): return self.SimpleSetPredicate
    def set_SimpleSetPredicate(self, SimpleSetPredicate): self.SimpleSetPredicate = SimpleSetPredicate
    def get_True(self): return self.True_
    def set_True(self, True_): self.True_ = True_
    def get_False(self): return self.False_
    def set_False(self, False_): self.False_ = False_
    def get_ScoreDistribution(self): return self.ScoreDistribution
    def set_ScoreDistribution(self, ScoreDistribution): self.ScoreDistribution = ScoreDistribution
    def add_ScoreDistribution(self, value): self.ScoreDistribution.append(value)
    def insert_ScoreDistribution_at(self, index, value): self.ScoreDistribution.insert(index, value)
    def replace_ScoreDistribution_at(self, index, value): self.ScoreDistribution[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_score(self): return self.score
    def set_score(self, score): self.score = score
    def get_recordCount(self): return self.recordCount
    def set_recordCount(self, recordCount): self.recordCount = recordCount
    def get_nbCorrect(self): return self.nbCorrect
    def set_nbCorrect(self, nbCorrect): self.nbCorrect = nbCorrect
    def get_confidence(self): return self.confidence
    def set_confidence(self, confidence): self.confidence = confidence
    def get_weight(self): return self.weight
    def set_weight(self, weight): self.weight = weight
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.SimplePredicate is not None or
            self.CompoundPredicate is not None or
            self.SimpleSetPredicate is not None or
            self.True_ is not None or
            self.False_ is not None or
            self.ScoreDistribution
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimpleRule', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SimpleRule')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleRule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimpleRule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimpleRule'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.score is not None and 'score' not in already_processed:
            already_processed.add('score')
            outfile.write(' score=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.score), input_name='score')), ))
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            outfile.write(' recordCount=%s' % (quote_attrib(self.recordCount), ))
        if self.nbCorrect is not None and 'nbCorrect' not in already_processed:
            already_processed.add('nbCorrect')
            outfile.write(' nbCorrect=%s' % (quote_attrib(self.nbCorrect), ))
        if self.confidence != 1 and 'confidence' not in already_processed:
            already_processed.add('confidence')
            outfile.write(' confidence=%s' % (quote_attrib(self.confidence), ))
        if self.weight != 1 and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight=%s' % (quote_attrib(self.weight), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SimpleRule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.SimplePredicate is not None:
            self.SimplePredicate.export(outfile, level, namespace_, name_='SimplePredicate', pretty_print=pretty_print)
        if self.CompoundPredicate is not None:
            self.CompoundPredicate.export(outfile, level, namespace_, name_='CompoundPredicate', pretty_print=pretty_print)
        if self.SimpleSetPredicate is not None:
            self.SimpleSetPredicate.export(outfile, level, namespace_, name_='SimpleSetPredicate', pretty_print=pretty_print)
        if self.True_ is not None:
            self.True_.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False_ is not None:
            self.False_.export(outfile, level, namespace_, name_='False', pretty_print=pretty_print)
        for ScoreDistribution_ in self.ScoreDistribution:
            ScoreDistribution_.export(outfile, level, namespace_, name_='ScoreDistribution', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SimpleRule', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.score is not None:
            element.set('score', self.gds_format_string(self.score))
        if self.recordCount is not None:
            element.set('recordCount', self.recordCount)
        if self.nbCorrect is not None:
            element.set('nbCorrect', self.nbCorrect)
        if self.confidence is not None:
            element.set('confidence', self.confidence)
        if self.weight is not None:
            element.set('weight', self.weight)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.SimplePredicate is not None:
            SimplePredicate_ = self.SimplePredicate
            SimplePredicate_.to_etree(element, name_='SimplePredicate', mapping_=mapping_)
        if self.CompoundPredicate is not None:
            CompoundPredicate_ = self.CompoundPredicate
            CompoundPredicate_.to_etree(element, name_='CompoundPredicate', mapping_=mapping_)
        if self.SimpleSetPredicate is not None:
            SimpleSetPredicate_ = self.SimpleSetPredicate
            SimpleSetPredicate_.to_etree(element, name_='SimpleSetPredicate', mapping_=mapping_)
        if self.True_ is not None:
            True__ = self.True_
            True__.to_etree(element, name_='True', mapping_=mapping_)
        if self.False_ is not None:
            False__ = self.False_
            False__.to_etree(element, name_='False', mapping_=mapping_)
        for ScoreDistribution_ in self.ScoreDistribution:
            ScoreDistribution_.to_etree(element, name_='ScoreDistribution', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SimpleRule'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.score is not None and 'score' not in already_processed:
            already_processed.add('score')
            showIndent(outfile, level)
            outfile.write('score="%s",\n' % (self.score,))
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            showIndent(outfile, level)
            outfile.write('recordCount=%e,\n' % (self.recordCount,))
        if self.nbCorrect is not None and 'nbCorrect' not in already_processed:
            already_processed.add('nbCorrect')
            showIndent(outfile, level)
            outfile.write('nbCorrect=%e,\n' % (self.nbCorrect,))
        if self.confidence is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            showIndent(outfile, level)
            outfile.write('confidence=%e,\n' % (self.confidence,))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            showIndent(outfile, level)
            outfile.write('weight=%e,\n' % (self.weight,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SimplePredicate is not None:
            showIndent(outfile, level)
            outfile.write('SimplePredicate=model_.SimplePredicate(\n')
            self.SimplePredicate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CompoundPredicate is not None:
            showIndent(outfile, level)
            outfile.write('CompoundPredicate=model_.CompoundPredicate(\n')
            self.CompoundPredicate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SimpleSetPredicate is not None:
            showIndent(outfile, level)
            outfile.write('SimpleSetPredicate=model_.SimpleSetPredicate(\n')
            self.SimpleSetPredicate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.True_ is not None:
            showIndent(outfile, level)
            outfile.write('True_=model_.True_(\n')
            self.True_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.False_ is not None:
            showIndent(outfile, level)
            outfile.write('False_=model_.False_(\n')
            self.False_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ScoreDistribution=[\n')
        level += 1
        for ScoreDistribution_ in self.ScoreDistribution:
            showIndent(outfile, level)
            outfile.write('model_.ScoreDistribution(\n')
            ScoreDistribution_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('score', node)
        if value is not None and 'score' not in already_processed:
            already_processed.add('score')
            self.score = value
        value = find_attr_value_('recordCount', node)
        if value is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            try:
                self.recordCount = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (recordCount): %s' % exp)
            self.validate_NUMBER(self.recordCount)    # validate type NUMBER
        value = find_attr_value_('nbCorrect', node)
        if value is not None and 'nbCorrect' not in already_processed:
            already_processed.add('nbCorrect')
            try:
                self.nbCorrect = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (nbCorrect): %s' % exp)
            self.validate_NUMBER(self.nbCorrect)    # validate type NUMBER
        value = find_attr_value_('confidence', node)
        if value is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            try:
                self.confidence = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (confidence): %s' % exp)
            self.validate_NUMBER(self.confidence)    # validate type NUMBER
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            try:
                self.weight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (weight): %s' % exp)
            self.validate_NUMBER(self.weight)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'SimplePredicate':
            obj_ = SimplePredicate.factory()
            obj_.build(child_)
            self.SimplePredicate = obj_
            obj_.original_tagname_ = 'SimplePredicate'
        elif nodeName_ == 'CompoundPredicate':
            obj_ = CompoundPredicate.factory()
            obj_.build(child_)
            self.CompoundPredicate = obj_
            obj_.original_tagname_ = 'CompoundPredicate'
        elif nodeName_ == 'SimpleSetPredicate':
            obj_ = SimpleSetPredicate.factory()
            obj_.build(child_)
            self.SimpleSetPredicate = obj_
            obj_.original_tagname_ = 'SimpleSetPredicate'
        elif nodeName_ == 'True':
            obj_ = True_.factory()
            obj_.build(child_)
            self.True_ = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            obj_ = False_.factory()
            obj_.build(child_)
            self.False_ = obj_
            obj_.original_tagname_ = 'False'
        elif nodeName_ == 'ScoreDistribution':
            obj_ = ScoreDistribution.factory()
            obj_.build(child_)
            self.ScoreDistribution.append(obj_)
            obj_.original_tagname_ = 'ScoreDistribution'
# end class SimpleRule


class CompoundRule(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, SimplePredicate=None, CompoundPredicate=None, SimpleSetPredicate=None, True_=None, False_=None, SimpleRule=None, CompoundRule_member=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.SimplePredicate = SimplePredicate
        self.CompoundPredicate = CompoundPredicate
        self.SimpleSetPredicate = SimpleSetPredicate
        self.True_ = True_
        self.False_ = False_
        if SimpleRule is None:
            self.SimpleRule = []
        else:
            self.SimpleRule = SimpleRule
        if CompoundRule_member is None:
            self.CompoundRule = []
        else:
            self.CompoundRule = CompoundRule_member
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompoundRule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompoundRule.subclass:
            return CompoundRule.subclass(*args_, **kwargs_)
        else:
            return CompoundRule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_SimplePredicate(self): return self.SimplePredicate
    def set_SimplePredicate(self, SimplePredicate): self.SimplePredicate = SimplePredicate
    def get_CompoundPredicate(self): return self.CompoundPredicate
    def set_CompoundPredicate(self, CompoundPredicate): self.CompoundPredicate = CompoundPredicate
    def get_SimpleSetPredicate(self): return self.SimpleSetPredicate
    def set_SimpleSetPredicate(self, SimpleSetPredicate): self.SimpleSetPredicate = SimpleSetPredicate
    def get_True(self): return self.True_
    def set_True(self, True_): self.True_ = True_
    def get_False(self): return self.False_
    def set_False(self, False_): self.False_ = False_
    def get_SimpleRule(self): return self.SimpleRule
    def set_SimpleRule(self, SimpleRule): self.SimpleRule = SimpleRule
    def add_SimpleRule(self, value): self.SimpleRule.append(value)
    def insert_SimpleRule_at(self, index, value): self.SimpleRule.insert(index, value)
    def replace_SimpleRule_at(self, index, value): self.SimpleRule[index] = value
    def get_CompoundRule(self): return self.CompoundRule
    def set_CompoundRule(self, CompoundRule): self.CompoundRule = CompoundRule
    def add_CompoundRule(self, value): self.CompoundRule.append(value)
    def insert_CompoundRule_at(self, index, value): self.CompoundRule.insert(index, value)
    def replace_CompoundRule_at(self, index, value): self.CompoundRule[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.SimplePredicate is not None or
            self.CompoundPredicate is not None or
            self.SimpleSetPredicate is not None or
            self.True_ is not None or
            self.False_ is not None or
            self.SimpleRule or
            self.CompoundRule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CompoundRule', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompoundRule')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompoundRule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CompoundRule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CompoundRule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CompoundRule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.SimplePredicate is not None:
            self.SimplePredicate.export(outfile, level, namespace_, name_='SimplePredicate', pretty_print=pretty_print)
        if self.CompoundPredicate is not None:
            self.CompoundPredicate.export(outfile, level, namespace_, name_='CompoundPredicate', pretty_print=pretty_print)
        if self.SimpleSetPredicate is not None:
            self.SimpleSetPredicate.export(outfile, level, namespace_, name_='SimpleSetPredicate', pretty_print=pretty_print)
        if self.True_ is not None:
            self.True_.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False_ is not None:
            self.False_.export(outfile, level, namespace_, name_='False', pretty_print=pretty_print)
        for SimpleRule_ in self.SimpleRule:
            SimpleRule_.export(outfile, level, namespace_, name_='SimpleRule', pretty_print=pretty_print)
        for CompoundRule_ in self.CompoundRule:
            CompoundRule_.export(outfile, level, namespace_, name_='CompoundRule', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='CompoundRule', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.SimplePredicate is not None:
            SimplePredicate_ = self.SimplePredicate
            SimplePredicate_.to_etree(element, name_='SimplePredicate', mapping_=mapping_)
        if self.CompoundPredicate is not None:
            CompoundPredicate_ = self.CompoundPredicate
            CompoundPredicate_.to_etree(element, name_='CompoundPredicate', mapping_=mapping_)
        if self.SimpleSetPredicate is not None:
            SimpleSetPredicate_ = self.SimpleSetPredicate
            SimpleSetPredicate_.to_etree(element, name_='SimpleSetPredicate', mapping_=mapping_)
        if self.True_ is not None:
            True__ = self.True_
            True__.to_etree(element, name_='True', mapping_=mapping_)
        if self.False_ is not None:
            False__ = self.False_
            False__.to_etree(element, name_='False', mapping_=mapping_)
        for SimpleRule_ in self.SimpleRule:
            SimpleRule_.to_etree(element, name_='SimpleRule', mapping_=mapping_)
        for CompoundRule_ in self.CompoundRule:
            CompoundRule_.to_etree(element, name_='CompoundRule', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CompoundRule'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SimplePredicate is not None:
            showIndent(outfile, level)
            outfile.write('SimplePredicate=model_.SimplePredicate(\n')
            self.SimplePredicate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CompoundPredicate is not None:
            showIndent(outfile, level)
            outfile.write('CompoundPredicate=model_.CompoundPredicate(\n')
            self.CompoundPredicate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SimpleSetPredicate is not None:
            showIndent(outfile, level)
            outfile.write('SimpleSetPredicate=model_.SimpleSetPredicate(\n')
            self.SimpleSetPredicate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.True_ is not None:
            showIndent(outfile, level)
            outfile.write('True_=model_.True_(\n')
            self.True_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.False_ is not None:
            showIndent(outfile, level)
            outfile.write('False_=model_.False_(\n')
            self.False_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('SimpleRule=[\n')
        level += 1
        for SimpleRule_ in self.SimpleRule:
            showIndent(outfile, level)
            outfile.write('model_.SimpleRule(\n')
            SimpleRule_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CompoundRule=[\n')
        level += 1
        for CompoundRule_ in self.CompoundRule:
            showIndent(outfile, level)
            outfile.write('model_.CompoundRule(\n')
            CompoundRule_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'SimplePredicate':
            obj_ = SimplePredicate.factory()
            obj_.build(child_)
            self.SimplePredicate = obj_
            obj_.original_tagname_ = 'SimplePredicate'
        elif nodeName_ == 'CompoundPredicate':
            obj_ = CompoundPredicate.factory()
            obj_.build(child_)
            self.CompoundPredicate = obj_
            obj_.original_tagname_ = 'CompoundPredicate'
        elif nodeName_ == 'SimpleSetPredicate':
            obj_ = SimpleSetPredicate.factory()
            obj_.build(child_)
            self.SimpleSetPredicate = obj_
            obj_.original_tagname_ = 'SimpleSetPredicate'
        elif nodeName_ == 'True':
            obj_ = True_.factory()
            obj_.build(child_)
            self.True_ = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            obj_ = False_.factory()
            obj_.build(child_)
            self.False_ = obj_
            obj_.original_tagname_ = 'False'
        elif nodeName_ == 'SimpleRule':
            obj_ = SimpleRule.factory()
            obj_.build(child_)
            self.SimpleRule.append(obj_)
            obj_.original_tagname_ = 'SimpleRule'
        elif nodeName_ == 'CompoundRule':
            obj_ = CompoundRule.factory()
            obj_.build(child_)
            self.CompoundRule.append(obj_)
            obj_.original_tagname_ = 'CompoundRule'
# end class CompoundRule


class ModelExplanation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, PredictiveModelQuality=None, ClusteringModelQuality=None, Correlations=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if PredictiveModelQuality is None:
            self.PredictiveModelQuality = []
        else:
            self.PredictiveModelQuality = PredictiveModelQuality
        if ClusteringModelQuality is None:
            self.ClusteringModelQuality = []
        else:
            self.ClusteringModelQuality = ClusteringModelQuality
        self.Correlations = Correlations
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ModelExplanation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ModelExplanation.subclass:
            return ModelExplanation.subclass(*args_, **kwargs_)
        else:
            return ModelExplanation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_PredictiveModelQuality(self): return self.PredictiveModelQuality
    def set_PredictiveModelQuality(self, PredictiveModelQuality): self.PredictiveModelQuality = PredictiveModelQuality
    def add_PredictiveModelQuality(self, value): self.PredictiveModelQuality.append(value)
    def insert_PredictiveModelQuality_at(self, index, value): self.PredictiveModelQuality.insert(index, value)
    def replace_PredictiveModelQuality_at(self, index, value): self.PredictiveModelQuality[index] = value
    def get_ClusteringModelQuality(self): return self.ClusteringModelQuality
    def set_ClusteringModelQuality(self, ClusteringModelQuality): self.ClusteringModelQuality = ClusteringModelQuality
    def add_ClusteringModelQuality(self, value): self.ClusteringModelQuality.append(value)
    def insert_ClusteringModelQuality_at(self, index, value): self.ClusteringModelQuality.insert(index, value)
    def replace_ClusteringModelQuality_at(self, index, value): self.ClusteringModelQuality[index] = value
    def get_Correlations(self): return self.Correlations
    def set_Correlations(self, Correlations): self.Correlations = Correlations
    def hasContent_(self):
        if (
            self.Extension or
            self.PredictiveModelQuality or
            self.ClusteringModelQuality or
            self.Correlations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ModelExplanation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ModelExplanation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModelExplanation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ModelExplanation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ModelExplanation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ModelExplanation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for PredictiveModelQuality_ in self.PredictiveModelQuality:
            PredictiveModelQuality_.export(outfile, level, namespace_, name_='PredictiveModelQuality', pretty_print=pretty_print)
        for ClusteringModelQuality_ in self.ClusteringModelQuality:
            ClusteringModelQuality_.export(outfile, level, namespace_, name_='ClusteringModelQuality', pretty_print=pretty_print)
        if self.Correlations is not None:
            self.Correlations.export(outfile, level, namespace_, name_='Correlations', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ModelExplanation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for PredictiveModelQuality_ in self.PredictiveModelQuality:
            PredictiveModelQuality_.to_etree(element, name_='PredictiveModelQuality', mapping_=mapping_)
        for ClusteringModelQuality_ in self.ClusteringModelQuality:
            ClusteringModelQuality_.to_etree(element, name_='ClusteringModelQuality', mapping_=mapping_)
        if self.Correlations is not None:
            Correlations_ = self.Correlations
            Correlations_.to_etree(element, name_='Correlations', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ModelExplanation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PredictiveModelQuality=[\n')
        level += 1
        for PredictiveModelQuality_ in self.PredictiveModelQuality:
            showIndent(outfile, level)
            outfile.write('model_.PredictiveModelQuality(\n')
            PredictiveModelQuality_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ClusteringModelQuality=[\n')
        level += 1
        for ClusteringModelQuality_ in self.ClusteringModelQuality:
            showIndent(outfile, level)
            outfile.write('model_.ClusteringModelQuality(\n')
            ClusteringModelQuality_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Correlations is not None:
            showIndent(outfile, level)
            outfile.write('Correlations=model_.Correlations(\n')
            self.Correlations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'PredictiveModelQuality':
            obj_ = PredictiveModelQuality.factory()
            obj_.build(child_)
            self.PredictiveModelQuality.append(obj_)
            obj_.original_tagname_ = 'PredictiveModelQuality'
        elif nodeName_ == 'ClusteringModelQuality':
            obj_ = ClusteringModelQuality.factory()
            obj_.build(child_)
            self.ClusteringModelQuality.append(obj_)
            obj_.original_tagname_ = 'ClusteringModelQuality'
        elif nodeName_ == 'Correlations':
            obj_ = Correlations.factory()
            obj_.build(child_)
            self.Correlations = obj_
            obj_.original_tagname_ = 'Correlations'
# end class ModelExplanation


class PredictiveModelQuality(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, targetField=None, dataName=None, dataUsage='training', meanError=None, meanAbsoluteError=None, meanSquaredError=None, rootMeanSquaredError=None, r_squared=None, adj_r_squared=None, sumSquaredError=None, sumSquaredRegression=None, numOfRecords=None, numOfRecordsWeighted=None, numOfPredictors=None, degreesOfFreedom=None, fStatistic=None, AIC=None, BIC=None, AICc=None, accuracy=None, AUC=None, precision=None, recall=None, specificity=None, F1=None, F2=None, Fhalf=None, Extension=None, ConfusionMatrix=None, LiftData=None, ROC=None):
        self.original_tagname_ = None
        self.targetField = _cast(None, targetField)
        self.dataName = _cast(None, dataName)
        self.dataUsage = _cast(None, dataUsage)
        self.meanError = _cast(None, meanError)
        self.meanAbsoluteError = _cast(None, meanAbsoluteError)
        self.meanSquaredError = _cast(None, meanSquaredError)
        self.rootMeanSquaredError = _cast(None, rootMeanSquaredError)
        self.r_squared = _cast(None, r_squared)
        self.adj_r_squared = _cast(None, adj_r_squared)
        self.sumSquaredError = _cast(None, sumSquaredError)
        self.sumSquaredRegression = _cast(None, sumSquaredRegression)
        self.numOfRecords = _cast(None, numOfRecords)
        self.numOfRecordsWeighted = _cast(None, numOfRecordsWeighted)
        self.numOfPredictors = _cast(None, numOfPredictors)
        self.degreesOfFreedom = _cast(None, degreesOfFreedom)
        self.fStatistic = _cast(None, fStatistic)
        self.AIC = _cast(None, AIC)
        self.BIC = _cast(None, BIC)
        self.AICc = _cast(None, AICc)
        self.accuracy = _cast(None, accuracy)
        self.AUC = _cast(None, AUC)
        self.precision = _cast(None, precision)
        self.recall = _cast(None, recall)
        self.specificity = _cast(None, specificity)
        self.F1 = _cast(None, F1)
        self.F2 = _cast(None, F2)
        self.Fhalf = _cast(None, Fhalf)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.ConfusionMatrix = ConfusionMatrix
        if LiftData is None:
            self.LiftData = []
        else:
            self.LiftData = LiftData
        self.ROC = ROC
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PredictiveModelQuality)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PredictiveModelQuality.subclass:
            return PredictiveModelQuality.subclass(*args_, **kwargs_)
        else:
            return PredictiveModelQuality(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_ConfusionMatrix(self): return self.ConfusionMatrix
    def set_ConfusionMatrix(self, ConfusionMatrix): self.ConfusionMatrix = ConfusionMatrix
    def get_LiftData(self): return self.LiftData
    def set_LiftData(self, LiftData): self.LiftData = LiftData
    def add_LiftData(self, value): self.LiftData.append(value)
    def insert_LiftData_at(self, index, value): self.LiftData.insert(index, value)
    def replace_LiftData_at(self, index, value): self.LiftData[index] = value
    def get_ROC(self): return self.ROC
    def set_ROC(self, ROC): self.ROC = ROC
    def get_targetField(self): return self.targetField
    def set_targetField(self, targetField): self.targetField = targetField
    def get_dataName(self): return self.dataName
    def set_dataName(self, dataName): self.dataName = dataName
    def get_dataUsage(self): return self.dataUsage
    def set_dataUsage(self, dataUsage): self.dataUsage = dataUsage
    def get_meanError(self): return self.meanError
    def set_meanError(self, meanError): self.meanError = meanError
    def get_meanAbsoluteError(self): return self.meanAbsoluteError
    def set_meanAbsoluteError(self, meanAbsoluteError): self.meanAbsoluteError = meanAbsoluteError
    def get_meanSquaredError(self): return self.meanSquaredError
    def set_meanSquaredError(self, meanSquaredError): self.meanSquaredError = meanSquaredError
    def get_rootMeanSquaredError(self): return self.rootMeanSquaredError
    def set_rootMeanSquaredError(self, rootMeanSquaredError): self.rootMeanSquaredError = rootMeanSquaredError
    def get_r_squared(self): return self.r_squared
    def set_r_squared(self, r_squared): self.r_squared = r_squared
    def get_adj_r_squared(self): return self.adj_r_squared
    def set_adj_r_squared(self, adj_r_squared): self.adj_r_squared = adj_r_squared
    def get_sumSquaredError(self): return self.sumSquaredError
    def set_sumSquaredError(self, sumSquaredError): self.sumSquaredError = sumSquaredError
    def get_sumSquaredRegression(self): return self.sumSquaredRegression
    def set_sumSquaredRegression(self, sumSquaredRegression): self.sumSquaredRegression = sumSquaredRegression
    def get_numOfRecords(self): return self.numOfRecords
    def set_numOfRecords(self, numOfRecords): self.numOfRecords = numOfRecords
    def get_numOfRecordsWeighted(self): return self.numOfRecordsWeighted
    def set_numOfRecordsWeighted(self, numOfRecordsWeighted): self.numOfRecordsWeighted = numOfRecordsWeighted
    def get_numOfPredictors(self): return self.numOfPredictors
    def set_numOfPredictors(self, numOfPredictors): self.numOfPredictors = numOfPredictors
    def get_degreesOfFreedom(self): return self.degreesOfFreedom
    def set_degreesOfFreedom(self, degreesOfFreedom): self.degreesOfFreedom = degreesOfFreedom
    def get_fStatistic(self): return self.fStatistic
    def set_fStatistic(self, fStatistic): self.fStatistic = fStatistic
    def get_AIC(self): return self.AIC
    def set_AIC(self, AIC): self.AIC = AIC
    def get_BIC(self): return self.BIC
    def set_BIC(self, BIC): self.BIC = BIC
    def get_AICc(self): return self.AICc
    def set_AICc(self, AICc): self.AICc = AICc
    def get_accuracy(self): return self.accuracy
    def set_accuracy(self, accuracy): self.accuracy = accuracy
    def get_AUC(self): return self.AUC
    def set_AUC(self, AUC): self.AUC = AUC
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_recall(self): return self.recall
    def set_recall(self, recall): self.recall = recall
    def get_specificity(self): return self.specificity
    def set_specificity(self, specificity): self.specificity = specificity
    def get_F1(self): return self.F1
    def set_F1(self, F1): self.F1 = F1
    def get_F2(self): return self.F2
    def set_F2(self, F2): self.F2 = F2
    def get_Fhalf(self): return self.Fhalf
    def set_Fhalf(self, Fhalf): self.Fhalf = Fhalf
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.ConfusionMatrix is not None or
            self.LiftData or
            self.ROC is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PredictiveModelQuality', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PredictiveModelQuality')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PredictiveModelQuality')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PredictiveModelQuality', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PredictiveModelQuality'):
        if self.targetField is not None and 'targetField' not in already_processed:
            already_processed.add('targetField')
            outfile.write(' targetField=%s' % (quote_attrib(self.targetField), ))
        if self.dataName is not None and 'dataName' not in already_processed:
            already_processed.add('dataName')
            outfile.write(' dataName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataName), input_name='dataName')), ))
        if self.dataUsage != "training" and 'dataUsage' not in already_processed:
            already_processed.add('dataUsage')
            outfile.write(' dataUsage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataUsage), input_name='dataUsage')), ))
        if self.meanError is not None and 'meanError' not in already_processed:
            already_processed.add('meanError')
            outfile.write(' meanError=%s' % (quote_attrib(self.meanError), ))
        if self.meanAbsoluteError is not None and 'meanAbsoluteError' not in already_processed:
            already_processed.add('meanAbsoluteError')
            outfile.write(' meanAbsoluteError=%s' % (quote_attrib(self.meanAbsoluteError), ))
        if self.meanSquaredError is not None and 'meanSquaredError' not in already_processed:
            already_processed.add('meanSquaredError')
            outfile.write(' meanSquaredError=%s' % (quote_attrib(self.meanSquaredError), ))
        if self.rootMeanSquaredError is not None and 'rootMeanSquaredError' not in already_processed:
            already_processed.add('rootMeanSquaredError')
            outfile.write(' rootMeanSquaredError=%s' % (quote_attrib(self.rootMeanSquaredError), ))
        if self.r_squared is not None and 'r_squared' not in already_processed:
            already_processed.add('r_squared')
            outfile.write(' r-squared=%s' % (quote_attrib(self.r_squared), ))
        if self.adj_r_squared is not None and 'adj_r_squared' not in already_processed:
            already_processed.add('adj_r_squared')
            outfile.write(' adj-r-squared=%s' % (quote_attrib(self.adj_r_squared), ))
        if self.sumSquaredError is not None and 'sumSquaredError' not in already_processed:
            already_processed.add('sumSquaredError')
            outfile.write(' sumSquaredError=%s' % (quote_attrib(self.sumSquaredError), ))
        if self.sumSquaredRegression is not None and 'sumSquaredRegression' not in already_processed:
            already_processed.add('sumSquaredRegression')
            outfile.write(' sumSquaredRegression=%s' % (quote_attrib(self.sumSquaredRegression), ))
        if self.numOfRecords is not None and 'numOfRecords' not in already_processed:
            already_processed.add('numOfRecords')
            outfile.write(' numOfRecords=%s' % (quote_attrib(self.numOfRecords), ))
        if self.numOfRecordsWeighted is not None and 'numOfRecordsWeighted' not in already_processed:
            already_processed.add('numOfRecordsWeighted')
            outfile.write(' numOfRecordsWeighted=%s' % (quote_attrib(self.numOfRecordsWeighted), ))
        if self.numOfPredictors is not None and 'numOfPredictors' not in already_processed:
            already_processed.add('numOfPredictors')
            outfile.write(' numOfPredictors=%s' % (quote_attrib(self.numOfPredictors), ))
        if self.degreesOfFreedom is not None and 'degreesOfFreedom' not in already_processed:
            already_processed.add('degreesOfFreedom')
            outfile.write(' degreesOfFreedom=%s' % (quote_attrib(self.degreesOfFreedom), ))
        if self.fStatistic is not None and 'fStatistic' not in already_processed:
            already_processed.add('fStatistic')
            outfile.write(' fStatistic=%s' % (quote_attrib(self.fStatistic), ))
        if self.AIC is not None and 'AIC' not in already_processed:
            already_processed.add('AIC')
            outfile.write(' AIC=%s' % (quote_attrib(self.AIC), ))
        if self.BIC is not None and 'BIC' not in already_processed:
            already_processed.add('BIC')
            outfile.write(' BIC=%s' % (quote_attrib(self.BIC), ))
        if self.AICc is not None and 'AICc' not in already_processed:
            already_processed.add('AICc')
            outfile.write(' AICc=%s' % (quote_attrib(self.AICc), ))
        if self.accuracy is not None and 'accuracy' not in already_processed:
            already_processed.add('accuracy')
            outfile.write(' accuracy=%s' % (quote_attrib(self.accuracy), ))
        if self.AUC is not None and 'AUC' not in already_processed:
            already_processed.add('AUC')
            outfile.write(' AUC=%s' % (quote_attrib(self.AUC), ))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (quote_attrib(self.precision), ))
        if self.recall is not None and 'recall' not in already_processed:
            already_processed.add('recall')
            outfile.write(' recall=%s' % (quote_attrib(self.recall), ))
        if self.specificity is not None and 'specificity' not in already_processed:
            already_processed.add('specificity')
            outfile.write(' specificity=%s' % (quote_attrib(self.specificity), ))
        if self.F1 is not None and 'F1' not in already_processed:
            already_processed.add('F1')
            outfile.write(' F1=%s' % (quote_attrib(self.F1), ))
        if self.F2 is not None and 'F2' not in already_processed:
            already_processed.add('F2')
            outfile.write(' F2=%s' % (quote_attrib(self.F2), ))
        if self.Fhalf is not None and 'Fhalf' not in already_processed:
            already_processed.add('Fhalf')
            outfile.write(' Fhalf=%s' % (quote_attrib(self.Fhalf), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PredictiveModelQuality', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.ConfusionMatrix is not None:
            self.ConfusionMatrix.export(outfile, level, namespace_, name_='ConfusionMatrix', pretty_print=pretty_print)
        for LiftData_ in self.LiftData:
            LiftData_.export(outfile, level, namespace_, name_='LiftData', pretty_print=pretty_print)
        if self.ROC is not None:
            self.ROC.export(outfile, level, namespace_, name_='ROC', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PredictiveModelQuality', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.targetField is not None:
            element.set('targetField', self.targetField)
        if self.dataName is not None:
            element.set('dataName', self.gds_format_string(self.dataName))
        if self.dataUsage is not None:
            element.set('dataUsage', self.gds_format_string(self.dataUsage))
        if self.meanError is not None:
            element.set('meanError', self.meanError)
        if self.meanAbsoluteError is not None:
            element.set('meanAbsoluteError', self.meanAbsoluteError)
        if self.meanSquaredError is not None:
            element.set('meanSquaredError', self.meanSquaredError)
        if self.rootMeanSquaredError is not None:
            element.set('rootMeanSquaredError', self.rootMeanSquaredError)
        if self.r_squared is not None:
            element.set('r-squared', self.r_squared)
        if self.adj_r_squared is not None:
            element.set('adj-r-squared', self.adj_r_squared)
        if self.sumSquaredError is not None:
            element.set('sumSquaredError', self.sumSquaredError)
        if self.sumSquaredRegression is not None:
            element.set('sumSquaredRegression', self.sumSquaredRegression)
        if self.numOfRecords is not None:
            element.set('numOfRecords', self.numOfRecords)
        if self.numOfRecordsWeighted is not None:
            element.set('numOfRecordsWeighted', self.numOfRecordsWeighted)
        if self.numOfPredictors is not None:
            element.set('numOfPredictors', self.numOfPredictors)
        if self.degreesOfFreedom is not None:
            element.set('degreesOfFreedom', self.degreesOfFreedom)
        if self.fStatistic is not None:
            element.set('fStatistic', self.fStatistic)
        if self.AIC is not None:
            element.set('AIC', self.AIC)
        if self.BIC is not None:
            element.set('BIC', self.BIC)
        if self.AICc is not None:
            element.set('AICc', self.AICc)
        if self.accuracy is not None:
            element.set('accuracy', self.accuracy)
        if self.AUC is not None:
            element.set('AUC', self.AUC)
        if self.precision is not None:
            element.set('precision', self.precision)
        if self.recall is not None:
            element.set('recall', self.recall)
        if self.specificity is not None:
            element.set('specificity', self.specificity)
        if self.F1 is not None:
            element.set('F1', self.F1)
        if self.F2 is not None:
            element.set('F2', self.F2)
        if self.Fhalf is not None:
            element.set('Fhalf', self.Fhalf)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.ConfusionMatrix is not None:
            ConfusionMatrix_ = self.ConfusionMatrix
            ConfusionMatrix_.to_etree(element, name_='ConfusionMatrix', mapping_=mapping_)
        for LiftData_ in self.LiftData:
            LiftData_.to_etree(element, name_='LiftData', mapping_=mapping_)
        if self.ROC is not None:
            ROC_ = self.ROC
            ROC_.to_etree(element, name_='ROC', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PredictiveModelQuality'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.targetField is not None and 'targetField' not in already_processed:
            already_processed.add('targetField')
            showIndent(outfile, level)
            outfile.write('targetField="%s",\n' % (self.targetField,))
        if self.dataName is not None and 'dataName' not in already_processed:
            already_processed.add('dataName')
            showIndent(outfile, level)
            outfile.write('dataName="%s",\n' % (self.dataName,))
        if self.dataUsage is not None and 'dataUsage' not in already_processed:
            already_processed.add('dataUsage')
            showIndent(outfile, level)
            outfile.write('dataUsage="%s",\n' % (self.dataUsage,))
        if self.meanError is not None and 'meanError' not in already_processed:
            already_processed.add('meanError')
            showIndent(outfile, level)
            outfile.write('meanError=%e,\n' % (self.meanError,))
        if self.meanAbsoluteError is not None and 'meanAbsoluteError' not in already_processed:
            already_processed.add('meanAbsoluteError')
            showIndent(outfile, level)
            outfile.write('meanAbsoluteError=%e,\n' % (self.meanAbsoluteError,))
        if self.meanSquaredError is not None and 'meanSquaredError' not in already_processed:
            already_processed.add('meanSquaredError')
            showIndent(outfile, level)
            outfile.write('meanSquaredError=%e,\n' % (self.meanSquaredError,))
        if self.rootMeanSquaredError is not None and 'rootMeanSquaredError' not in already_processed:
            already_processed.add('rootMeanSquaredError')
            showIndent(outfile, level)
            outfile.write('rootMeanSquaredError=%e,\n' % (self.rootMeanSquaredError,))
        if self.r_squared is not None and 'r_squared' not in already_processed:
            already_processed.add('r_squared')
            showIndent(outfile, level)
            outfile.write('r_squared=%e,\n' % (self.r_squared,))
        if self.adj_r_squared is not None and 'adj_r_squared' not in already_processed:
            already_processed.add('adj_r_squared')
            showIndent(outfile, level)
            outfile.write('adj_r_squared=%e,\n' % (self.adj_r_squared,))
        if self.sumSquaredError is not None and 'sumSquaredError' not in already_processed:
            already_processed.add('sumSquaredError')
            showIndent(outfile, level)
            outfile.write('sumSquaredError=%e,\n' % (self.sumSquaredError,))
        if self.sumSquaredRegression is not None and 'sumSquaredRegression' not in already_processed:
            already_processed.add('sumSquaredRegression')
            showIndent(outfile, level)
            outfile.write('sumSquaredRegression=%e,\n' % (self.sumSquaredRegression,))
        if self.numOfRecords is not None and 'numOfRecords' not in already_processed:
            already_processed.add('numOfRecords')
            showIndent(outfile, level)
            outfile.write('numOfRecords=%e,\n' % (self.numOfRecords,))
        if self.numOfRecordsWeighted is not None and 'numOfRecordsWeighted' not in already_processed:
            already_processed.add('numOfRecordsWeighted')
            showIndent(outfile, level)
            outfile.write('numOfRecordsWeighted=%e,\n' % (self.numOfRecordsWeighted,))
        if self.numOfPredictors is not None and 'numOfPredictors' not in already_processed:
            already_processed.add('numOfPredictors')
            showIndent(outfile, level)
            outfile.write('numOfPredictors=%e,\n' % (self.numOfPredictors,))
        if self.degreesOfFreedom is not None and 'degreesOfFreedom' not in already_processed:
            already_processed.add('degreesOfFreedom')
            showIndent(outfile, level)
            outfile.write('degreesOfFreedom=%e,\n' % (self.degreesOfFreedom,))
        if self.fStatistic is not None and 'fStatistic' not in already_processed:
            already_processed.add('fStatistic')
            showIndent(outfile, level)
            outfile.write('fStatistic=%e,\n' % (self.fStatistic,))
        if self.AIC is not None and 'AIC' not in already_processed:
            already_processed.add('AIC')
            showIndent(outfile, level)
            outfile.write('AIC=%e,\n' % (self.AIC,))
        if self.BIC is not None and 'BIC' not in already_processed:
            already_processed.add('BIC')
            showIndent(outfile, level)
            outfile.write('BIC=%e,\n' % (self.BIC,))
        if self.AICc is not None and 'AICc' not in already_processed:
            already_processed.add('AICc')
            showIndent(outfile, level)
            outfile.write('AICc=%e,\n' % (self.AICc,))
        if self.accuracy is not None and 'accuracy' not in already_processed:
            already_processed.add('accuracy')
            showIndent(outfile, level)
            outfile.write('accuracy=%e,\n' % (self.accuracy,))
        if self.AUC is not None and 'AUC' not in already_processed:
            already_processed.add('AUC')
            showIndent(outfile, level)
            outfile.write('AUC=%e,\n' % (self.AUC,))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            showIndent(outfile, level)
            outfile.write('precision=%e,\n' % (self.precision,))
        if self.recall is not None and 'recall' not in already_processed:
            already_processed.add('recall')
            showIndent(outfile, level)
            outfile.write('recall=%e,\n' % (self.recall,))
        if self.specificity is not None and 'specificity' not in already_processed:
            already_processed.add('specificity')
            showIndent(outfile, level)
            outfile.write('specificity=%e,\n' % (self.specificity,))
        if self.F1 is not None and 'F1' not in already_processed:
            already_processed.add('F1')
            showIndent(outfile, level)
            outfile.write('F1=%e,\n' % (self.F1,))
        if self.F2 is not None and 'F2' not in already_processed:
            already_processed.add('F2')
            showIndent(outfile, level)
            outfile.write('F2=%e,\n' % (self.F2,))
        if self.Fhalf is not None and 'Fhalf' not in already_processed:
            already_processed.add('Fhalf')
            showIndent(outfile, level)
            outfile.write('Fhalf=%e,\n' % (self.Fhalf,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ConfusionMatrix is not None:
            showIndent(outfile, level)
            outfile.write('ConfusionMatrix=model_.ConfusionMatrix(\n')
            self.ConfusionMatrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('LiftData=[\n')
        level += 1
        for LiftData_ in self.LiftData:
            showIndent(outfile, level)
            outfile.write('model_.LiftData(\n')
            LiftData_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ROC is not None:
            showIndent(outfile, level)
            outfile.write('ROC=model_.ROC(\n')
            self.ROC.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('targetField', node)
        if value is not None and 'targetField' not in already_processed:
            already_processed.add('targetField')
            self.targetField = value
            self.validate_FIELD_NAME(self.targetField)    # validate type FIELD-NAME
        value = find_attr_value_('dataName', node)
        if value is not None and 'dataName' not in already_processed:
            already_processed.add('dataName')
            self.dataName = value
        value = find_attr_value_('dataUsage', node)
        if value is not None and 'dataUsage' not in already_processed:
            already_processed.add('dataUsage')
            self.dataUsage = value
        value = find_attr_value_('meanError', node)
        if value is not None and 'meanError' not in already_processed:
            already_processed.add('meanError')
            try:
                self.meanError = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (meanError): %s' % exp)
            self.validate_NUMBER(self.meanError)    # validate type NUMBER
        value = find_attr_value_('meanAbsoluteError', node)
        if value is not None and 'meanAbsoluteError' not in already_processed:
            already_processed.add('meanAbsoluteError')
            try:
                self.meanAbsoluteError = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (meanAbsoluteError): %s' % exp)
            self.validate_NUMBER(self.meanAbsoluteError)    # validate type NUMBER
        value = find_attr_value_('meanSquaredError', node)
        if value is not None and 'meanSquaredError' not in already_processed:
            already_processed.add('meanSquaredError')
            try:
                self.meanSquaredError = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (meanSquaredError): %s' % exp)
            self.validate_NUMBER(self.meanSquaredError)    # validate type NUMBER
        value = find_attr_value_('rootMeanSquaredError', node)
        if value is not None and 'rootMeanSquaredError' not in already_processed:
            already_processed.add('rootMeanSquaredError')
            try:
                self.rootMeanSquaredError = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rootMeanSquaredError): %s' % exp)
            self.validate_NUMBER(self.rootMeanSquaredError)    # validate type NUMBER
        value = find_attr_value_('r-squared', node)
        if value is not None and 'r-squared' not in already_processed:
            already_processed.add('r-squared')
            try:
                self.r_squared = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (r-squared): %s' % exp)
            self.validate_NUMBER(self.r_squared)    # validate type NUMBER
        value = find_attr_value_('adj-r-squared', node)
        if value is not None and 'adj-r-squared' not in already_processed:
            already_processed.add('adj-r-squared')
            try:
                self.adj_r_squared = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (adj-r-squared): %s' % exp)
            self.validate_NUMBER(self.adj_r_squared)    # validate type NUMBER
        value = find_attr_value_('sumSquaredError', node)
        if value is not None and 'sumSquaredError' not in already_processed:
            already_processed.add('sumSquaredError')
            try:
                self.sumSquaredError = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sumSquaredError): %s' % exp)
            self.validate_NUMBER(self.sumSquaredError)    # validate type NUMBER
        value = find_attr_value_('sumSquaredRegression', node)
        if value is not None and 'sumSquaredRegression' not in already_processed:
            already_processed.add('sumSquaredRegression')
            try:
                self.sumSquaredRegression = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sumSquaredRegression): %s' % exp)
            self.validate_NUMBER(self.sumSquaredRegression)    # validate type NUMBER
        value = find_attr_value_('numOfRecords', node)
        if value is not None and 'numOfRecords' not in already_processed:
            already_processed.add('numOfRecords')
            try:
                self.numOfRecords = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (numOfRecords): %s' % exp)
            self.validate_NUMBER(self.numOfRecords)    # validate type NUMBER
        value = find_attr_value_('numOfRecordsWeighted', node)
        if value is not None and 'numOfRecordsWeighted' not in already_processed:
            already_processed.add('numOfRecordsWeighted')
            try:
                self.numOfRecordsWeighted = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (numOfRecordsWeighted): %s' % exp)
            self.validate_NUMBER(self.numOfRecordsWeighted)    # validate type NUMBER
        value = find_attr_value_('numOfPredictors', node)
        if value is not None and 'numOfPredictors' not in already_processed:
            already_processed.add('numOfPredictors')
            try:
                self.numOfPredictors = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (numOfPredictors): %s' % exp)
            self.validate_NUMBER(self.numOfPredictors)    # validate type NUMBER
        value = find_attr_value_('degreesOfFreedom', node)
        if value is not None and 'degreesOfFreedom' not in already_processed:
            already_processed.add('degreesOfFreedom')
            try:
                self.degreesOfFreedom = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (degreesOfFreedom): %s' % exp)
            self.validate_NUMBER(self.degreesOfFreedom)    # validate type NUMBER
        value = find_attr_value_('fStatistic', node)
        if value is not None and 'fStatistic' not in already_processed:
            already_processed.add('fStatistic')
            try:
                self.fStatistic = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (fStatistic): %s' % exp)
            self.validate_NUMBER(self.fStatistic)    # validate type NUMBER
        value = find_attr_value_('AIC', node)
        if value is not None and 'AIC' not in already_processed:
            already_processed.add('AIC')
            try:
                self.AIC = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (AIC): %s' % exp)
            self.validate_NUMBER(self.AIC)    # validate type NUMBER
        value = find_attr_value_('BIC', node)
        if value is not None and 'BIC' not in already_processed:
            already_processed.add('BIC')
            try:
                self.BIC = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (BIC): %s' % exp)
            self.validate_NUMBER(self.BIC)    # validate type NUMBER
        value = find_attr_value_('AICc', node)
        if value is not None and 'AICc' not in already_processed:
            already_processed.add('AICc')
            try:
                self.AICc = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (AICc): %s' % exp)
            self.validate_NUMBER(self.AICc)    # validate type NUMBER
        value = find_attr_value_('accuracy', node)
        if value is not None and 'accuracy' not in already_processed:
            already_processed.add('accuracy')
            try:
                self.accuracy = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (accuracy): %s' % exp)
            self.validate_NUMBER(self.accuracy)    # validate type NUMBER
        value = find_attr_value_('AUC', node)
        if value is not None and 'AUC' not in already_processed:
            already_processed.add('AUC')
            try:
                self.AUC = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (AUC): %s' % exp)
            self.validate_NUMBER(self.AUC)    # validate type NUMBER
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            try:
                self.precision = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (precision): %s' % exp)
            self.validate_NUMBER(self.precision)    # validate type NUMBER
        value = find_attr_value_('recall', node)
        if value is not None and 'recall' not in already_processed:
            already_processed.add('recall')
            try:
                self.recall = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (recall): %s' % exp)
            self.validate_NUMBER(self.recall)    # validate type NUMBER
        value = find_attr_value_('specificity', node)
        if value is not None and 'specificity' not in already_processed:
            already_processed.add('specificity')
            try:
                self.specificity = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (specificity): %s' % exp)
            self.validate_NUMBER(self.specificity)    # validate type NUMBER
        value = find_attr_value_('F1', node)
        if value is not None and 'F1' not in already_processed:
            already_processed.add('F1')
            try:
                self.F1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (F1): %s' % exp)
            self.validate_NUMBER(self.F1)    # validate type NUMBER
        value = find_attr_value_('F2', node)
        if value is not None and 'F2' not in already_processed:
            already_processed.add('F2')
            try:
                self.F2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (F2): %s' % exp)
            self.validate_NUMBER(self.F2)    # validate type NUMBER
        value = find_attr_value_('Fhalf', node)
        if value is not None and 'Fhalf' not in already_processed:
            already_processed.add('Fhalf')
            try:
                self.Fhalf = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Fhalf): %s' % exp)
            self.validate_NUMBER(self.Fhalf)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ConfusionMatrix':
            obj_ = ConfusionMatrix.factory()
            obj_.build(child_)
            self.ConfusionMatrix = obj_
            obj_.original_tagname_ = 'ConfusionMatrix'
        elif nodeName_ == 'LiftData':
            obj_ = LiftData.factory()
            obj_.build(child_)
            self.LiftData.append(obj_)
            obj_.original_tagname_ = 'LiftData'
        elif nodeName_ == 'ROC':
            obj_ = ROC.factory()
            obj_.build(child_)
            self.ROC = obj_
            obj_.original_tagname_ = 'ROC'
# end class PredictiveModelQuality


class ClusteringModelQuality(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dataName=None, SSE=None, SSB=None, Extension=None):
        self.original_tagname_ = None
        self.dataName = _cast(None, dataName)
        self.SSE = _cast(None, SSE)
        self.SSB = _cast(None, SSB)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClusteringModelQuality)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClusteringModelQuality.subclass:
            return ClusteringModelQuality.subclass(*args_, **kwargs_)
        else:
            return ClusteringModelQuality(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_dataName(self): return self.dataName
    def set_dataName(self, dataName): self.dataName = dataName
    def get_SSE(self): return self.SSE
    def set_SSE(self, SSE): self.SSE = SSE
    def get_SSB(self): return self.SSB
    def set_SSB(self, SSB): self.SSB = SSB
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClusteringModelQuality', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClusteringModelQuality')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClusteringModelQuality')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClusteringModelQuality', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClusteringModelQuality'):
        if self.dataName is not None and 'dataName' not in already_processed:
            already_processed.add('dataName')
            outfile.write(' dataName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataName), input_name='dataName')), ))
        if self.SSE is not None and 'SSE' not in already_processed:
            already_processed.add('SSE')
            outfile.write(' SSE=%s' % (quote_attrib(self.SSE), ))
        if self.SSB is not None and 'SSB' not in already_processed:
            already_processed.add('SSB')
            outfile.write(' SSB=%s' % (quote_attrib(self.SSB), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ClusteringModelQuality', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ClusteringModelQuality', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.dataName is not None:
            element.set('dataName', self.gds_format_string(self.dataName))
        if self.SSE is not None:
            element.set('SSE', self.SSE)
        if self.SSB is not None:
            element.set('SSB', self.SSB)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ClusteringModelQuality'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dataName is not None and 'dataName' not in already_processed:
            already_processed.add('dataName')
            showIndent(outfile, level)
            outfile.write('dataName="%s",\n' % (self.dataName,))
        if self.SSE is not None and 'SSE' not in already_processed:
            already_processed.add('SSE')
            showIndent(outfile, level)
            outfile.write('SSE=%e,\n' % (self.SSE,))
        if self.SSB is not None and 'SSB' not in already_processed:
            already_processed.add('SSB')
            showIndent(outfile, level)
            outfile.write('SSB=%e,\n' % (self.SSB,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dataName', node)
        if value is not None and 'dataName' not in already_processed:
            already_processed.add('dataName')
            self.dataName = value
        value = find_attr_value_('SSE', node)
        if value is not None and 'SSE' not in already_processed:
            already_processed.add('SSE')
            try:
                self.SSE = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (SSE): %s' % exp)
            self.validate_NUMBER(self.SSE)    # validate type NUMBER
        value = find_attr_value_('SSB', node)
        if value is not None and 'SSB' not in already_processed:
            already_processed.add('SSB')
            try:
                self.SSB = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (SSB): %s' % exp)
            self.validate_NUMBER(self.SSB)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class ClusteringModelQuality


class LiftData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, targetFieldValue=None, targetFieldDisplayValue=None, rankingQuality=None, Extension=None, ModelLiftGraph=None, OptimumLiftGraph=None, RandomLiftGraph=None):
        self.original_tagname_ = None
        self.targetFieldValue = _cast(None, targetFieldValue)
        self.targetFieldDisplayValue = _cast(None, targetFieldDisplayValue)
        self.rankingQuality = _cast(None, rankingQuality)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.ModelLiftGraph = ModelLiftGraph
        self.OptimumLiftGraph = OptimumLiftGraph
        self.RandomLiftGraph = RandomLiftGraph
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LiftData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LiftData.subclass:
            return LiftData.subclass(*args_, **kwargs_)
        else:
            return LiftData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_ModelLiftGraph(self): return self.ModelLiftGraph
    def set_ModelLiftGraph(self, ModelLiftGraph): self.ModelLiftGraph = ModelLiftGraph
    def get_OptimumLiftGraph(self): return self.OptimumLiftGraph
    def set_OptimumLiftGraph(self, OptimumLiftGraph): self.OptimumLiftGraph = OptimumLiftGraph
    def get_RandomLiftGraph(self): return self.RandomLiftGraph
    def set_RandomLiftGraph(self, RandomLiftGraph): self.RandomLiftGraph = RandomLiftGraph
    def get_targetFieldValue(self): return self.targetFieldValue
    def set_targetFieldValue(self, targetFieldValue): self.targetFieldValue = targetFieldValue
    def get_targetFieldDisplayValue(self): return self.targetFieldDisplayValue
    def set_targetFieldDisplayValue(self, targetFieldDisplayValue): self.targetFieldDisplayValue = targetFieldDisplayValue
    def get_rankingQuality(self): return self.rankingQuality
    def set_rankingQuality(self, rankingQuality): self.rankingQuality = rankingQuality
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.ModelLiftGraph is not None or
            self.OptimumLiftGraph is not None or
            self.RandomLiftGraph is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LiftData', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LiftData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LiftData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LiftData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LiftData'):
        if self.targetFieldValue is not None and 'targetFieldValue' not in already_processed:
            already_processed.add('targetFieldValue')
            outfile.write(' targetFieldValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetFieldValue), input_name='targetFieldValue')), ))
        if self.targetFieldDisplayValue is not None and 'targetFieldDisplayValue' not in already_processed:
            already_processed.add('targetFieldDisplayValue')
            outfile.write(' targetFieldDisplayValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetFieldDisplayValue), input_name='targetFieldDisplayValue')), ))
        if self.rankingQuality is not None and 'rankingQuality' not in already_processed:
            already_processed.add('rankingQuality')
            outfile.write(' rankingQuality=%s' % (quote_attrib(self.rankingQuality), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LiftData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.ModelLiftGraph is not None:
            self.ModelLiftGraph.export(outfile, level, namespace_, name_='ModelLiftGraph', pretty_print=pretty_print)
        if self.OptimumLiftGraph is not None:
            self.OptimumLiftGraph.export(outfile, level, namespace_, name_='OptimumLiftGraph', pretty_print=pretty_print)
        if self.RandomLiftGraph is not None:
            self.RandomLiftGraph.export(outfile, level, namespace_, name_='RandomLiftGraph', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='LiftData', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.targetFieldValue is not None:
            element.set('targetFieldValue', self.gds_format_string(self.targetFieldValue))
        if self.targetFieldDisplayValue is not None:
            element.set('targetFieldDisplayValue', self.gds_format_string(self.targetFieldDisplayValue))
        if self.rankingQuality is not None:
            element.set('rankingQuality', self.rankingQuality)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.ModelLiftGraph is not None:
            ModelLiftGraph_ = self.ModelLiftGraph
            ModelLiftGraph_.to_etree(element, name_='ModelLiftGraph', mapping_=mapping_)
        if self.OptimumLiftGraph is not None:
            OptimumLiftGraph_ = self.OptimumLiftGraph
            OptimumLiftGraph_.to_etree(element, name_='OptimumLiftGraph', mapping_=mapping_)
        if self.RandomLiftGraph is not None:
            RandomLiftGraph_ = self.RandomLiftGraph
            RandomLiftGraph_.to_etree(element, name_='RandomLiftGraph', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='LiftData'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.targetFieldValue is not None and 'targetFieldValue' not in already_processed:
            already_processed.add('targetFieldValue')
            showIndent(outfile, level)
            outfile.write('targetFieldValue="%s",\n' % (self.targetFieldValue,))
        if self.targetFieldDisplayValue is not None and 'targetFieldDisplayValue' not in already_processed:
            already_processed.add('targetFieldDisplayValue')
            showIndent(outfile, level)
            outfile.write('targetFieldDisplayValue="%s",\n' % (self.targetFieldDisplayValue,))
        if self.rankingQuality is not None and 'rankingQuality' not in already_processed:
            already_processed.add('rankingQuality')
            showIndent(outfile, level)
            outfile.write('rankingQuality=%e,\n' % (self.rankingQuality,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ModelLiftGraph is not None:
            showIndent(outfile, level)
            outfile.write('ModelLiftGraph=model_.ModelLiftGraph(\n')
            self.ModelLiftGraph.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OptimumLiftGraph is not None:
            showIndent(outfile, level)
            outfile.write('OptimumLiftGraph=model_.OptimumLiftGraph(\n')
            self.OptimumLiftGraph.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RandomLiftGraph is not None:
            showIndent(outfile, level)
            outfile.write('RandomLiftGraph=model_.RandomLiftGraph(\n')
            self.RandomLiftGraph.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('targetFieldValue', node)
        if value is not None and 'targetFieldValue' not in already_processed:
            already_processed.add('targetFieldValue')
            self.targetFieldValue = value
        value = find_attr_value_('targetFieldDisplayValue', node)
        if value is not None and 'targetFieldDisplayValue' not in already_processed:
            already_processed.add('targetFieldDisplayValue')
            self.targetFieldDisplayValue = value
        value = find_attr_value_('rankingQuality', node)
        if value is not None and 'rankingQuality' not in already_processed:
            already_processed.add('rankingQuality')
            try:
                self.rankingQuality = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rankingQuality): %s' % exp)
            self.validate_NUMBER(self.rankingQuality)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ModelLiftGraph':
            obj_ = ModelLiftGraph.factory()
            obj_.build(child_)
            self.ModelLiftGraph = obj_
            obj_.original_tagname_ = 'ModelLiftGraph'
        elif nodeName_ == 'OptimumLiftGraph':
            obj_ = OptimumLiftGraph.factory()
            obj_.build(child_)
            self.OptimumLiftGraph = obj_
            obj_.original_tagname_ = 'OptimumLiftGraph'
        elif nodeName_ == 'RandomLiftGraph':
            obj_ = RandomLiftGraph.factory()
            obj_.build(child_)
            self.RandomLiftGraph = obj_
            obj_.original_tagname_ = 'RandomLiftGraph'
# end class LiftData


class ModelLiftGraph(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, LiftGraph=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.LiftGraph = LiftGraph
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ModelLiftGraph)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ModelLiftGraph.subclass:
            return ModelLiftGraph.subclass(*args_, **kwargs_)
        else:
            return ModelLiftGraph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_LiftGraph(self): return self.LiftGraph
    def set_LiftGraph(self, LiftGraph): self.LiftGraph = LiftGraph
    def hasContent_(self):
        if (
            self.Extension or
            self.LiftGraph is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ModelLiftGraph', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ModelLiftGraph')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModelLiftGraph')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ModelLiftGraph', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ModelLiftGraph'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ModelLiftGraph', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.LiftGraph is not None:
            self.LiftGraph.export(outfile, level, namespace_, name_='LiftGraph', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ModelLiftGraph', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.LiftGraph is not None:
            LiftGraph_ = self.LiftGraph
            LiftGraph_.to_etree(element, name_='LiftGraph', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ModelLiftGraph'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.LiftGraph is not None:
            showIndent(outfile, level)
            outfile.write('LiftGraph=model_.LiftGraph(\n')
            self.LiftGraph.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'LiftGraph':
            obj_ = LiftGraph.factory()
            obj_.build(child_)
            self.LiftGraph = obj_
            obj_.original_tagname_ = 'LiftGraph'
# end class ModelLiftGraph


class OptimumLiftGraph(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, LiftGraph=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.LiftGraph = LiftGraph
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptimumLiftGraph)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptimumLiftGraph.subclass:
            return OptimumLiftGraph.subclass(*args_, **kwargs_)
        else:
            return OptimumLiftGraph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_LiftGraph(self): return self.LiftGraph
    def set_LiftGraph(self, LiftGraph): self.LiftGraph = LiftGraph
    def hasContent_(self):
        if (
            self.Extension or
            self.LiftGraph is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OptimumLiftGraph', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OptimumLiftGraph')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptimumLiftGraph')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OptimumLiftGraph', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OptimumLiftGraph'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OptimumLiftGraph', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.LiftGraph is not None:
            self.LiftGraph.export(outfile, level, namespace_, name_='LiftGraph', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='OptimumLiftGraph', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.LiftGraph is not None:
            LiftGraph_ = self.LiftGraph
            LiftGraph_.to_etree(element, name_='LiftGraph', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='OptimumLiftGraph'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.LiftGraph is not None:
            showIndent(outfile, level)
            outfile.write('LiftGraph=model_.LiftGraph(\n')
            self.LiftGraph.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'LiftGraph':
            obj_ = LiftGraph.factory()
            obj_.build(child_)
            self.LiftGraph = obj_
            obj_.original_tagname_ = 'LiftGraph'
# end class OptimumLiftGraph


class RandomLiftGraph(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, LiftGraph=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.LiftGraph = LiftGraph
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RandomLiftGraph)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RandomLiftGraph.subclass:
            return RandomLiftGraph.subclass(*args_, **kwargs_)
        else:
            return RandomLiftGraph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_LiftGraph(self): return self.LiftGraph
    def set_LiftGraph(self, LiftGraph): self.LiftGraph = LiftGraph
    def hasContent_(self):
        if (
            self.Extension or
            self.LiftGraph is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RandomLiftGraph', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RandomLiftGraph')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RandomLiftGraph')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RandomLiftGraph', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RandomLiftGraph'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RandomLiftGraph', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.LiftGraph is not None:
            self.LiftGraph.export(outfile, level, namespace_, name_='LiftGraph', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='RandomLiftGraph', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.LiftGraph is not None:
            LiftGraph_ = self.LiftGraph
            LiftGraph_.to_etree(element, name_='LiftGraph', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='RandomLiftGraph'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.LiftGraph is not None:
            showIndent(outfile, level)
            outfile.write('LiftGraph=model_.LiftGraph(\n')
            self.LiftGraph.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'LiftGraph':
            obj_ = LiftGraph.factory()
            obj_.build(child_)
            self.LiftGraph = obj_
            obj_.original_tagname_ = 'LiftGraph'
# end class RandomLiftGraph


class LiftGraph(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, XCoordinates=None, YCoordinates=None, BoundaryValues=None, BoundaryValueMeans=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.XCoordinates = XCoordinates
        self.YCoordinates = YCoordinates
        self.BoundaryValues = BoundaryValues
        self.BoundaryValueMeans = BoundaryValueMeans
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LiftGraph)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LiftGraph.subclass:
            return LiftGraph.subclass(*args_, **kwargs_)
        else:
            return LiftGraph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_XCoordinates(self): return self.XCoordinates
    def set_XCoordinates(self, XCoordinates): self.XCoordinates = XCoordinates
    def get_YCoordinates(self): return self.YCoordinates
    def set_YCoordinates(self, YCoordinates): self.YCoordinates = YCoordinates
    def get_BoundaryValues(self): return self.BoundaryValues
    def set_BoundaryValues(self, BoundaryValues): self.BoundaryValues = BoundaryValues
    def get_BoundaryValueMeans(self): return self.BoundaryValueMeans
    def set_BoundaryValueMeans(self, BoundaryValueMeans): self.BoundaryValueMeans = BoundaryValueMeans
    def hasContent_(self):
        if (
            self.Extension or
            self.XCoordinates is not None or
            self.YCoordinates is not None or
            self.BoundaryValues is not None or
            self.BoundaryValueMeans is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LiftGraph', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LiftGraph')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LiftGraph')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LiftGraph', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LiftGraph'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LiftGraph', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.XCoordinates is not None:
            self.XCoordinates.export(outfile, level, namespace_, name_='XCoordinates', pretty_print=pretty_print)
        if self.YCoordinates is not None:
            self.YCoordinates.export(outfile, level, namespace_, name_='YCoordinates', pretty_print=pretty_print)
        if self.BoundaryValues is not None:
            self.BoundaryValues.export(outfile, level, namespace_, name_='BoundaryValues', pretty_print=pretty_print)
        if self.BoundaryValueMeans is not None:
            self.BoundaryValueMeans.export(outfile, level, namespace_, name_='BoundaryValueMeans', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='LiftGraph', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.XCoordinates is not None:
            XCoordinates_ = self.XCoordinates
            XCoordinates_.to_etree(element, name_='XCoordinates', mapping_=mapping_)
        if self.YCoordinates is not None:
            YCoordinates_ = self.YCoordinates
            YCoordinates_.to_etree(element, name_='YCoordinates', mapping_=mapping_)
        if self.BoundaryValues is not None:
            BoundaryValues_ = self.BoundaryValues
            BoundaryValues_.to_etree(element, name_='BoundaryValues', mapping_=mapping_)
        if self.BoundaryValueMeans is not None:
            BoundaryValueMeans_ = self.BoundaryValueMeans
            BoundaryValueMeans_.to_etree(element, name_='BoundaryValueMeans', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='LiftGraph'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.XCoordinates is not None:
            showIndent(outfile, level)
            outfile.write('XCoordinates=model_.XCoordinates(\n')
            self.XCoordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.YCoordinates is not None:
            showIndent(outfile, level)
            outfile.write('YCoordinates=model_.YCoordinates(\n')
            self.YCoordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BoundaryValues is not None:
            showIndent(outfile, level)
            outfile.write('BoundaryValues=model_.BoundaryValues(\n')
            self.BoundaryValues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BoundaryValueMeans is not None:
            showIndent(outfile, level)
            outfile.write('BoundaryValueMeans=model_.BoundaryValueMeans(\n')
            self.BoundaryValueMeans.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'XCoordinates':
            obj_ = XCoordinates.factory()
            obj_.build(child_)
            self.XCoordinates = obj_
            obj_.original_tagname_ = 'XCoordinates'
        elif nodeName_ == 'YCoordinates':
            obj_ = YCoordinates.factory()
            obj_.build(child_)
            self.YCoordinates = obj_
            obj_.original_tagname_ = 'YCoordinates'
        elif nodeName_ == 'BoundaryValues':
            obj_ = BoundaryValues.factory()
            obj_.build(child_)
            self.BoundaryValues = obj_
            obj_.original_tagname_ = 'BoundaryValues'
        elif nodeName_ == 'BoundaryValueMeans':
            obj_ = BoundaryValueMeans.factory()
            obj_.build(child_)
            self.BoundaryValueMeans = obj_
            obj_.original_tagname_ = 'BoundaryValueMeans'
# end class LiftGraph


class XCoordinates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XCoordinates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XCoordinates.subclass:
            return XCoordinates.subclass(*args_, **kwargs_)
        else:
            return XCoordinates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='XCoordinates', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XCoordinates')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XCoordinates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='XCoordinates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='XCoordinates'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='XCoordinates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='XCoordinates', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='XCoordinates'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class XCoordinates


class YCoordinates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, YCoordinates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if YCoordinates.subclass:
            return YCoordinates.subclass(*args_, **kwargs_)
        else:
            return YCoordinates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='YCoordinates', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('YCoordinates')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='YCoordinates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='YCoordinates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='YCoordinates'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='YCoordinates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='YCoordinates', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='YCoordinates'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class YCoordinates


class BoundaryValues(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BoundaryValues)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BoundaryValues.subclass:
            return BoundaryValues.subclass(*args_, **kwargs_)
        else:
            return BoundaryValues(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BoundaryValues', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BoundaryValues')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoundaryValues')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BoundaryValues', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BoundaryValues'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BoundaryValues', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BoundaryValues', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BoundaryValues'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class BoundaryValues


class BoundaryValueMeans(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BoundaryValueMeans)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BoundaryValueMeans.subclass:
            return BoundaryValueMeans.subclass(*args_, **kwargs_)
        else:
            return BoundaryValueMeans(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BoundaryValueMeans', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BoundaryValueMeans')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoundaryValueMeans')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BoundaryValueMeans', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BoundaryValueMeans'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BoundaryValueMeans', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BoundaryValueMeans', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BoundaryValueMeans'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class BoundaryValueMeans


class ROC(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, positiveTargetFieldValue=None, positiveTargetFieldDisplayValue=None, negativeTargetFieldValue=None, negativeTargetFieldDisplayValue=None, Extension=None, ROCGraph=None):
        self.original_tagname_ = None
        self.positiveTargetFieldValue = _cast(None, positiveTargetFieldValue)
        self.positiveTargetFieldDisplayValue = _cast(None, positiveTargetFieldDisplayValue)
        self.negativeTargetFieldValue = _cast(None, negativeTargetFieldValue)
        self.negativeTargetFieldDisplayValue = _cast(None, negativeTargetFieldDisplayValue)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.ROCGraph = ROCGraph
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ROC)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ROC.subclass:
            return ROC.subclass(*args_, **kwargs_)
        else:
            return ROC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_ROCGraph(self): return self.ROCGraph
    def set_ROCGraph(self, ROCGraph): self.ROCGraph = ROCGraph
    def get_positiveTargetFieldValue(self): return self.positiveTargetFieldValue
    def set_positiveTargetFieldValue(self, positiveTargetFieldValue): self.positiveTargetFieldValue = positiveTargetFieldValue
    def get_positiveTargetFieldDisplayValue(self): return self.positiveTargetFieldDisplayValue
    def set_positiveTargetFieldDisplayValue(self, positiveTargetFieldDisplayValue): self.positiveTargetFieldDisplayValue = positiveTargetFieldDisplayValue
    def get_negativeTargetFieldValue(self): return self.negativeTargetFieldValue
    def set_negativeTargetFieldValue(self, negativeTargetFieldValue): self.negativeTargetFieldValue = negativeTargetFieldValue
    def get_negativeTargetFieldDisplayValue(self): return self.negativeTargetFieldDisplayValue
    def set_negativeTargetFieldDisplayValue(self, negativeTargetFieldDisplayValue): self.negativeTargetFieldDisplayValue = negativeTargetFieldDisplayValue
    def hasContent_(self):
        if (
            self.Extension or
            self.ROCGraph is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ROC', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ROC')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ROC')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ROC', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ROC'):
        if self.positiveTargetFieldValue is not None and 'positiveTargetFieldValue' not in already_processed:
            already_processed.add('positiveTargetFieldValue')
            outfile.write(' positiveTargetFieldValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.positiveTargetFieldValue), input_name='positiveTargetFieldValue')), ))
        if self.positiveTargetFieldDisplayValue is not None and 'positiveTargetFieldDisplayValue' not in already_processed:
            already_processed.add('positiveTargetFieldDisplayValue')
            outfile.write(' positiveTargetFieldDisplayValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.positiveTargetFieldDisplayValue), input_name='positiveTargetFieldDisplayValue')), ))
        if self.negativeTargetFieldValue is not None and 'negativeTargetFieldValue' not in already_processed:
            already_processed.add('negativeTargetFieldValue')
            outfile.write(' negativeTargetFieldValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.negativeTargetFieldValue), input_name='negativeTargetFieldValue')), ))
        if self.negativeTargetFieldDisplayValue is not None and 'negativeTargetFieldDisplayValue' not in already_processed:
            already_processed.add('negativeTargetFieldDisplayValue')
            outfile.write(' negativeTargetFieldDisplayValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.negativeTargetFieldDisplayValue), input_name='negativeTargetFieldDisplayValue')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ROC', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.ROCGraph is not None:
            self.ROCGraph.export(outfile, level, namespace_, name_='ROCGraph', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ROC', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.positiveTargetFieldValue is not None:
            element.set('positiveTargetFieldValue', self.gds_format_string(self.positiveTargetFieldValue))
        if self.positiveTargetFieldDisplayValue is not None:
            element.set('positiveTargetFieldDisplayValue', self.gds_format_string(self.positiveTargetFieldDisplayValue))
        if self.negativeTargetFieldValue is not None:
            element.set('negativeTargetFieldValue', self.gds_format_string(self.negativeTargetFieldValue))
        if self.negativeTargetFieldDisplayValue is not None:
            element.set('negativeTargetFieldDisplayValue', self.gds_format_string(self.negativeTargetFieldDisplayValue))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.ROCGraph is not None:
            ROCGraph_ = self.ROCGraph
            ROCGraph_.to_etree(element, name_='ROCGraph', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ROC'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.positiveTargetFieldValue is not None and 'positiveTargetFieldValue' not in already_processed:
            already_processed.add('positiveTargetFieldValue')
            showIndent(outfile, level)
            outfile.write('positiveTargetFieldValue="%s",\n' % (self.positiveTargetFieldValue,))
        if self.positiveTargetFieldDisplayValue is not None and 'positiveTargetFieldDisplayValue' not in already_processed:
            already_processed.add('positiveTargetFieldDisplayValue')
            showIndent(outfile, level)
            outfile.write('positiveTargetFieldDisplayValue="%s",\n' % (self.positiveTargetFieldDisplayValue,))
        if self.negativeTargetFieldValue is not None and 'negativeTargetFieldValue' not in already_processed:
            already_processed.add('negativeTargetFieldValue')
            showIndent(outfile, level)
            outfile.write('negativeTargetFieldValue="%s",\n' % (self.negativeTargetFieldValue,))
        if self.negativeTargetFieldDisplayValue is not None and 'negativeTargetFieldDisplayValue' not in already_processed:
            already_processed.add('negativeTargetFieldDisplayValue')
            showIndent(outfile, level)
            outfile.write('negativeTargetFieldDisplayValue="%s",\n' % (self.negativeTargetFieldDisplayValue,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ROCGraph is not None:
            showIndent(outfile, level)
            outfile.write('ROCGraph=model_.ROCGraph(\n')
            self.ROCGraph.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('positiveTargetFieldValue', node)
        if value is not None and 'positiveTargetFieldValue' not in already_processed:
            already_processed.add('positiveTargetFieldValue')
            self.positiveTargetFieldValue = value
        value = find_attr_value_('positiveTargetFieldDisplayValue', node)
        if value is not None and 'positiveTargetFieldDisplayValue' not in already_processed:
            already_processed.add('positiveTargetFieldDisplayValue')
            self.positiveTargetFieldDisplayValue = value
        value = find_attr_value_('negativeTargetFieldValue', node)
        if value is not None and 'negativeTargetFieldValue' not in already_processed:
            already_processed.add('negativeTargetFieldValue')
            self.negativeTargetFieldValue = value
        value = find_attr_value_('negativeTargetFieldDisplayValue', node)
        if value is not None and 'negativeTargetFieldDisplayValue' not in already_processed:
            already_processed.add('negativeTargetFieldDisplayValue')
            self.negativeTargetFieldDisplayValue = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ROCGraph':
            obj_ = ROCGraph.factory()
            obj_.build(child_)
            self.ROCGraph = obj_
            obj_.original_tagname_ = 'ROCGraph'
# end class ROC


class ROCGraph(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, XCoordinates=None, YCoordinates=None, BoundaryValues=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.XCoordinates = XCoordinates
        self.YCoordinates = YCoordinates
        self.BoundaryValues = BoundaryValues
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ROCGraph)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ROCGraph.subclass:
            return ROCGraph.subclass(*args_, **kwargs_)
        else:
            return ROCGraph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_XCoordinates(self): return self.XCoordinates
    def set_XCoordinates(self, XCoordinates): self.XCoordinates = XCoordinates
    def get_YCoordinates(self): return self.YCoordinates
    def set_YCoordinates(self, YCoordinates): self.YCoordinates = YCoordinates
    def get_BoundaryValues(self): return self.BoundaryValues
    def set_BoundaryValues(self, BoundaryValues): self.BoundaryValues = BoundaryValues
    def hasContent_(self):
        if (
            self.Extension or
            self.XCoordinates is not None or
            self.YCoordinates is not None or
            self.BoundaryValues is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ROCGraph', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ROCGraph')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ROCGraph')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ROCGraph', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ROCGraph'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ROCGraph', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.XCoordinates is not None:
            self.XCoordinates.export(outfile, level, namespace_, name_='XCoordinates', pretty_print=pretty_print)
        if self.YCoordinates is not None:
            self.YCoordinates.export(outfile, level, namespace_, name_='YCoordinates', pretty_print=pretty_print)
        if self.BoundaryValues is not None:
            self.BoundaryValues.export(outfile, level, namespace_, name_='BoundaryValues', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ROCGraph', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.XCoordinates is not None:
            XCoordinates_ = self.XCoordinates
            XCoordinates_.to_etree(element, name_='XCoordinates', mapping_=mapping_)
        if self.YCoordinates is not None:
            YCoordinates_ = self.YCoordinates
            YCoordinates_.to_etree(element, name_='YCoordinates', mapping_=mapping_)
        if self.BoundaryValues is not None:
            BoundaryValues_ = self.BoundaryValues
            BoundaryValues_.to_etree(element, name_='BoundaryValues', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ROCGraph'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.XCoordinates is not None:
            showIndent(outfile, level)
            outfile.write('XCoordinates=model_.XCoordinates(\n')
            self.XCoordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.YCoordinates is not None:
            showIndent(outfile, level)
            outfile.write('YCoordinates=model_.YCoordinates(\n')
            self.YCoordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BoundaryValues is not None:
            showIndent(outfile, level)
            outfile.write('BoundaryValues=model_.BoundaryValues(\n')
            self.BoundaryValues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'XCoordinates':
            obj_ = XCoordinates.factory()
            obj_.build(child_)
            self.XCoordinates = obj_
            obj_.original_tagname_ = 'XCoordinates'
        elif nodeName_ == 'YCoordinates':
            obj_ = YCoordinates.factory()
            obj_.build(child_)
            self.YCoordinates = obj_
            obj_.original_tagname_ = 'YCoordinates'
        elif nodeName_ == 'BoundaryValues':
            obj_ = BoundaryValues.factory()
            obj_.build(child_)
            self.BoundaryValues = obj_
            obj_.original_tagname_ = 'BoundaryValues'
# end class ROCGraph


class ConfusionMatrix(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, ClassLabels=None, Matrix=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.ClassLabels = ClassLabels
        self.Matrix = Matrix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConfusionMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConfusionMatrix.subclass:
            return ConfusionMatrix.subclass(*args_, **kwargs_)
        else:
            return ConfusionMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_ClassLabels(self): return self.ClassLabels
    def set_ClassLabels(self, ClassLabels): self.ClassLabels = ClassLabels
    def get_Matrix(self): return self.Matrix
    def set_Matrix(self, Matrix): self.Matrix = Matrix
    def hasContent_(self):
        if (
            self.Extension or
            self.ClassLabels is not None or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConfusionMatrix', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConfusionMatrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConfusionMatrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConfusionMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConfusionMatrix'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConfusionMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.ClassLabels is not None:
            self.ClassLabels.export(outfile, level, namespace_, name_='ClassLabels', pretty_print=pretty_print)
        if self.Matrix is not None:
            self.Matrix.export(outfile, level, namespace_, name_='Matrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ConfusionMatrix', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.ClassLabels is not None:
            ClassLabels_ = self.ClassLabels
            ClassLabels_.to_etree(element, name_='ClassLabels', mapping_=mapping_)
        if self.Matrix is not None:
            Matrix_ = self.Matrix
            Matrix_.to_etree(element, name_='Matrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ConfusionMatrix'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ClassLabels is not None:
            showIndent(outfile, level)
            outfile.write('ClassLabels=model_.ClassLabels(\n')
            self.ClassLabels.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Matrix is not None:
            showIndent(outfile, level)
            outfile.write('Matrix=model_.Matrix(\n')
            self.Matrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ClassLabels':
            obj_ = ClassLabels.factory()
            obj_.build(child_)
            self.ClassLabels = obj_
            obj_.original_tagname_ = 'ClassLabels'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory()
            obj_.build(child_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class ConfusionMatrix


class ClassLabels(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassLabels)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassLabels.subclass:
            return ClassLabels.subclass(*args_, **kwargs_)
        else:
            return ClassLabels(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClassLabels', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClassLabels')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClassLabels')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClassLabels', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClassLabels'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ClassLabels', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ClassLabels', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ClassLabels'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class ClassLabels


class Correlations(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, CorrelationFields=None, CorrelationValues=None, CorrelationMethods=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.CorrelationFields = CorrelationFields
        self.CorrelationValues = CorrelationValues
        self.CorrelationMethods = CorrelationMethods
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Correlations)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Correlations.subclass:
            return Correlations.subclass(*args_, **kwargs_)
        else:
            return Correlations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_CorrelationFields(self): return self.CorrelationFields
    def set_CorrelationFields(self, CorrelationFields): self.CorrelationFields = CorrelationFields
    def get_CorrelationValues(self): return self.CorrelationValues
    def set_CorrelationValues(self, CorrelationValues): self.CorrelationValues = CorrelationValues
    def get_CorrelationMethods(self): return self.CorrelationMethods
    def set_CorrelationMethods(self, CorrelationMethods): self.CorrelationMethods = CorrelationMethods
    def hasContent_(self):
        if (
            self.Extension or
            self.CorrelationFields is not None or
            self.CorrelationValues is not None or
            self.CorrelationMethods is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Correlations', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Correlations')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Correlations')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Correlations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Correlations'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Correlations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.CorrelationFields is not None:
            self.CorrelationFields.export(outfile, level, namespace_, name_='CorrelationFields', pretty_print=pretty_print)
        if self.CorrelationValues is not None:
            self.CorrelationValues.export(outfile, level, namespace_, name_='CorrelationValues', pretty_print=pretty_print)
        if self.CorrelationMethods is not None:
            self.CorrelationMethods.export(outfile, level, namespace_, name_='CorrelationMethods', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Correlations', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.CorrelationFields is not None:
            CorrelationFields_ = self.CorrelationFields
            CorrelationFields_.to_etree(element, name_='CorrelationFields', mapping_=mapping_)
        if self.CorrelationValues is not None:
            CorrelationValues_ = self.CorrelationValues
            CorrelationValues_.to_etree(element, name_='CorrelationValues', mapping_=mapping_)
        if self.CorrelationMethods is not None:
            CorrelationMethods_ = self.CorrelationMethods
            CorrelationMethods_.to_etree(element, name_='CorrelationMethods', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Correlations'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.CorrelationFields is not None:
            showIndent(outfile, level)
            outfile.write('CorrelationFields=model_.CorrelationFields(\n')
            self.CorrelationFields.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CorrelationValues is not None:
            showIndent(outfile, level)
            outfile.write('CorrelationValues=model_.CorrelationValues(\n')
            self.CorrelationValues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CorrelationMethods is not None:
            showIndent(outfile, level)
            outfile.write('CorrelationMethods=model_.CorrelationMethods(\n')
            self.CorrelationMethods.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'CorrelationFields':
            obj_ = CorrelationFields.factory()
            obj_.build(child_)
            self.CorrelationFields = obj_
            obj_.original_tagname_ = 'CorrelationFields'
        elif nodeName_ == 'CorrelationValues':
            obj_ = CorrelationValues.factory()
            obj_.build(child_)
            self.CorrelationValues = obj_
            obj_.original_tagname_ = 'CorrelationValues'
        elif nodeName_ == 'CorrelationMethods':
            obj_ = CorrelationMethods.factory()
            obj_.build(child_)
            self.CorrelationMethods = obj_
            obj_.original_tagname_ = 'CorrelationMethods'
# end class Correlations


class CorrelationFields(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrelationFields)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrelationFields.subclass:
            return CorrelationFields.subclass(*args_, **kwargs_)
        else:
            return CorrelationFields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CorrelationFields', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CorrelationFields')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CorrelationFields')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CorrelationFields', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CorrelationFields'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CorrelationFields', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='CorrelationFields', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CorrelationFields'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class CorrelationFields


class CorrelationValues(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Matrix=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Matrix = Matrix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrelationValues)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrelationValues.subclass:
            return CorrelationValues.subclass(*args_, **kwargs_)
        else:
            return CorrelationValues(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Matrix(self): return self.Matrix
    def set_Matrix(self, Matrix): self.Matrix = Matrix
    def hasContent_(self):
        if (
            self.Extension or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CorrelationValues', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CorrelationValues')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CorrelationValues')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CorrelationValues', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CorrelationValues'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CorrelationValues', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Matrix is not None:
            self.Matrix.export(outfile, level, namespace_, name_='Matrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='CorrelationValues', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Matrix is not None:
            Matrix_ = self.Matrix
            Matrix_.to_etree(element, name_='Matrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CorrelationValues'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Matrix is not None:
            showIndent(outfile, level)
            outfile.write('Matrix=model_.Matrix(\n')
            self.Matrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory()
            obj_.build(child_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class CorrelationValues


class CorrelationMethods(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Matrix=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Matrix = Matrix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrelationMethods)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrelationMethods.subclass:
            return CorrelationMethods.subclass(*args_, **kwargs_)
        else:
            return CorrelationMethods(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Matrix(self): return self.Matrix
    def set_Matrix(self, Matrix): self.Matrix = Matrix
    def hasContent_(self):
        if (
            self.Extension or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CorrelationMethods', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CorrelationMethods')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CorrelationMethods')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CorrelationMethods', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CorrelationMethods'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CorrelationMethods', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Matrix is not None:
            self.Matrix.export(outfile, level, namespace_, name_='Matrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='CorrelationMethods', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Matrix is not None:
            Matrix_ = self.Matrix
            Matrix_.to_etree(element, name_='Matrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CorrelationMethods'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Matrix is not None:
            showIndent(outfile, level)
            outfile.write('Matrix=model_.Matrix(\n')
            self.Matrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory()
            obj_.build(child_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class CorrelationMethods


class Taxonomy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, Extension=None, ChildParent=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if ChildParent is None:
            self.ChildParent = []
        else:
            self.ChildParent = ChildParent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Taxonomy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Taxonomy.subclass:
            return Taxonomy.subclass(*args_, **kwargs_)
        else:
            return Taxonomy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_ChildParent(self): return self.ChildParent
    def set_ChildParent(self, ChildParent): self.ChildParent = ChildParent
    def add_ChildParent(self, value): self.ChildParent.append(value)
    def insert_ChildParent_at(self, index, value): self.ChildParent.insert(index, value)
    def replace_ChildParent_at(self, index, value): self.ChildParent[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.Extension or
            self.ChildParent
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Taxonomy', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Taxonomy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Taxonomy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Taxonomy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Taxonomy'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Taxonomy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for ChildParent_ in self.ChildParent:
            ChildParent_.export(outfile, level, namespace_, name_='ChildParent', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Taxonomy', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for ChildParent_ in self.ChildParent:
            ChildParent_.to_etree(element, name_='ChildParent', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Taxonomy'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChildParent=[\n')
        level += 1
        for ChildParent_ in self.ChildParent:
            showIndent(outfile, level)
            outfile.write('model_.ChildParent(\n')
            ChildParent_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ChildParent':
            obj_ = ChildParent.factory()
            obj_.build(child_)
            self.ChildParent.append(obj_)
            obj_.original_tagname_ = 'ChildParent'
# end class Taxonomy


class ChildParent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, childField=None, parentField=None, parentLevelField=None, isRecursive='no', Extension=None, FieldColumnPair=None, TableLocator=None, InlineTable=None):
        self.original_tagname_ = None
        self.childField = _cast(None, childField)
        self.parentField = _cast(None, parentField)
        self.parentLevelField = _cast(None, parentLevelField)
        self.isRecursive = _cast(None, isRecursive)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if FieldColumnPair is None:
            self.FieldColumnPair = []
        else:
            self.FieldColumnPair = FieldColumnPair
        self.TableLocator = TableLocator
        self.InlineTable = InlineTable
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChildParent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChildParent.subclass:
            return ChildParent.subclass(*args_, **kwargs_)
        else:
            return ChildParent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_FieldColumnPair(self): return self.FieldColumnPair
    def set_FieldColumnPair(self, FieldColumnPair): self.FieldColumnPair = FieldColumnPair
    def add_FieldColumnPair(self, value): self.FieldColumnPair.append(value)
    def insert_FieldColumnPair_at(self, index, value): self.FieldColumnPair.insert(index, value)
    def replace_FieldColumnPair_at(self, index, value): self.FieldColumnPair[index] = value
    def get_TableLocator(self): return self.TableLocator
    def set_TableLocator(self, TableLocator): self.TableLocator = TableLocator
    def get_InlineTable(self): return self.InlineTable
    def set_InlineTable(self, InlineTable): self.InlineTable = InlineTable
    def get_childField(self): return self.childField
    def set_childField(self, childField): self.childField = childField
    def get_parentField(self): return self.parentField
    def set_parentField(self, parentField): self.parentField = parentField
    def get_parentLevelField(self): return self.parentLevelField
    def set_parentLevelField(self, parentLevelField): self.parentLevelField = parentLevelField
    def get_isRecursive(self): return self.isRecursive
    def set_isRecursive(self, isRecursive): self.isRecursive = isRecursive
    def hasContent_(self):
        if (
            self.Extension or
            self.FieldColumnPair or
            self.TableLocator is not None or
            self.InlineTable is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ChildParent', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChildParent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChildParent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ChildParent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChildParent'):
        if self.childField is not None and 'childField' not in already_processed:
            already_processed.add('childField')
            outfile.write(' childField=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.childField), input_name='childField')), ))
        if self.parentField is not None and 'parentField' not in already_processed:
            already_processed.add('parentField')
            outfile.write(' parentField=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parentField), input_name='parentField')), ))
        if self.parentLevelField is not None and 'parentLevelField' not in already_processed:
            already_processed.add('parentLevelField')
            outfile.write(' parentLevelField=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parentLevelField), input_name='parentLevelField')), ))
        if self.isRecursive != "no" and 'isRecursive' not in already_processed:
            already_processed.add('isRecursive')
            outfile.write(' isRecursive=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.isRecursive), input_name='isRecursive')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChildParent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for FieldColumnPair_ in self.FieldColumnPair:
            FieldColumnPair_.export(outfile, level, namespace_, name_='FieldColumnPair', pretty_print=pretty_print)
        if self.TableLocator is not None:
            self.TableLocator.export(outfile, level, namespace_, name_='TableLocator', pretty_print=pretty_print)
        if self.InlineTable is not None:
            self.InlineTable.export(outfile, level, namespace_, name_='InlineTable', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ChildParent', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.childField is not None:
            element.set('childField', self.gds_format_string(self.childField))
        if self.parentField is not None:
            element.set('parentField', self.gds_format_string(self.parentField))
        if self.parentLevelField is not None:
            element.set('parentLevelField', self.gds_format_string(self.parentLevelField))
        if self.isRecursive is not None:
            element.set('isRecursive', self.gds_format_string(self.isRecursive))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for FieldColumnPair_ in self.FieldColumnPair:
            FieldColumnPair_.to_etree(element, name_='FieldColumnPair', mapping_=mapping_)
        if self.TableLocator is not None:
            TableLocator_ = self.TableLocator
            TableLocator_.to_etree(element, name_='TableLocator', mapping_=mapping_)
        if self.InlineTable is not None:
            InlineTable_ = self.InlineTable
            InlineTable_.to_etree(element, name_='InlineTable', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ChildParent'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.childField is not None and 'childField' not in already_processed:
            already_processed.add('childField')
            showIndent(outfile, level)
            outfile.write('childField="%s",\n' % (self.childField,))
        if self.parentField is not None and 'parentField' not in already_processed:
            already_processed.add('parentField')
            showIndent(outfile, level)
            outfile.write('parentField="%s",\n' % (self.parentField,))
        if self.parentLevelField is not None and 'parentLevelField' not in already_processed:
            already_processed.add('parentLevelField')
            showIndent(outfile, level)
            outfile.write('parentLevelField="%s",\n' % (self.parentLevelField,))
        if self.isRecursive is not None and 'isRecursive' not in already_processed:
            already_processed.add('isRecursive')
            showIndent(outfile, level)
            outfile.write('isRecursive="%s",\n' % (self.isRecursive,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FieldColumnPair=[\n')
        level += 1
        for FieldColumnPair_ in self.FieldColumnPair:
            showIndent(outfile, level)
            outfile.write('model_.FieldColumnPair(\n')
            FieldColumnPair_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.TableLocator is not None:
            showIndent(outfile, level)
            outfile.write('TableLocator=model_.TableLocator(\n')
            self.TableLocator.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InlineTable is not None:
            showIndent(outfile, level)
            outfile.write('InlineTable=model_.InlineTable(\n')
            self.InlineTable.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('childField', node)
        if value is not None and 'childField' not in already_processed:
            already_processed.add('childField')
            self.childField = value
        value = find_attr_value_('parentField', node)
        if value is not None and 'parentField' not in already_processed:
            already_processed.add('parentField')
            self.parentField = value
        value = find_attr_value_('parentLevelField', node)
        if value is not None and 'parentLevelField' not in already_processed:
            already_processed.add('parentLevelField')
            self.parentLevelField = value
        value = find_attr_value_('isRecursive', node)
        if value is not None and 'isRecursive' not in already_processed:
            already_processed.add('isRecursive')
            self.isRecursive = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'FieldColumnPair':
            obj_ = FieldColumnPair.factory()
            obj_.build(child_)
            self.FieldColumnPair.append(obj_)
            obj_.original_tagname_ = 'FieldColumnPair'
        elif nodeName_ == 'TableLocator':
            obj_ = TableLocator.factory()
            obj_.build(child_)
            self.TableLocator = obj_
            obj_.original_tagname_ = 'TableLocator'
        elif nodeName_ == 'InlineTable':
            obj_ = InlineTable.factory()
            obj_.build(child_)
            self.InlineTable = obj_
            obj_.original_tagname_ = 'InlineTable'
# end class ChildParent


class TableLocator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TableLocator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TableLocator.subclass:
            return TableLocator.subclass(*args_, **kwargs_)
        else:
            return TableLocator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TableLocator', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TableLocator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TableLocator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TableLocator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TableLocator'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TableLocator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TableLocator', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TableLocator'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class TableLocator


class InlineTable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, row=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if row is None:
            self.row = []
        else:
            self.row = row
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InlineTable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InlineTable.subclass:
            return InlineTable.subclass(*args_, **kwargs_)
        else:
            return InlineTable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row_at(self, index, value): self.row.insert(index, value)
    def replace_row_at(self, index, value): self.row[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.row
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InlineTable', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InlineTable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InlineTable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InlineTable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InlineTable'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InlineTable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for row_ in self.row:
            row_.export(outfile, level, namespace_, name_='row', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InlineTable', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for row_ in self.row:
            row_.to_etree(element, name_='row', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='InlineTable'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('row=[\n')
        level += 1
        for row_ in self.row:
            showIndent(outfile, level)
            outfile.write('model_.row(\n')
            row_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'row':
            obj_ = row.factory()
            obj_.build(child_)
            self.row.append(obj_)
            obj_.original_tagname_ = 'row'
# end class InlineTable


class row(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.elementobjs_ = []
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, row)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if row.subclass:
            return row.subclass(*args_, **kwargs_)
        else:
            return row(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_ or self.elementobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='row', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('row')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='row')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='row', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='row'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='row', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            try:
                obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
            except:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write(eol_)
        for objName_ in self.elementobjs_:
            obj_ = eval("self." + objName_)
            if eval("isinstance(obj_, list)"):
                for s in obj_:
                    showIndent(outfile, level, pretty_print)
                    outfile.write("<" + objName_ + ">" + str(s) + "</" + objName_ + ">")
                    outfile.write(eol_)
            else:
                showIndent(outfile, level, pretty_print)
                outfile.write("<" + objName_ + ">" + str(obj_) + "</" + objName_ + ">")
                outfile.write(eol_)
    def to_etree(self, parent_element=None, name_='row', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for obj_ in self.anytypeobjs_:
            obj_.to_etree(element)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='row'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        if self.anytypeobjs_ == []:
            self.anytypeobjs_ = list(filter(None, [obj_.lstrip(' ') for obj_ in node.text.split('\n')]))
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not hasattr(self, "elementobjs_"):
            self.elementobjs_ = []
        if hasattr(self, nodeName_) and nodeName_ not in self.elementobjs_:
            nodeName_ += '_'
        if nodeName_ not in self.elementobjs_:
            self.elementobjs_.append(nodeName_)
        if not eval("hasattr(self, '" + nodeName_ + "')"):
            exec("self." + nodeName_ + " = " + list(filter(None, [obj_.lstrip(' ') for obj_ in child_.text.split('\n')]))[0])
        else:
            exec("self." + nodeName_ + " = list(self." + nodeName_ + ")")
            exec("self." + nodeName_ + ".append(" + list(filter(None, [obj_.lstrip(' ') for obj_ in child_.text.split('\n')]))[0] + ")")
# end class row


class AssociationModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, numberOfTransactions=None, maxNumberOfItemsPerTA=None, avgNumberOfItemsPerTA=None, minimumSupport=None, minimumConfidence=None, lengthLimit=None, numberOfItems=None, numberOfItemsets=None, numberOfRules=None, isScorable=True, MiningSchema=None, Output=None, ModelStats=None, LocalTransformations=None, Item=None, Itemset=None, AssociationRule=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.numberOfTransactions = _cast(int, numberOfTransactions)
        self.maxNumberOfItemsPerTA = _cast(int, maxNumberOfItemsPerTA)
        self.avgNumberOfItemsPerTA = _cast(None, avgNumberOfItemsPerTA)
        self.minimumSupport = _cast(None, minimumSupport)
        self.minimumConfidence = _cast(None, minimumConfidence)
        self.lengthLimit = _cast(None, lengthLimit)
        self.numberOfItems = _cast(int, numberOfItems)
        self.numberOfItemsets = _cast(int, numberOfItemsets)
        self.numberOfRules = _cast(int, numberOfRules)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.LocalTransformations = LocalTransformations
        if Item is None:
            self.Item = []
        else:
            self.Item = Item
        if Itemset is None:
            self.Itemset = []
        else:
            self.Itemset = Itemset
        if AssociationRule is None:
            self.AssociationRule = []
        else:
            self.AssociationRule = AssociationRule
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssociationModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssociationModel.subclass:
            return AssociationModel.subclass(*args_, **kwargs_)
        else:
            return AssociationModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_Item(self): return self.Item
    def set_Item(self, Item): self.Item = Item
    def add_Item(self, value): self.Item.append(value)
    def insert_Item_at(self, index, value): self.Item.insert(index, value)
    def replace_Item_at(self, index, value): self.Item[index] = value
    def get_Itemset(self): return self.Itemset
    def set_Itemset(self, Itemset): self.Itemset = Itemset
    def add_Itemset(self, value): self.Itemset.append(value)
    def insert_Itemset_at(self, index, value): self.Itemset.insert(index, value)
    def replace_Itemset_at(self, index, value): self.Itemset[index] = value
    def get_AssociationRule(self): return self.AssociationRule
    def set_AssociationRule(self, AssociationRule): self.AssociationRule = AssociationRule
    def add_AssociationRule(self, value): self.AssociationRule.append(value)
    def insert_AssociationRule_at(self, index, value): self.AssociationRule.insert(index, value)
    def replace_AssociationRule_at(self, index, value): self.AssociationRule[index] = value
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_numberOfTransactions(self): return self.numberOfTransactions
    def set_numberOfTransactions(self, numberOfTransactions): self.numberOfTransactions = numberOfTransactions
    def get_maxNumberOfItemsPerTA(self): return self.maxNumberOfItemsPerTA
    def set_maxNumberOfItemsPerTA(self, maxNumberOfItemsPerTA): self.maxNumberOfItemsPerTA = maxNumberOfItemsPerTA
    def get_avgNumberOfItemsPerTA(self): return self.avgNumberOfItemsPerTA
    def set_avgNumberOfItemsPerTA(self, avgNumberOfItemsPerTA): self.avgNumberOfItemsPerTA = avgNumberOfItemsPerTA
    def get_minimumSupport(self): return self.minimumSupport
    def set_minimumSupport(self, minimumSupport): self.minimumSupport = minimumSupport
    def get_minimumConfidence(self): return self.minimumConfidence
    def set_minimumConfidence(self, minimumConfidence): self.minimumConfidence = minimumConfidence
    def get_lengthLimit(self): return self.lengthLimit
    def set_lengthLimit(self, lengthLimit): self.lengthLimit = lengthLimit
    def get_numberOfItems(self): return self.numberOfItems
    def set_numberOfItems(self, numberOfItems): self.numberOfItems = numberOfItems
    def get_numberOfItemsets(self): return self.numberOfItemsets
    def set_numberOfItemsets(self, numberOfItemsets): self.numberOfItemsets = numberOfItemsets
    def get_numberOfRules(self): return self.numberOfRules
    def set_numberOfRules(self, numberOfRules): self.numberOfRules = numberOfRules
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.LocalTransformations is not None or
            self.Item or
            self.Itemset or
            self.AssociationRule or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssociationModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssociationModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssociationModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssociationModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssociationModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.numberOfTransactions is not None and 'numberOfTransactions' not in already_processed:
            already_processed.add('numberOfTransactions')
            outfile.write(' numberOfTransactions="%s"' % self.gds_format_integer(self.numberOfTransactions, input_name='numberOfTransactions'))
        if self.maxNumberOfItemsPerTA is not None and 'maxNumberOfItemsPerTA' not in already_processed:
            already_processed.add('maxNumberOfItemsPerTA')
            outfile.write(' maxNumberOfItemsPerTA="%s"' % self.gds_format_integer(self.maxNumberOfItemsPerTA, input_name='maxNumberOfItemsPerTA'))
        if self.avgNumberOfItemsPerTA is not None and 'avgNumberOfItemsPerTA' not in already_processed:
            already_processed.add('avgNumberOfItemsPerTA')
            outfile.write(' avgNumberOfItemsPerTA=%s' % (quote_attrib(self.avgNumberOfItemsPerTA), ))
        if self.minimumSupport is not None and 'minimumSupport' not in already_processed:
            already_processed.add('minimumSupport')
            outfile.write(' minimumSupport=%s' % (quote_attrib(self.minimumSupport), ))
        if self.minimumConfidence is not None and 'minimumConfidence' not in already_processed:
            already_processed.add('minimumConfidence')
            outfile.write(' minimumConfidence=%s' % (quote_attrib(self.minimumConfidence), ))
        if self.lengthLimit is not None and 'lengthLimit' not in already_processed:
            already_processed.add('lengthLimit')
            outfile.write(' lengthLimit=%s' % (quote_attrib(self.lengthLimit), ))
        if self.numberOfItems is not None and 'numberOfItems' not in already_processed:
            already_processed.add('numberOfItems')
            outfile.write(' numberOfItems="%s"' % self.gds_format_integer(self.numberOfItems, input_name='numberOfItems'))
        if self.numberOfItemsets is not None and 'numberOfItemsets' not in already_processed:
            already_processed.add('numberOfItemsets')
            outfile.write(' numberOfItemsets="%s"' % self.gds_format_integer(self.numberOfItemsets, input_name='numberOfItemsets'))
        if self.numberOfRules is not None and 'numberOfRules' not in already_processed:
            already_processed.add('numberOfRules')
            outfile.write(' numberOfRules="%s"' % self.gds_format_integer(self.numberOfRules, input_name='numberOfRules'))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='AssociationModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        for Item_ in self.Item:
            Item_.export(outfile, level, namespace_, name_='Item', pretty_print=pretty_print)
        for Itemset_ in self.Itemset:
            Itemset_.export(outfile, level, namespace_, name_='Itemset', pretty_print=pretty_print)
        for AssociationRule_ in self.AssociationRule:
            AssociationRule_.export(outfile, level, namespace_, name_='AssociationRule', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AssociationModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.numberOfTransactions is not None:
            element.set('numberOfTransactions', self.gds_format_integer(self.numberOfTransactions))
        if self.maxNumberOfItemsPerTA is not None:
            element.set('maxNumberOfItemsPerTA', self.gds_format_integer(self.maxNumberOfItemsPerTA))
        if self.avgNumberOfItemsPerTA is not None:
            element.set('avgNumberOfItemsPerTA', self.avgNumberOfItemsPerTA)
        if self.minimumSupport is not None:
            element.set('minimumSupport', self.minimumSupport)
        if self.minimumConfidence is not None:
            element.set('minimumConfidence', self.minimumConfidence)
        if self.lengthLimit is not None:
            element.set('lengthLimit', self.lengthLimit)
        if self.numberOfItems is not None:
            element.set('numberOfItems', self.gds_format_integer(self.numberOfItems))
        if self.numberOfItemsets is not None:
            element.set('numberOfItemsets', self.gds_format_integer(self.numberOfItemsets))
        if self.numberOfRules is not None:
            element.set('numberOfRules', self.gds_format_integer(self.numberOfRules))
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        for Item_ in self.Item:
            Item_.to_etree(element, name_='Item', mapping_=mapping_)
        for Itemset_ in self.Itemset:
            Itemset_.to_etree(element, name_='Itemset', mapping_=mapping_)
        for AssociationRule_ in self.AssociationRule:
            AssociationRule_.to_etree(element, name_='AssociationRule', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='AssociationModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.numberOfTransactions is not None and 'numberOfTransactions' not in already_processed:
            already_processed.add('numberOfTransactions')
            showIndent(outfile, level)
            outfile.write('numberOfTransactions=%d,\n' % (self.numberOfTransactions,))
        if self.maxNumberOfItemsPerTA is not None and 'maxNumberOfItemsPerTA' not in already_processed:
            already_processed.add('maxNumberOfItemsPerTA')
            showIndent(outfile, level)
            outfile.write('maxNumberOfItemsPerTA=%d,\n' % (self.maxNumberOfItemsPerTA,))
        if self.avgNumberOfItemsPerTA is not None and 'avgNumberOfItemsPerTA' not in already_processed:
            already_processed.add('avgNumberOfItemsPerTA')
            showIndent(outfile, level)
            outfile.write('avgNumberOfItemsPerTA=%e,\n' % (self.avgNumberOfItemsPerTA,))
        if self.minimumSupport is not None and 'minimumSupport' not in already_processed:
            already_processed.add('minimumSupport')
            showIndent(outfile, level)
            outfile.write('minimumSupport=%e,\n' % (self.minimumSupport,))
        if self.minimumConfidence is not None and 'minimumConfidence' not in already_processed:
            already_processed.add('minimumConfidence')
            showIndent(outfile, level)
            outfile.write('minimumConfidence=%e,\n' % (self.minimumConfidence,))
        if self.lengthLimit is not None and 'lengthLimit' not in already_processed:
            already_processed.add('lengthLimit')
            showIndent(outfile, level)
            outfile.write('lengthLimit=%d,\n' % (self.lengthLimit,))
        if self.numberOfItems is not None and 'numberOfItems' not in already_processed:
            already_processed.add('numberOfItems')
            showIndent(outfile, level)
            outfile.write('numberOfItems=%d,\n' % (self.numberOfItems,))
        if self.numberOfItemsets is not None and 'numberOfItemsets' not in already_processed:
            already_processed.add('numberOfItemsets')
            showIndent(outfile, level)
            outfile.write('numberOfItemsets=%d,\n' % (self.numberOfItemsets,))
        if self.numberOfRules is not None and 'numberOfRules' not in already_processed:
            already_processed.add('numberOfRules')
            showIndent(outfile, level)
            outfile.write('numberOfRules=%d,\n' % (self.numberOfRules,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Item=[\n')
        level += 1
        for Item_ in self.Item:
            showIndent(outfile, level)
            outfile.write('model_.Item(\n')
            Item_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Itemset=[\n')
        level += 1
        for Itemset_ in self.Itemset:
            showIndent(outfile, level)
            outfile.write('model_.Itemset(\n')
            Itemset_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AssociationRule=[\n')
        level += 1
        for AssociationRule_ in self.AssociationRule:
            showIndent(outfile, level)
            outfile.write('model_.AssociationRule(\n')
            AssociationRule_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('numberOfTransactions', node)
        if value is not None and 'numberOfTransactions' not in already_processed:
            already_processed.add('numberOfTransactions')
            try:
                self.numberOfTransactions = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfTransactions < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('maxNumberOfItemsPerTA', node)
        if value is not None and 'maxNumberOfItemsPerTA' not in already_processed:
            already_processed.add('maxNumberOfItemsPerTA')
            try:
                self.maxNumberOfItemsPerTA = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.maxNumberOfItemsPerTA < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('avgNumberOfItemsPerTA', node)
        if value is not None and 'avgNumberOfItemsPerTA' not in already_processed:
            already_processed.add('avgNumberOfItemsPerTA')
            try:
                self.avgNumberOfItemsPerTA = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (avgNumberOfItemsPerTA): %s' % exp)
            self.validate_REAL_NUMBER(self.avgNumberOfItemsPerTA)    # validate type REAL-NUMBER
        value = find_attr_value_('minimumSupport', node)
        if value is not None and 'minimumSupport' not in already_processed:
            already_processed.add('minimumSupport')
            try:
                self.minimumSupport = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (minimumSupport): %s' % exp)
            self.validate_PROB_NUMBER(self.minimumSupport)    # validate type PROB-NUMBER
        value = find_attr_value_('minimumConfidence', node)
        if value is not None and 'minimumConfidence' not in already_processed:
            already_processed.add('minimumConfidence')
            try:
                self.minimumConfidence = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (minimumConfidence): %s' % exp)
            self.validate_PROB_NUMBER(self.minimumConfidence)    # validate type PROB-NUMBER
        value = find_attr_value_('lengthLimit', node)
        if value is not None and 'lengthLimit' not in already_processed:
            already_processed.add('lengthLimit')
            try:
                self.lengthLimit = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.lengthLimit)    # validate type INT-NUMBER
        value = find_attr_value_('numberOfItems', node)
        if value is not None and 'numberOfItems' not in already_processed:
            already_processed.add('numberOfItems')
            try:
                self.numberOfItems = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfItems < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('numberOfItemsets', node)
        if value is not None and 'numberOfItemsets' not in already_processed:
            already_processed.add('numberOfItemsets')
            try:
                self.numberOfItemsets = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfItemsets < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('numberOfRules', node)
        if value is not None and 'numberOfRules' not in already_processed:
            already_processed.add('numberOfRules')
            try:
                self.numberOfRules = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfRules < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'Item':
            obj_ = Item.factory()
            obj_.build(child_)
            self.Item.append(obj_)
            obj_.original_tagname_ = 'Item'
        elif nodeName_ == 'Itemset':
            obj_ = Itemset.factory()
            obj_.build(child_)
            self.Itemset.append(obj_)
            obj_.original_tagname_ = 'Itemset'
        elif nodeName_ == 'AssociationRule':
            obj_ = AssociationRule.factory()
            obj_.build(child_)
            self.AssociationRule.append(obj_)
            obj_.original_tagname_ = 'AssociationRule'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class AssociationModel


class Item(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, value=None, field=None, category=None, mappedValue=None, weight=None, Extension=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.value = _cast(None, value)
        self.field = _cast(None, field)
        self.category = _cast(None, category)
        self.mappedValue = _cast(None, mappedValue)
        self.weight = _cast(None, weight)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Item)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Item.subclass:
            return Item.subclass(*args_, **kwargs_)
        else:
            return Item(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_mappedValue(self): return self.mappedValue
    def set_mappedValue(self, mappedValue): self.mappedValue = mappedValue
    def get_weight(self): return self.weight
    def set_weight(self, weight): self.weight = weight
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Item', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Item')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Item')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Item', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Item'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.category), input_name='category')), ))
        if self.mappedValue is not None and 'mappedValue' not in already_processed:
            already_processed.add('mappedValue')
            outfile.write(' mappedValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mappedValue), input_name='mappedValue')), ))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight=%s' % (quote_attrib(self.weight), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Item', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Item', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.field is not None:
            element.set('field', self.field)
        if self.category is not None:
            element.set('category', self.gds_format_string(self.category))
        if self.mappedValue is not None:
            element.set('mappedValue', self.gds_format_string(self.mappedValue))
        if self.weight is not None:
            element.set('weight', self.weight)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Item'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            showIndent(outfile, level)
            outfile.write('category="%s",\n' % (self.category,))
        if self.mappedValue is not None and 'mappedValue' not in already_processed:
            already_processed.add('mappedValue')
            showIndent(outfile, level)
            outfile.write('mappedValue="%s",\n' % (self.mappedValue,))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            showIndent(outfile, level)
            outfile.write('weight=%e,\n' % (self.weight,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
        value = find_attr_value_('mappedValue', node)
        if value is not None and 'mappedValue' not in already_processed:
            already_processed.add('mappedValue')
            self.mappedValue = value
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            try:
                self.weight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (weight): %s' % exp)
            self.validate_REAL_NUMBER(self.weight)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Item


class Itemset(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, support=None, numberOfItems=None, Extension=None, ItemRef=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.support = _cast(None, support)
        self.numberOfItems = _cast(int, numberOfItems)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if ItemRef is None:
            self.ItemRef = []
        else:
            self.ItemRef = ItemRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Itemset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Itemset.subclass:
            return Itemset.subclass(*args_, **kwargs_)
        else:
            return Itemset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_ItemRef(self): return self.ItemRef
    def set_ItemRef(self, ItemRef): self.ItemRef = ItemRef
    def add_ItemRef(self, value): self.ItemRef.append(value)
    def insert_ItemRef_at(self, index, value): self.ItemRef.insert(index, value)
    def replace_ItemRef_at(self, index, value): self.ItemRef[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_support(self): return self.support
    def set_support(self, support): self.support = support
    def get_numberOfItems(self): return self.numberOfItems
    def set_numberOfItems(self, numberOfItems): self.numberOfItems = numberOfItems
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.ItemRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Itemset', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Itemset')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Itemset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Itemset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Itemset'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.support is not None and 'support' not in already_processed:
            already_processed.add('support')
            outfile.write(' support=%s' % (quote_attrib(self.support), ))
        if self.numberOfItems is not None and 'numberOfItems' not in already_processed:
            already_processed.add('numberOfItems')
            outfile.write(' numberOfItems="%s"' % self.gds_format_integer(self.numberOfItems, input_name='numberOfItems'))
    def exportChildren(self, outfile, level, namespace_='', name_='Itemset', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for ItemRef_ in self.ItemRef:
            ItemRef_.export(outfile, level, namespace_, name_='ItemRef', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Itemset', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.support is not None:
            element.set('support', self.support)
        if self.numberOfItems is not None:
            element.set('numberOfItems', self.gds_format_integer(self.numberOfItems))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for ItemRef_ in self.ItemRef:
            ItemRef_.to_etree(element, name_='ItemRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Itemset'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.support is not None and 'support' not in already_processed:
            already_processed.add('support')
            showIndent(outfile, level)
            outfile.write('support=%e,\n' % (self.support,))
        if self.numberOfItems is not None and 'numberOfItems' not in already_processed:
            already_processed.add('numberOfItems')
            showIndent(outfile, level)
            outfile.write('numberOfItems=%d,\n' % (self.numberOfItems,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ItemRef=[\n')
        level += 1
        for ItemRef_ in self.ItemRef:
            showIndent(outfile, level)
            outfile.write('model_.ItemRef(\n')
            ItemRef_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('support', node)
        if value is not None and 'support' not in already_processed:
            already_processed.add('support')
            try:
                self.support = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (support): %s' % exp)
            self.validate_PROB_NUMBER(self.support)    # validate type PROB-NUMBER
        value = find_attr_value_('numberOfItems', node)
        if value is not None and 'numberOfItems' not in already_processed:
            already_processed.add('numberOfItems')
            try:
                self.numberOfItems = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfItems < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ItemRef':
            obj_ = ItemRef.factory()
            obj_.build(child_)
            self.ItemRef.append(obj_)
            obj_.original_tagname_ = 'ItemRef'
# end class Itemset


class ItemRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, itemRef=None, Extension=None):
        self.original_tagname_ = None
        self.itemRef = _cast(None, itemRef)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ItemRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ItemRef.subclass:
            return ItemRef.subclass(*args_, **kwargs_)
        else:
            return ItemRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_itemRef(self): return self.itemRef
    def set_itemRef(self, itemRef): self.itemRef = itemRef
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ItemRef', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ItemRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ItemRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ItemRef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ItemRef'):
        if self.itemRef is not None and 'itemRef' not in already_processed:
            already_processed.add('itemRef')
            outfile.write(' itemRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.itemRef), input_name='itemRef')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ItemRef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ItemRef', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.itemRef is not None:
            element.set('itemRef', self.gds_format_string(self.itemRef))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ItemRef'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.itemRef is not None and 'itemRef' not in already_processed:
            already_processed.add('itemRef')
            showIndent(outfile, level)
            outfile.write('itemRef="%s",\n' % (self.itemRef,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('itemRef', node)
        if value is not None and 'itemRef' not in already_processed:
            already_processed.add('itemRef')
            self.itemRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class ItemRef


class AssociationRule(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, antecedent=None, consequent=None, support=None, confidence=None, lift=None, leverage=None, affinity=None, id=None, Extension=None):
        self.original_tagname_ = None
        self.antecedent = _cast(None, antecedent)
        self.consequent = _cast(None, consequent)
        self.support = _cast(None, support)
        self.confidence = _cast(None, confidence)
        self.lift = _cast(float, lift)
        self.leverage = _cast(float, leverage)
        self.affinity = _cast(None, affinity)
        self.id = _cast(None, id)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssociationRule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssociationRule.subclass:
            return AssociationRule.subclass(*args_, **kwargs_)
        else:
            return AssociationRule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_antecedent(self): return self.antecedent
    def set_antecedent(self, antecedent): self.antecedent = antecedent
    def get_consequent(self): return self.consequent
    def set_consequent(self, consequent): self.consequent = consequent
    def get_support(self): return self.support
    def set_support(self, support): self.support = support
    def get_confidence(self): return self.confidence
    def set_confidence(self, confidence): self.confidence = confidence
    def get_lift(self): return self.lift
    def set_lift(self, lift): self.lift = lift
    def get_leverage(self): return self.leverage
    def set_leverage(self, leverage): self.leverage = leverage
    def get_affinity(self): return self.affinity
    def set_affinity(self, affinity): self.affinity = affinity
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssociationRule', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssociationRule')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssociationRule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssociationRule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssociationRule'):
        if self.antecedent is not None and 'antecedent' not in already_processed:
            already_processed.add('antecedent')
            outfile.write(' antecedent=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.antecedent), input_name='antecedent')), ))
        if self.consequent is not None and 'consequent' not in already_processed:
            already_processed.add('consequent')
            outfile.write(' consequent=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.consequent), input_name='consequent')), ))
        if self.support is not None and 'support' not in already_processed:
            already_processed.add('support')
            outfile.write(' support=%s' % (quote_attrib(self.support), ))
        if self.confidence is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            outfile.write(' confidence=%s' % (quote_attrib(self.confidence), ))
        if self.lift is not None and 'lift' not in already_processed:
            already_processed.add('lift')
            outfile.write(' lift="%s"' % self.gds_format_double(self.lift, input_name='lift'))
        if self.leverage is not None and 'leverage' not in already_processed:
            already_processed.add('leverage')
            outfile.write(' leverage="%s"' % self.gds_format_double(self.leverage, input_name='leverage'))
        if self.affinity is not None and 'affinity' not in already_processed:
            already_processed.add('affinity')
            outfile.write(' affinity=%s' % (quote_attrib(self.affinity), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AssociationRule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AssociationRule', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.antecedent is not None:
            element.set('antecedent', self.gds_format_string(self.antecedent))
        if self.consequent is not None:
            element.set('consequent', self.gds_format_string(self.consequent))
        if self.support is not None:
            element.set('support', self.support)
        if self.confidence is not None:
            element.set('confidence', self.confidence)
        if self.lift is not None:
            element.set('lift', self.gds_format_double(self.lift))
        if self.leverage is not None:
            element.set('leverage', self.gds_format_double(self.leverage))
        if self.affinity is not None:
            element.set('affinity', self.affinity)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='AssociationRule'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.antecedent is not None and 'antecedent' not in already_processed:
            already_processed.add('antecedent')
            showIndent(outfile, level)
            outfile.write('antecedent="%s",\n' % (self.antecedent,))
        if self.consequent is not None and 'consequent' not in already_processed:
            already_processed.add('consequent')
            showIndent(outfile, level)
            outfile.write('consequent="%s",\n' % (self.consequent,))
        if self.support is not None and 'support' not in already_processed:
            already_processed.add('support')
            showIndent(outfile, level)
            outfile.write('support=%e,\n' % (self.support,))
        if self.confidence is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            showIndent(outfile, level)
            outfile.write('confidence=%e,\n' % (self.confidence,))
        if self.lift is not None and 'lift' not in already_processed:
            already_processed.add('lift')
            showIndent(outfile, level)
            outfile.write('lift=%e,\n' % (self.lift,))
        if self.leverage is not None and 'leverage' not in already_processed:
            already_processed.add('leverage')
            showIndent(outfile, level)
            outfile.write('leverage=%e,\n' % (self.leverage,))
        if self.affinity is not None and 'affinity' not in already_processed:
            already_processed.add('affinity')
            showIndent(outfile, level)
            outfile.write('affinity=%e,\n' % (self.affinity,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('antecedent', node)
        if value is not None and 'antecedent' not in already_processed:
            already_processed.add('antecedent')
            self.antecedent = value
        value = find_attr_value_('consequent', node)
        if value is not None and 'consequent' not in already_processed:
            already_processed.add('consequent')
            self.consequent = value
        value = find_attr_value_('support', node)
        if value is not None and 'support' not in already_processed:
            already_processed.add('support')
            try:
                self.support = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (support): %s' % exp)
            self.validate_PROB_NUMBER(self.support)    # validate type PROB-NUMBER
        value = find_attr_value_('confidence', node)
        if value is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            try:
                self.confidence = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (confidence): %s' % exp)
            self.validate_PROB_NUMBER(self.confidence)    # validate type PROB-NUMBER
        value = find_attr_value_('lift', node)
        if value is not None and 'lift' not in already_processed:
            already_processed.add('lift')
            try:
                self.lift = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lift): %s' % exp)
        value = find_attr_value_('leverage', node)
        if value is not None and 'leverage' not in already_processed:
            already_processed.add('leverage')
            try:
                self.leverage = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (leverage): %s' % exp)
        value = find_attr_value_('affinity', node)
        if value is not None and 'affinity' not in already_processed:
            already_processed.add('affinity')
            try:
                self.affinity = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (affinity): %s' % exp)
            self.validate_PROB_NUMBER(self.affinity)    # validate type PROB-NUMBER
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class AssociationRule


class MiningSchema(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, MiningField=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if MiningField is None:
            self.MiningField = []
        else:
            self.MiningField = MiningField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MiningSchema)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MiningSchema.subclass:
            return MiningSchema.subclass(*args_, **kwargs_)
        else:
            return MiningSchema(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_MiningField(self): return self.MiningField
    def set_MiningField(self, MiningField): self.MiningField = MiningField
    def add_MiningField(self, value): self.MiningField.append(value)
    def insert_MiningField_at(self, index, value): self.MiningField.insert(index, value)
    def replace_MiningField_at(self, index, value): self.MiningField[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.MiningField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MiningSchema', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MiningSchema')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MiningSchema')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MiningSchema', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MiningSchema'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MiningSchema', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for MiningField_ in self.MiningField:
            MiningField_.export(outfile, level, namespace_, name_='MiningField', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MiningSchema', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for MiningField_ in self.MiningField:
            MiningField_.to_etree(element, name_='MiningField', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MiningSchema'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MiningField=[\n')
        level += 1
        for MiningField_ in self.MiningField:
            showIndent(outfile, level)
            outfile.write('model_.MiningField(\n')
            MiningField_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'MiningField':
            obj_ = MiningField.factory()
            obj_.build(child_)
            self.MiningField.append(obj_)
            obj_.original_tagname_ = 'MiningField'
# end class MiningSchema


class MiningField(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, usageType='active', optype=None, importance=None, outliers='asIs', lowValue=None, highValue=None, missingValueReplacement=None, missingValueTreatment=None, invalidValueTreatment='returnInvalid', invalidValueReplacement=None, Extension=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.usageType = _cast(None, usageType)
        self.optype = _cast(None, optype)
        self.importance = _cast(None, importance)
        self.outliers = _cast(None, outliers)
        self.lowValue = _cast(None, lowValue)
        self.highValue = _cast(None, highValue)
        self.missingValueReplacement = _cast(None, missingValueReplacement)
        self.missingValueTreatment = _cast(None, missingValueTreatment)
        self.invalidValueTreatment = _cast(None, invalidValueTreatment)
        self.invalidValueReplacement = _cast(None, invalidValueReplacement)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MiningField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MiningField.subclass:
            return MiningField.subclass(*args_, **kwargs_)
        else:
            return MiningField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_usageType(self): return self.usageType
    def set_usageType(self, usageType): self.usageType = usageType
    def get_optype(self): return self.optype
    def set_optype(self, optype): self.optype = optype
    def get_importance(self): return self.importance
    def set_importance(self, importance): self.importance = importance
    def get_outliers(self): return self.outliers
    def set_outliers(self, outliers): self.outliers = outliers
    def get_lowValue(self): return self.lowValue
    def set_lowValue(self, lowValue): self.lowValue = lowValue
    def get_highValue(self): return self.highValue
    def set_highValue(self, highValue): self.highValue = highValue
    def get_missingValueReplacement(self): return self.missingValueReplacement
    def set_missingValueReplacement(self, missingValueReplacement): self.missingValueReplacement = missingValueReplacement
    def get_missingValueTreatment(self): return self.missingValueTreatment
    def set_missingValueTreatment(self, missingValueTreatment): self.missingValueTreatment = missingValueTreatment
    def get_invalidValueTreatment(self): return self.invalidValueTreatment
    def set_invalidValueTreatment(self, invalidValueTreatment): self.invalidValueTreatment = invalidValueTreatment
    def get_invalidValueReplacement(self): return self.invalidValueReplacement
    def set_invalidValueReplacement(self, invalidValueReplacement): self.invalidValueReplacement = invalidValueReplacement
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_FIELD_USAGE_TYPE(self, value):
        # Validate type FIELD-USAGE-TYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['active', 'predicted', 'target', 'supplementary', 'group', 'order', 'frequencyWeight', 'analysisWeight']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FIELD-USAGE-TYPE' % {"value" : value.encode("utf-8")} )
    def validate_OPTYPE(self, value):
        # Validate type OPTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['categorical', 'ordinal', 'continuous']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OPTYPE' % {"value" : value.encode("utf-8")} )
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_OUTLIER_TREATMENT_METHOD(self, value):
        # Validate type OUTLIER-TREATMENT-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['asIs', 'asMissingValues', 'asExtremeValues']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OUTLIER-TREATMENT-METHOD' % {"value" : value.encode("utf-8")} )
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_MISSING_VALUE_TREATMENT_METHOD(self, value):
        # Validate type MISSING-VALUE-TREATMENT-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['asIs', 'asMean', 'asMode', 'asMedian', 'asValue', 'returnInvalid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MISSING-VALUE-TREATMENT-METHOD' % {"value" : value.encode("utf-8")} )
    def validate_INVALID_VALUE_TREATMENT_METHOD(self, value):
        # Validate type INVALID-VALUE-TREATMENT-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['returnInvalid', 'asIs', 'asMissing', 'asValue']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on INVALID-VALUE-TREATMENT-METHOD' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MiningField', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MiningField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MiningField')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MiningField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MiningField'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.usageType != "active" and 'usageType' not in already_processed:
            already_processed.add('usageType')
            outfile.write(' usageType=%s' % (quote_attrib(self.usageType), ))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            outfile.write(' optype=%s' % (quote_attrib(self.optype), ))
        if self.importance is not None and 'importance' not in already_processed:
            already_processed.add('importance')
            outfile.write(' importance=%s' % (quote_attrib(self.importance), ))
        if self.outliers != "asIs" and 'outliers' not in already_processed:
            already_processed.add('outliers')
            outfile.write(' outliers=%s' % (quote_attrib(self.outliers), ))
        if self.lowValue is not None and 'lowValue' not in already_processed:
            already_processed.add('lowValue')
            outfile.write(' lowValue=%s' % (quote_attrib(self.lowValue), ))
        if self.highValue is not None and 'highValue' not in already_processed:
            already_processed.add('highValue')
            outfile.write(' highValue=%s' % (quote_attrib(self.highValue), ))
        if self.missingValueReplacement is not None and 'missingValueReplacement' not in already_processed:
            already_processed.add('missingValueReplacement')
            outfile.write(' missingValueReplacement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.missingValueReplacement), input_name='missingValueReplacement')), ))
        if self.missingValueTreatment is not None and 'missingValueTreatment' not in already_processed:
            already_processed.add('missingValueTreatment')
            outfile.write(' missingValueTreatment=%s' % (quote_attrib(self.missingValueTreatment), ))
        if self.invalidValueTreatment != "returnInvalid" and 'invalidValueTreatment' not in already_processed:
            already_processed.add('invalidValueTreatment')
            outfile.write(' invalidValueTreatment=%s' % (quote_attrib(self.invalidValueTreatment), ))
        if self.invalidValueReplacement is not None and 'invalidValueReplacement' not in already_processed:
            already_processed.add('invalidValueReplacement')
            outfile.write(' invalidValueReplacement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.invalidValueReplacement), input_name='invalidValueReplacement')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MiningField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MiningField', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.name)
        if self.usageType is not None:
            element.set('usageType', self.usageType)
        if self.optype is not None:
            element.set('optype', self.optype)
        if self.importance is not None:
            element.set('importance', self.importance)
        if self.outliers is not None:
            element.set('outliers', self.outliers)
        if self.lowValue is not None:
            element.set('lowValue', self.lowValue)
        if self.highValue is not None:
            element.set('highValue', self.highValue)
        if self.missingValueReplacement is not None:
            element.set('missingValueReplacement', self.gds_format_string(self.missingValueReplacement))
        if self.missingValueTreatment is not None:
            element.set('missingValueTreatment', self.missingValueTreatment)
        if self.invalidValueTreatment is not None:
            element.set('invalidValueTreatment', self.invalidValueTreatment)
        if self.invalidValueReplacement is not None:
            element.set('invalidValueReplacement', self.gds_format_string(self.invalidValueReplacement))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MiningField'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.usageType is not None and 'usageType' not in already_processed:
            already_processed.add('usageType')
            showIndent(outfile, level)
            outfile.write('usageType="%s",\n' % (self.usageType,))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            showIndent(outfile, level)
            outfile.write('optype="%s",\n' % (self.optype,))
        if self.importance is not None and 'importance' not in already_processed:
            already_processed.add('importance')
            showIndent(outfile, level)
            outfile.write('importance=%e,\n' % (self.importance,))
        if self.outliers is not None and 'outliers' not in already_processed:
            already_processed.add('outliers')
            showIndent(outfile, level)
            outfile.write('outliers="%s",\n' % (self.outliers,))
        if self.lowValue is not None and 'lowValue' not in already_processed:
            already_processed.add('lowValue')
            showIndent(outfile, level)
            outfile.write('lowValue=%e,\n' % (self.lowValue,))
        if self.highValue is not None and 'highValue' not in already_processed:
            already_processed.add('highValue')
            showIndent(outfile, level)
            outfile.write('highValue=%e,\n' % (self.highValue,))
        if self.missingValueReplacement is not None and 'missingValueReplacement' not in already_processed:
            already_processed.add('missingValueReplacement')
            showIndent(outfile, level)
            outfile.write('missingValueReplacement="%s",\n' % (self.missingValueReplacement,))
        if self.missingValueTreatment is not None and 'missingValueTreatment' not in already_processed:
            already_processed.add('missingValueTreatment')
            showIndent(outfile, level)
            outfile.write('missingValueTreatment="%s",\n' % (self.missingValueTreatment,))
        if self.invalidValueTreatment is not None and 'invalidValueTreatment' not in already_processed:
            already_processed.add('invalidValueTreatment')
            showIndent(outfile, level)
            outfile.write('invalidValueTreatment="%s",\n' % (self.invalidValueTreatment,))
        if self.invalidValueReplacement is not None and 'invalidValueReplacement' not in already_processed:
            already_processed.add('invalidValueReplacement')
            showIndent(outfile, level)
            outfile.write('invalidValueReplacement="%s",\n' % (self.invalidValueReplacement,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('usageType', node)
        if value is not None and 'usageType' not in already_processed:
            already_processed.add('usageType')
            self.usageType = value
            self.validate_FIELD_USAGE_TYPE(self.usageType)    # validate type FIELD-USAGE-TYPE
        value = find_attr_value_('optype', node)
        if value is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            self.optype = value
            self.validate_OPTYPE(self.optype)    # validate type OPTYPE
        value = find_attr_value_('importance', node)
        if value is not None and 'importance' not in already_processed:
            already_processed.add('importance')
            try:
                self.importance = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (importance): %s' % exp)
            self.validate_PROB_NUMBER(self.importance)    # validate type PROB-NUMBER
        value = find_attr_value_('outliers', node)
        if value is not None and 'outliers' not in already_processed:
            already_processed.add('outliers')
            self.outliers = value
            self.validate_OUTLIER_TREATMENT_METHOD(self.outliers)    # validate type OUTLIER-TREATMENT-METHOD
        value = find_attr_value_('lowValue', node)
        if value is not None and 'lowValue' not in already_processed:
            already_processed.add('lowValue')
            try:
                self.lowValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lowValue): %s' % exp)
            self.validate_NUMBER(self.lowValue)    # validate type NUMBER
        value = find_attr_value_('highValue', node)
        if value is not None and 'highValue' not in already_processed:
            already_processed.add('highValue')
            try:
                self.highValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (highValue): %s' % exp)
            self.validate_NUMBER(self.highValue)    # validate type NUMBER
        value = find_attr_value_('missingValueReplacement', node)
        if value is not None and 'missingValueReplacement' not in already_processed:
            already_processed.add('missingValueReplacement')
            self.missingValueReplacement = value
        value = find_attr_value_('missingValueTreatment', node)
        if value is not None and 'missingValueTreatment' not in already_processed:
            already_processed.add('missingValueTreatment')
            self.missingValueTreatment = value
            self.validate_MISSING_VALUE_TREATMENT_METHOD(self.missingValueTreatment)    # validate type MISSING-VALUE-TREATMENT-METHOD
        value = find_attr_value_('invalidValueTreatment', node)
        if value is not None and 'invalidValueTreatment' not in already_processed:
            already_processed.add('invalidValueTreatment')
            self.invalidValueTreatment = value
            self.validate_INVALID_VALUE_TREATMENT_METHOD(self.invalidValueTreatment)    # validate type INVALID-VALUE-TREATMENT-METHOD
        value = find_attr_value_('invalidValueReplacement', node)
        if value is not None and 'invalidValueReplacement' not in already_processed:
            already_processed.add('invalidValueReplacement')
            self.invalidValueReplacement = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class MiningField


class Output(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, OutputField=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if OutputField is None:
            self.OutputField = []
        else:
            self.OutputField = OutputField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Output)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Output.subclass:
            return Output.subclass(*args_, **kwargs_)
        else:
            return Output(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_OutputField(self): return self.OutputField
    def set_OutputField(self, OutputField): self.OutputField = OutputField
    def add_OutputField(self, value): self.OutputField.append(value)
    def insert_OutputField_at(self, index, value): self.OutputField.insert(index, value)
    def replace_OutputField_at(self, index, value): self.OutputField[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.OutputField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Output', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Output')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Output')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Output', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Output'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Output', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for OutputField_ in self.OutputField:
            OutputField_.export(outfile, level, namespace_, name_='OutputField', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Output', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for OutputField_ in self.OutputField:
            OutputField_.to_etree(element, name_='OutputField', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Output'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OutputField=[\n')
        level += 1
        for OutputField_ in self.OutputField:
            showIndent(outfile, level)
            outfile.write('model_.OutputField(\n')
            OutputField_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'OutputField':
            obj_ = OutputField.factory()
            obj_.build(child_)
            self.OutputField.append(obj_)
            obj_.original_tagname_ = 'OutputField'
# end class Output


class OutputField(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, optype=None, dataType=None, targetField=None, feature='predictedValue', value=None, ruleFeature='consequent', algorithm='exclusiveRecommendation', rank='1', rankBasis='confidence', rankOrder='descending', isMultiValued='0', segmentId=None, isFinalResult=True, Extension=None, Decisions=None, FieldRef=None, Apply=None, Constant=None, NormContinuous=None, NormDiscrete=None, Discretize=None, MapValues=None, TextIndex=None, Aggregate=None, Lag=None, Value=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.displayName = _cast(None, displayName)
        self.optype = _cast(None, optype)
        self.dataType = _cast(None, dataType)
        self.targetField = _cast(None, targetField)
        self.feature = _cast(None, feature)
        self.value = _cast(None, value)
        self.ruleFeature = _cast(None, ruleFeature)
        self.algorithm = _cast(None, algorithm)
        self.rank = _cast(None, rank)
        self.rankBasis = _cast(None, rankBasis)
        self.rankOrder = _cast(None, rankOrder)
        self.isMultiValued = _cast(None, isMultiValued)
        self.segmentId = _cast(None, segmentId)
        self.isFinalResult = _cast(bool, isFinalResult)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Decisions = Decisions
        self.FieldRef = FieldRef
        self.Apply = Apply
        self.Constant = Constant
        self.NormContinuous = NormContinuous
        self.NormDiscrete = NormDiscrete
        self.Discretize = Discretize
        self.MapValues = MapValues
        self.TextIndex = TextIndex
        self.Aggregate = Aggregate
        self.Lag = Lag
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutputField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutputField.subclass:
            return OutputField.subclass(*args_, **kwargs_)
        else:
            return OutputField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Decisions(self): return self.Decisions
    def set_Decisions(self, Decisions): self.Decisions = Decisions
    def get_FieldRef(self): return self.FieldRef
    def set_FieldRef(self, FieldRef): self.FieldRef = FieldRef
    def get_Apply(self): return self.Apply
    def set_Apply(self, Apply): self.Apply = Apply
    def get_Constant(self): return self.Constant
    def set_Constant(self, Constant): self.Constant = Constant
    def get_NormContinuous(self): return self.NormContinuous
    def set_NormContinuous(self, NormContinuous): self.NormContinuous = NormContinuous
    def get_NormDiscrete(self): return self.NormDiscrete
    def set_NormDiscrete(self, NormDiscrete): self.NormDiscrete = NormDiscrete
    def get_Discretize(self): return self.Discretize
    def set_Discretize(self, Discretize): self.Discretize = Discretize
    def get_MapValues(self): return self.MapValues
    def set_MapValues(self, MapValues): self.MapValues = MapValues
    def get_TextIndex(self): return self.TextIndex
    def set_TextIndex(self, TextIndex): self.TextIndex = TextIndex
    def get_Aggregate(self): return self.Aggregate
    def set_Aggregate(self, Aggregate): self.Aggregate = Aggregate
    def get_Lag(self): return self.Lag
    def set_Lag(self, Lag): self.Lag = Lag
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value_at(self, index, value): self.Value.insert(index, value)
    def replace_Value_at(self, index, value): self.Value[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_optype(self): return self.optype
    def set_optype(self, optype): self.optype = optype
    def get_dataType(self): return self.dataType
    def set_dataType(self, dataType): self.dataType = dataType
    def get_targetField(self): return self.targetField
    def set_targetField(self, targetField): self.targetField = targetField
    def get_feature(self): return self.feature
    def set_feature(self, feature): self.feature = feature
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_ruleFeature(self): return self.ruleFeature
    def set_ruleFeature(self, ruleFeature): self.ruleFeature = ruleFeature
    def get_algorithm(self): return self.algorithm
    def set_algorithm(self, algorithm): self.algorithm = algorithm
    def get_rank(self): return self.rank
    def set_rank(self, rank): self.rank = rank
    def get_rankBasis(self): return self.rankBasis
    def set_rankBasis(self, rankBasis): self.rankBasis = rankBasis
    def get_rankOrder(self): return self.rankOrder
    def set_rankOrder(self, rankOrder): self.rankOrder = rankOrder
    def get_isMultiValued(self): return self.isMultiValued
    def set_isMultiValued(self, isMultiValued): self.isMultiValued = isMultiValued
    def get_segmentId(self): return self.segmentId
    def set_segmentId(self, segmentId): self.segmentId = segmentId
    def get_isFinalResult(self): return self.isFinalResult
    def set_isFinalResult(self, isFinalResult): self.isFinalResult = isFinalResult
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_OPTYPE(self, value):
        # Validate type OPTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['categorical', 'ordinal', 'continuous']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OPTYPE' % {"value" : value.encode("utf-8")} )
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DATATYPE' % {"value" : value.encode("utf-8")} )
    def validate_RESULT_FEATURE(self, value):
        # Validate type RESULT-FEATURE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['predictedValue', 'predictedDisplayValue', 'transformedValue', 'decision', 'probability', 'affinity', 'residual', 'standardError', 'standardDeviation', 'clusterId', 'clusterAffinity', 'entityId', 'entityAffinity', 'warning', 'ruleValue', 'reasonCode', 'antecedent', 'consequent', 'rule', 'ruleId', 'confidence', 'support', 'lift', 'leverage', 'confidenceIntervalLower', 'confidenceIntervalUpper']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RESULT-FEATURE' % {"value" : value.encode("utf-8")} )
    def validate_RULE_FEATURE(self, value):
        # Validate type RULE-FEATURE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['antecedent', 'consequent', 'rule', 'ruleId', 'confidence', 'support', 'lift', 'leverage', 'affinity']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RULE-FEATURE' % {"value" : value.encode("utf-8")} )
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Decisions is not None or
            self.FieldRef is not None or
            self.Apply is not None or
            self.Constant is not None or
            self.NormContinuous is not None or
            self.NormDiscrete is not None or
            self.Discretize is not None or
            self.MapValues is not None or
            self.TextIndex is not None or
            self.Aggregate is not None or
            self.Lag is not None or
            self.Value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OutputField', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OutputField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OutputField')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OutputField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OutputField'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            outfile.write(' optype=%s' % (quote_attrib(self.optype), ))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (quote_attrib(self.dataType), ))
        if self.targetField is not None and 'targetField' not in already_processed:
            already_processed.add('targetField')
            outfile.write(' targetField=%s' % (quote_attrib(self.targetField), ))
        if self.feature != "predictedValue" and 'feature' not in already_processed:
            already_processed.add('feature')
            outfile.write(' feature=%s' % (quote_attrib(self.feature), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.ruleFeature != "consequent" and 'ruleFeature' not in already_processed:
            already_processed.add('ruleFeature')
            outfile.write(' ruleFeature=%s' % (quote_attrib(self.ruleFeature), ))
        if self.algorithm != "exclusiveRecommendation" and 'algorithm' not in already_processed:
            already_processed.add('algorithm')
            outfile.write(' algorithm=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithm), input_name='algorithm')), ))
        if self.rank != 1 and 'rank' not in already_processed:
            already_processed.add('rank')
            outfile.write(' rank=%s' % (quote_attrib(self.rank), ))
        if self.rankBasis != "confidence" and 'rankBasis' not in already_processed:
            already_processed.add('rankBasis')
            outfile.write(' rankBasis=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rankBasis), input_name='rankBasis')), ))
        if self.rankOrder != "descending" and 'rankOrder' not in already_processed:
            already_processed.add('rankOrder')
            outfile.write(' rankOrder=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rankOrder), input_name='rankOrder')), ))
        if self.isMultiValued != "0" and 'isMultiValued' not in already_processed:
            already_processed.add('isMultiValued')
            outfile.write(' isMultiValued=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.isMultiValued), input_name='isMultiValued')), ))
        if self.segmentId is not None and 'segmentId' not in already_processed:
            already_processed.add('segmentId')
            outfile.write(' segmentId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segmentId), input_name='segmentId')), ))
        if not self.isFinalResult and 'isFinalResult' not in already_processed:
            already_processed.add('isFinalResult')
            outfile.write(' isFinalResult="%s"' % self.gds_format_boolean(self.isFinalResult, input_name='isFinalResult'))
    def exportChildren(self, outfile, level, namespace_='', name_='OutputField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Decisions is not None:
            self.Decisions.export(outfile, level, namespace_, name_='Decisions', pretty_print=pretty_print)
        if self.FieldRef is not None:
            self.FieldRef.export(outfile, level, namespace_, name_='FieldRef', pretty_print=pretty_print)
        if self.Apply is not None:
            self.Apply.export(outfile, level, namespace_, name_='Apply', pretty_print=pretty_print)
        if self.Constant is not None:
            self.Constant.export(outfile, level, namespace_, name_='Constant', pretty_print=pretty_print)
        if self.NormContinuous is not None:
            self.NormContinuous.export(outfile, level, namespace_, name_='NormContinuous', pretty_print=pretty_print)
        if self.NormDiscrete is not None:
            self.NormDiscrete.export(outfile, level, namespace_, name_='NormDiscrete', pretty_print=pretty_print)
        if self.Discretize is not None:
            self.Discretize.export(outfile, level, namespace_, name_='Discretize', pretty_print=pretty_print)
        if self.MapValues is not None:
            self.MapValues.export(outfile, level, namespace_, name_='MapValues', pretty_print=pretty_print)
        if self.TextIndex is not None:
            self.TextIndex.export(outfile, level, namespace_, name_='TextIndex', pretty_print=pretty_print)
        if self.Aggregate is not None:
            self.Aggregate.export(outfile, level, namespace_, name_='Aggregate', pretty_print=pretty_print)
        if self.Lag is not None:
            self.Lag.export(outfile, level, namespace_, name_='Lag', pretty_print=pretty_print)
        for Value_ in self.Value:
            Value_.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='OutputField', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.name)
        if self.displayName is not None:
            element.set('displayName', self.gds_format_string(self.displayName))
        if self.optype is not None:
            element.set('optype', self.optype)
        if self.dataType is not None:
            element.set('dataType', self.dataType)
        if self.targetField is not None:
            element.set('targetField', self.targetField)
        if self.feature is not None:
            element.set('feature', self.feature)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.ruleFeature is not None:
            element.set('ruleFeature', self.ruleFeature)
        if self.algorithm is not None:
            element.set('algorithm', self.gds_format_string(self.algorithm))
        if self.rank is not None:
            element.set('rank', self.rank)
        if self.rankBasis is not None:
            element.set('rankBasis', self.gds_format_string(self.rankBasis))
        if self.rankOrder is not None:
            element.set('rankOrder', self.gds_format_string(self.rankOrder))
        if self.isMultiValued is not None:
            element.set('isMultiValued', self.gds_format_string(self.isMultiValued))
        if self.segmentId is not None:
            element.set('segmentId', self.gds_format_string(self.segmentId))
        if self.isFinalResult is not None:
            element.set('isFinalResult', self.gds_format_boolean(self.isFinalResult))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Decisions is not None:
            Decisions_ = self.Decisions
            Decisions_.to_etree(element, name_='Decisions', mapping_=mapping_)
        if self.FieldRef is not None:
            FieldRef_ = self.FieldRef
            FieldRef_.to_etree(element, name_='FieldRef', mapping_=mapping_)
        if self.Apply is not None:
            Apply_ = self.Apply
            Apply_.to_etree(element, name_='Apply', mapping_=mapping_)
        if self.Constant is not None:
            Constant_ = self.Constant
            Constant_.to_etree(element, name_='Constant', mapping_=mapping_)
        if self.NormContinuous is not None:
            NormContinuous_ = self.NormContinuous
            NormContinuous_.to_etree(element, name_='NormContinuous', mapping_=mapping_)
        if self.NormDiscrete is not None:
            NormDiscrete_ = self.NormDiscrete
            NormDiscrete_.to_etree(element, name_='NormDiscrete', mapping_=mapping_)
        if self.Discretize is not None:
            Discretize_ = self.Discretize
            Discretize_.to_etree(element, name_='Discretize', mapping_=mapping_)
        if self.MapValues is not None:
            MapValues_ = self.MapValues
            MapValues_.to_etree(element, name_='MapValues', mapping_=mapping_)
        if self.TextIndex is not None:
            TextIndex_ = self.TextIndex
            TextIndex_.to_etree(element, name_='TextIndex', mapping_=mapping_)
        if self.Aggregate is not None:
            Aggregate_ = self.Aggregate
            Aggregate_.to_etree(element, name_='Aggregate', mapping_=mapping_)
        if self.Lag is not None:
            Lag_ = self.Lag
            Lag_.to_etree(element, name_='Lag', mapping_=mapping_)
        for Value_ in self.Value:
            Value_.to_etree(element, name_='Value', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='OutputField'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            showIndent(outfile, level)
            outfile.write('displayName="%s",\n' % (self.displayName,))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            showIndent(outfile, level)
            outfile.write('optype="%s",\n' % (self.optype,))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            showIndent(outfile, level)
            outfile.write('dataType="%s",\n' % (self.dataType,))
        if self.targetField is not None and 'targetField' not in already_processed:
            already_processed.add('targetField')
            showIndent(outfile, level)
            outfile.write('targetField="%s",\n' % (self.targetField,))
        if self.feature is not None and 'feature' not in already_processed:
            already_processed.add('feature')
            showIndent(outfile, level)
            outfile.write('feature="%s",\n' % (self.feature,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.ruleFeature is not None and 'ruleFeature' not in already_processed:
            already_processed.add('ruleFeature')
            showIndent(outfile, level)
            outfile.write('ruleFeature="%s",\n' % (self.ruleFeature,))
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.add('algorithm')
            showIndent(outfile, level)
            outfile.write('algorithm="%s",\n' % (self.algorithm,))
        if self.rank is not None and 'rank' not in already_processed:
            already_processed.add('rank')
            showIndent(outfile, level)
            outfile.write('rank=%d,\n' % (self.rank,))
        if self.rankBasis is not None and 'rankBasis' not in already_processed:
            already_processed.add('rankBasis')
            showIndent(outfile, level)
            outfile.write('rankBasis="%s",\n' % (self.rankBasis,))
        if self.rankOrder is not None and 'rankOrder' not in already_processed:
            already_processed.add('rankOrder')
            showIndent(outfile, level)
            outfile.write('rankOrder="%s",\n' % (self.rankOrder,))
        if self.isMultiValued is not None and 'isMultiValued' not in already_processed:
            already_processed.add('isMultiValued')
            showIndent(outfile, level)
            outfile.write('isMultiValued="%s",\n' % (self.isMultiValued,))
        if self.segmentId is not None and 'segmentId' not in already_processed:
            already_processed.add('segmentId')
            showIndent(outfile, level)
            outfile.write('segmentId="%s",\n' % (self.segmentId,))
        if self.isFinalResult is not None and 'isFinalResult' not in already_processed:
            already_processed.add('isFinalResult')
            showIndent(outfile, level)
            outfile.write('isFinalResult=%s,\n' % (self.isFinalResult,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Decisions is not None:
            showIndent(outfile, level)
            outfile.write('Decisions=model_.Decisions(\n')
            self.Decisions.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FieldRef is not None:
            showIndent(outfile, level)
            outfile.write('FieldRef=model_.FieldRef(\n')
            self.FieldRef.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Apply is not None:
            showIndent(outfile, level)
            outfile.write('Apply=model_.Apply(\n')
            self.Apply.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Constant is not None:
            showIndent(outfile, level)
            outfile.write('Constant=model_.Constant(\n')
            self.Constant.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormContinuous is not None:
            showIndent(outfile, level)
            outfile.write('NormContinuous=model_.NormContinuous(\n')
            self.NormContinuous.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormDiscrete is not None:
            showIndent(outfile, level)
            outfile.write('NormDiscrete=model_.NormDiscrete(\n')
            self.NormDiscrete.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Discretize is not None:
            showIndent(outfile, level)
            outfile.write('Discretize=model_.Discretize(\n')
            self.Discretize.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MapValues is not None:
            showIndent(outfile, level)
            outfile.write('MapValues=model_.MapValues(\n')
            self.MapValues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextIndex is not None:
            showIndent(outfile, level)
            outfile.write('TextIndex=model_.TextIndex(\n')
            self.TextIndex.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Aggregate is not None:
            showIndent(outfile, level)
            outfile.write('Aggregate=model_.Aggregate(\n')
            self.Aggregate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Lag is not None:
            showIndent(outfile, level)
            outfile.write('Lag=model_.Lag(\n')
            self.Lag.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('model_.Value(\n')
            Value_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
        value = find_attr_value_('optype', node)
        if value is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            self.optype = value
            self.validate_OPTYPE(self.optype)    # validate type OPTYPE
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
        value = find_attr_value_('targetField', node)
        if value is not None and 'targetField' not in already_processed:
            already_processed.add('targetField')
            self.targetField = value
            self.validate_FIELD_NAME(self.targetField)    # validate type FIELD-NAME
        value = find_attr_value_('feature', node)
        if value is not None and 'feature' not in already_processed:
            already_processed.add('feature')
            self.feature = value
            self.validate_RESULT_FEATURE(self.feature)    # validate type RESULT-FEATURE
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('ruleFeature', node)
        if value is not None and 'ruleFeature' not in already_processed:
            already_processed.add('ruleFeature')
            self.ruleFeature = value
            self.validate_RULE_FEATURE(self.ruleFeature)    # validate type RULE-FEATURE
        value = find_attr_value_('algorithm', node)
        if value is not None and 'algorithm' not in already_processed:
            already_processed.add('algorithm')
            self.algorithm = value
        value = find_attr_value_('rank', node)
        if value is not None and 'rank' not in already_processed:
            already_processed.add('rank')
            try:
                self.rank = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.rank)    # validate type INT-NUMBER
        value = find_attr_value_('rankBasis', node)
        if value is not None and 'rankBasis' not in already_processed:
            already_processed.add('rankBasis')
            self.rankBasis = value
        value = find_attr_value_('rankOrder', node)
        if value is not None and 'rankOrder' not in already_processed:
            already_processed.add('rankOrder')
            self.rankOrder = value
        value = find_attr_value_('isMultiValued', node)
        if value is not None and 'isMultiValued' not in already_processed:
            already_processed.add('isMultiValued')
            self.isMultiValued = value
        value = find_attr_value_('segmentId', node)
        if value is not None and 'segmentId' not in already_processed:
            already_processed.add('segmentId')
            self.segmentId = value
        value = find_attr_value_('isFinalResult', node)
        if value is not None and 'isFinalResult' not in already_processed:
            already_processed.add('isFinalResult')
            if value in ('true', '1'):
                self.isFinalResult = True
            elif value in ('false', '0'):
                self.isFinalResult = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Decisions':
            obj_ = Decisions.factory()
            obj_.build(child_)
            self.Decisions = obj_
            obj_.original_tagname_ = 'Decisions'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory()
            obj_.build(child_)
            self.FieldRef = obj_
            obj_.original_tagname_ = 'FieldRef'
        elif nodeName_ == 'Apply':
            obj_ = Apply.factory()
            obj_.build(child_)
            self.Apply = obj_
            obj_.original_tagname_ = 'Apply'
        elif nodeName_ == 'Constant':
            obj_ = Constant.factory()
            obj_.build(child_)
            self.Constant = obj_
            obj_.original_tagname_ = 'Constant'
        elif nodeName_ == 'NormContinuous':
            obj_ = NormContinuous.factory()
            obj_.build(child_)
            self.NormContinuous = obj_
            obj_.original_tagname_ = 'NormContinuous'
        elif nodeName_ == 'NormDiscrete':
            obj_ = NormDiscrete.factory()
            obj_.build(child_)
            self.NormDiscrete = obj_
            obj_.original_tagname_ = 'NormDiscrete'
        elif nodeName_ == 'Discretize':
            obj_ = Discretize.factory()
            obj_.build(child_)
            self.Discretize = obj_
            obj_.original_tagname_ = 'Discretize'
        elif nodeName_ == 'MapValues':
            obj_ = MapValues.factory()
            obj_.build(child_)
            self.MapValues = obj_
            obj_.original_tagname_ = 'MapValues'
        elif nodeName_ == 'TextIndex':
            obj_ = TextIndex.factory()
            obj_.build(child_)
            self.TextIndex = obj_
            obj_.original_tagname_ = 'TextIndex'
        elif nodeName_ == 'Aggregate':
            obj_ = Aggregate.factory()
            obj_.build(child_)
            self.Aggregate = obj_
            obj_.original_tagname_ = 'Aggregate'
        elif nodeName_ == 'Lag':
            obj_ = Lag.factory()
            obj_.build(child_)
            self.Lag = obj_
            obj_.original_tagname_ = 'Lag'
        elif nodeName_ == 'Value':
            obj_ = Value.factory()
            obj_.build(child_)
            self.Value.append(obj_)
            obj_.original_tagname_ = 'Value'
# end class OutputField


class Decisions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, businessProblem=None, description=None, Extension=None, Decision=None):
        self.original_tagname_ = None
        self.businessProblem = _cast(None, businessProblem)
        self.description = _cast(None, description)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Decision is None:
            self.Decision = []
        else:
            self.Decision = Decision
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Decisions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Decisions.subclass:
            return Decisions.subclass(*args_, **kwargs_)
        else:
            return Decisions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Decision(self): return self.Decision
    def set_Decision(self, Decision): self.Decision = Decision
    def add_Decision(self, value): self.Decision.append(value)
    def insert_Decision_at(self, index, value): self.Decision.insert(index, value)
    def replace_Decision_at(self, index, value): self.Decision[index] = value
    def get_businessProblem(self): return self.businessProblem
    def set_businessProblem(self, businessProblem): self.businessProblem = businessProblem
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def hasContent_(self):
        if (
            self.Extension or
            self.Decision
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Decisions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Decisions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Decisions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Decisions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Decisions'):
        if self.businessProblem is not None and 'businessProblem' not in already_processed:
            already_processed.add('businessProblem')
            outfile.write(' businessProblem=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.businessProblem), input_name='businessProblem')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Decisions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Decision_ in self.Decision:
            Decision_.export(outfile, level, namespace_, name_='Decision', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Decisions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.businessProblem is not None:
            element.set('businessProblem', self.gds_format_string(self.businessProblem))
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Decision_ in self.Decision:
            Decision_.to_etree(element, name_='Decision', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Decisions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.businessProblem is not None and 'businessProblem' not in already_processed:
            already_processed.add('businessProblem')
            showIndent(outfile, level)
            outfile.write('businessProblem="%s",\n' % (self.businessProblem,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            showIndent(outfile, level)
            outfile.write('description="%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Decision=[\n')
        level += 1
        for Decision_ in self.Decision:
            showIndent(outfile, level)
            outfile.write('model_.Decision(\n')
            Decision_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('businessProblem', node)
        if value is not None and 'businessProblem' not in already_processed:
            already_processed.add('businessProblem')
            self.businessProblem = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Decision':
            obj_ = Decision.factory()
            obj_.build(child_)
            self.Decision.append(obj_)
            obj_.original_tagname_ = 'Decision'
# end class Decisions


class Decision(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, displayValue=None, description=None, Extension=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.displayValue = _cast(None, displayValue)
        self.description = _cast(None, description)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Decision)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Decision.subclass:
            return Decision.subclass(*args_, **kwargs_)
        else:
            return Decision(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_displayValue(self): return self.displayValue
    def set_displayValue(self, displayValue): self.displayValue = displayValue
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Decision', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Decision')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Decision')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Decision', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Decision'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.displayValue is not None and 'displayValue' not in already_processed:
            already_processed.add('displayValue')
            outfile.write(' displayValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayValue), input_name='displayValue')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Decision', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Decision', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.displayValue is not None:
            element.set('displayValue', self.gds_format_string(self.displayValue))
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Decision'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.displayValue is not None and 'displayValue' not in already_processed:
            already_processed.add('displayValue')
            showIndent(outfile, level)
            outfile.write('displayValue="%s",\n' % (self.displayValue,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            showIndent(outfile, level)
            outfile.write('description="%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('displayValue', node)
        if value is not None and 'displayValue' not in already_processed:
            already_processed.add('displayValue')
            self.displayValue = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Decision


class TreeModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, missingValueStrategy='none', missingValuePenalty='1.0', noTrueChildStrategy='returnNullPrediction', splitCharacteristic='multiSplit', isScorable=True, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, Node=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.missingValueStrategy = _cast(None, missingValueStrategy)
        self.missingValuePenalty = _cast(None, missingValuePenalty)
        self.noTrueChildStrategy = _cast(None, noTrueChildStrategy)
        self.splitCharacteristic = _cast(None, splitCharacteristic)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.ModelExplanation = ModelExplanation
        self.Targets = Targets
        self.LocalTransformations = LocalTransformations
        self.Node = Node
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TreeModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TreeModel.subclass:
            return TreeModel.subclass(*args_, **kwargs_)
        else:
            return TreeModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_ModelExplanation(self): return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation): self.ModelExplanation = ModelExplanation
    def get_Targets(self): return self.Targets
    def set_Targets(self, Targets): self.Targets = Targets
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_Node(self): return self.Node
    def set_Node(self, Node): self.Node = Node
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_missingValueStrategy(self): return self.missingValueStrategy
    def set_missingValueStrategy(self, missingValueStrategy): self.missingValueStrategy = missingValueStrategy
    def get_missingValuePenalty(self): return self.missingValuePenalty
    def set_missingValuePenalty(self, missingValuePenalty): self.missingValuePenalty = missingValuePenalty
    def get_noTrueChildStrategy(self): return self.noTrueChildStrategy
    def set_noTrueChildStrategy(self, noTrueChildStrategy): self.noTrueChildStrategy = noTrueChildStrategy
    def get_splitCharacteristic(self): return self.splitCharacteristic
    def set_splitCharacteristic(self, splitCharacteristic): self.splitCharacteristic = splitCharacteristic
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_MISSING_VALUE_STRATEGY(self, value):
        # Validate type MISSING-VALUE-STRATEGY, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['lastPrediction', 'nullPrediction', 'defaultChild', 'weightedConfidence', 'aggregateNodes', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MISSING-VALUE-STRATEGY' % {"value" : value.encode("utf-8")} )
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_NO_TRUE_CHILD_STRATEGY(self, value):
        # Validate type NO-TRUE-CHILD-STRATEGY, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['returnNullPrediction', 'returnLastPrediction']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NO-TRUE-CHILD-STRATEGY' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.Node is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TreeModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TreeModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TreeModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TreeModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TreeModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.missingValueStrategy != "none" and 'missingValueStrategy' not in already_processed:
            already_processed.add('missingValueStrategy')
            outfile.write(' missingValueStrategy=%s' % (quote_attrib(self.missingValueStrategy), ))
        if self.missingValuePenalty != 1.0 and 'missingValuePenalty' not in already_processed:
            already_processed.add('missingValuePenalty')
            outfile.write(' missingValuePenalty=%s' % (quote_attrib(self.missingValuePenalty), ))
        if self.noTrueChildStrategy != "returnNullPrediction" and 'noTrueChildStrategy' not in already_processed:
            already_processed.add('noTrueChildStrategy')
            outfile.write(' noTrueChildStrategy=%s' % (quote_attrib(self.noTrueChildStrategy), ))
        if self.splitCharacteristic != "multiSplit" and 'splitCharacteristic' not in already_processed:
            already_processed.add('splitCharacteristic')
            outfile.write(' splitCharacteristic=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.splitCharacteristic), input_name='splitCharacteristic')), ))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='TreeModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            self.ModelExplanation.export(outfile, level, namespace_, name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            self.Targets.export(outfile, level, namespace_, name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        if self.Node is not None:
            self.Node.export(outfile, level, namespace_, name_='Node', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TreeModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.missingValueStrategy is not None:
            element.set('missingValueStrategy', self.missingValueStrategy)
        if self.missingValuePenalty is not None:
            element.set('missingValuePenalty', self.missingValuePenalty)
        if self.noTrueChildStrategy is not None:
            element.set('noTrueChildStrategy', self.noTrueChildStrategy)
        if self.splitCharacteristic is not None:
            element.set('splitCharacteristic', self.gds_format_string(self.splitCharacteristic))
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.ModelExplanation is not None:
            ModelExplanation_ = self.ModelExplanation
            ModelExplanation_.to_etree(element, name_='ModelExplanation', mapping_=mapping_)
        if self.Targets is not None:
            Targets_ = self.Targets
            Targets_.to_etree(element, name_='Targets', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        if self.Node is not None:
            Node_ = self.Node
            Node_.to_etree(element, name_='Node', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TreeModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.missingValueStrategy is not None and 'missingValueStrategy' not in already_processed:
            already_processed.add('missingValueStrategy')
            showIndent(outfile, level)
            outfile.write('missingValueStrategy="%s",\n' % (self.missingValueStrategy,))
        if self.missingValuePenalty is not None and 'missingValuePenalty' not in already_processed:
            already_processed.add('missingValuePenalty')
            showIndent(outfile, level)
            outfile.write('missingValuePenalty=%e,\n' % (self.missingValuePenalty,))
        if self.noTrueChildStrategy is not None and 'noTrueChildStrategy' not in already_processed:
            already_processed.add('noTrueChildStrategy')
            showIndent(outfile, level)
            outfile.write('noTrueChildStrategy="%s",\n' % (self.noTrueChildStrategy,))
        if self.splitCharacteristic is not None and 'splitCharacteristic' not in already_processed:
            already_processed.add('splitCharacteristic')
            showIndent(outfile, level)
            outfile.write('splitCharacteristic="%s",\n' % (self.splitCharacteristic,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelExplanation is not None:
            showIndent(outfile, level)
            outfile.write('ModelExplanation=model_.ModelExplanation(\n')
            self.ModelExplanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targets is not None:
            showIndent(outfile, level)
            outfile.write('Targets=model_.Targets(\n')
            self.Targets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Node is not None:
            showIndent(outfile, level)
            outfile.write('Node=model_.Node(\n')
            self.Node.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('missingValueStrategy', node)
        if value is not None and 'missingValueStrategy' not in already_processed:
            already_processed.add('missingValueStrategy')
            self.missingValueStrategy = value
            self.validate_MISSING_VALUE_STRATEGY(self.missingValueStrategy)    # validate type MISSING-VALUE-STRATEGY
        value = find_attr_value_('missingValuePenalty', node)
        if value is not None and 'missingValuePenalty' not in already_processed:
            already_processed.add('missingValuePenalty')
            try:
                self.missingValuePenalty = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (missingValuePenalty): %s' % exp)
            self.validate_PROB_NUMBER(self.missingValuePenalty)    # validate type PROB-NUMBER
        value = find_attr_value_('noTrueChildStrategy', node)
        if value is not None and 'noTrueChildStrategy' not in already_processed:
            already_processed.add('noTrueChildStrategy')
            self.noTrueChildStrategy = value
            self.validate_NO_TRUE_CHILD_STRATEGY(self.noTrueChildStrategy)    # validate type NO-TRUE-CHILD-STRATEGY
        value = find_attr_value_('splitCharacteristic', node)
        if value is not None and 'splitCharacteristic' not in already_processed:
            already_processed.add('splitCharacteristic')
            self.splitCharacteristic = value
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory()
            obj_.build(child_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory()
            obj_.build(child_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'Node':
            obj_ = Node.factory()
            obj_.build(child_)
            self.Node = obj_
            obj_.original_tagname_ = 'Node'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class TreeModel


class Node(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, score=None, recordCount=None, defaultChild=None, SimplePredicate=None, CompoundPredicate=None, SimpleSetPredicate=None, True_=None, False_=None, Partition=None, ScoreDistribution=None, Node_member=None, Extension=None, Regression=None, DecisionTree=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.score = _cast(None, score)
        self.recordCount = _cast(None, recordCount)
        self.defaultChild = _cast(None, defaultChild)
        self.SimplePredicate = SimplePredicate
        self.CompoundPredicate = CompoundPredicate
        self.SimpleSetPredicate = SimpleSetPredicate
        self.True_ = True_
        self.False_ = False_
        self.Partition = Partition
        if ScoreDistribution is None:
            self.ScoreDistribution = []
        else:
            self.ScoreDistribution = ScoreDistribution
        if Node_member is None:
            self.Node = []
        else:
            self.Node = Node_member
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Regression = Regression
        self.DecisionTree = DecisionTree
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Node)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Node.subclass:
            return Node.subclass(*args_, **kwargs_)
        else:
            return Node(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SimplePredicate(self): return self.SimplePredicate
    def set_SimplePredicate(self, SimplePredicate): self.SimplePredicate = SimplePredicate
    def get_CompoundPredicate(self): return self.CompoundPredicate
    def set_CompoundPredicate(self, CompoundPredicate): self.CompoundPredicate = CompoundPredicate
    def get_SimpleSetPredicate(self): return self.SimpleSetPredicate
    def set_SimpleSetPredicate(self, SimpleSetPredicate): self.SimpleSetPredicate = SimpleSetPredicate
    def get_True(self): return self.True_
    def set_True(self, True_): self.True_ = True_
    def get_False(self): return self.False_
    def set_False(self, False_): self.False_ = False_
    def get_Partition(self): return self.Partition
    def set_Partition(self, Partition): self.Partition = Partition
    def get_ScoreDistribution(self): return self.ScoreDistribution
    def set_ScoreDistribution(self, ScoreDistribution): self.ScoreDistribution = ScoreDistribution
    def add_ScoreDistribution(self, value): self.ScoreDistribution.append(value)
    def insert_ScoreDistribution_at(self, index, value): self.ScoreDistribution.insert(index, value)
    def replace_ScoreDistribution_at(self, index, value): self.ScoreDistribution[index] = value
    def get_Node(self): return self.Node
    def set_Node(self, Node): self.Node = Node
    def add_Node(self, value): self.Node.append(value)
    def insert_Node_at(self, index, value): self.Node.insert(index, value)
    def replace_Node_at(self, index, value): self.Node[index] = value
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Regression(self): return self.Regression
    def set_Regression(self, Regression): self.Regression = Regression
    def get_DecisionTree(self): return self.DecisionTree
    def set_DecisionTree(self, DecisionTree): self.DecisionTree = DecisionTree
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_score(self): return self.score
    def set_score(self, score): self.score = score
    def get_recordCount(self): return self.recordCount
    def set_recordCount(self, recordCount): self.recordCount = recordCount
    def get_defaultChild(self): return self.defaultChild
    def set_defaultChild(self, defaultChild): self.defaultChild = defaultChild
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.SimplePredicate is not None or
            self.CompoundPredicate is not None or
            self.SimpleSetPredicate is not None or
            self.True_ is not None or
            self.False_ is not None or
            self.Partition is not None or
            self.ScoreDistribution or
            self.Node or
            self.Extension or
            self.Regression is not None or
            self.DecisionTree is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Node', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Node')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Node')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Node', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Node'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.score is not None and 'score' not in already_processed:
            already_processed.add('score')
            outfile.write(' score=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.score), input_name='score')), ))
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            outfile.write(' recordCount=%s' % (quote_attrib(self.recordCount), ))
        if self.defaultChild is not None and 'defaultChild' not in already_processed:
            already_processed.add('defaultChild')
            outfile.write(' defaultChild=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.defaultChild), input_name='defaultChild')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Node', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SimplePredicate is not None:
            self.SimplePredicate.export(outfile, level, namespace_, name_='SimplePredicate', pretty_print=pretty_print)
        if self.CompoundPredicate is not None:
            self.CompoundPredicate.export(outfile, level, namespace_, name_='CompoundPredicate', pretty_print=pretty_print)
        if self.SimpleSetPredicate is not None:
            self.SimpleSetPredicate.export(outfile, level, namespace_, name_='SimpleSetPredicate', pretty_print=pretty_print)
        if self.True_ is not None:
            self.True_.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False_ is not None:
            self.False_.export(outfile, level, namespace_, name_='False', pretty_print=pretty_print)
        if self.Partition is not None:
            self.Partition.export(outfile, level, namespace_, name_='Partition', pretty_print=pretty_print)
        for ScoreDistribution_ in self.ScoreDistribution:
            ScoreDistribution_.export(outfile, level, namespace_, name_='ScoreDistribution', pretty_print=pretty_print)
        for Node_ in self.Node:
            Node_.export(outfile, level, namespace_, name_='Node', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Regression is not None:
            self.Regression.export(outfile, level, namespace_, name_='Regression', pretty_print=pretty_print)
        if self.DecisionTree is not None:
            self.DecisionTree.export(outfile, level, namespace_, name_='DecisionTree', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Node', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.score is not None:
            element.set('score', self.gds_format_string(self.score))
        if self.recordCount is not None:
            element.set('recordCount', self.recordCount)
        if self.defaultChild is not None:
            element.set('defaultChild', self.gds_format_string(self.defaultChild))
        if self.SimplePredicate is not None:
            SimplePredicate_ = self.SimplePredicate
            SimplePredicate_.to_etree(element, name_='SimplePredicate', mapping_=mapping_)
        if self.CompoundPredicate is not None:
            CompoundPredicate_ = self.CompoundPredicate
            CompoundPredicate_.to_etree(element, name_='CompoundPredicate', mapping_=mapping_)
        if self.SimpleSetPredicate is not None:
            SimpleSetPredicate_ = self.SimpleSetPredicate
            SimpleSetPredicate_.to_etree(element, name_='SimpleSetPredicate', mapping_=mapping_)
        if self.True_ is not None:
            True__ = self.True_
            True__.to_etree(element, name_='True', mapping_=mapping_)
        if self.False_ is not None:
            False__ = self.False_
            False__.to_etree(element, name_='False', mapping_=mapping_)
        if self.Partition is not None:
            Partition_ = self.Partition
            Partition_.to_etree(element, name_='Partition', mapping_=mapping_)
        for ScoreDistribution_ in self.ScoreDistribution:
            ScoreDistribution_.to_etree(element, name_='ScoreDistribution', mapping_=mapping_)
        for Node_ in self.Node:
            Node_.to_etree(element, name_='Node', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Regression is not None:
            Regression_ = self.Regression
            Regression_.to_etree(element, name_='Regression', mapping_=mapping_)
        if self.DecisionTree is not None:
            DecisionTree_ = self.DecisionTree
            DecisionTree_.to_etree(element, name_='DecisionTree', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Node'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.score is not None and 'score' not in already_processed:
            already_processed.add('score')
            showIndent(outfile, level)
            outfile.write('score="%s",\n' % (self.score,))
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            showIndent(outfile, level)
            outfile.write('recordCount=%e,\n' % (self.recordCount,))
        if self.defaultChild is not None and 'defaultChild' not in already_processed:
            already_processed.add('defaultChild')
            showIndent(outfile, level)
            outfile.write('defaultChild="%s",\n' % (self.defaultChild,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SimplePredicate is not None:
            showIndent(outfile, level)
            outfile.write('SimplePredicate=model_.SimplePredicate(\n')
            self.SimplePredicate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CompoundPredicate is not None:
            showIndent(outfile, level)
            outfile.write('CompoundPredicate=model_.CompoundPredicate(\n')
            self.CompoundPredicate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SimpleSetPredicate is not None:
            showIndent(outfile, level)
            outfile.write('SimpleSetPredicate=model_.SimpleSetPredicate(\n')
            self.SimpleSetPredicate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.True_ is not None:
            showIndent(outfile, level)
            outfile.write('True_=model_.True_(\n')
            self.True_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.False_ is not None:
            showIndent(outfile, level)
            outfile.write('False_=model_.False_(\n')
            self.False_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Partition is not None:
            showIndent(outfile, level)
            outfile.write('Partition=model_.Partition(\n')
            self.Partition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ScoreDistribution=[\n')
        level += 1
        for ScoreDistribution_ in self.ScoreDistribution:
            showIndent(outfile, level)
            outfile.write('model_.ScoreDistribution(\n')
            ScoreDistribution_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Node=[\n')
        level += 1
        for Node_ in self.Node:
            showIndent(outfile, level)
            outfile.write('model_.Node(\n')
            Node_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Regression is not None:
            showIndent(outfile, level)
            outfile.write('Regression=model_.Regression(\n')
            self.Regression.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DecisionTree is not None:
            showIndent(outfile, level)
            outfile.write('DecisionTree=model_.DecisionTree(\n')
            self.DecisionTree.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('score', node)
        if value is not None and 'score' not in already_processed:
            already_processed.add('score')
            self.score = value
        value = find_attr_value_('recordCount', node)
        if value is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            try:
                self.recordCount = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (recordCount): %s' % exp)
            self.validate_NUMBER(self.recordCount)    # validate type NUMBER
        value = find_attr_value_('defaultChild', node)
        if value is not None and 'defaultChild' not in already_processed:
            already_processed.add('defaultChild')
            self.defaultChild = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SimplePredicate':
            obj_ = SimplePredicate.factory()
            obj_.build(child_)
            self.SimplePredicate = obj_
            obj_.original_tagname_ = 'SimplePredicate'
        elif nodeName_ == 'CompoundPredicate':
            obj_ = CompoundPredicate.factory()
            obj_.build(child_)
            self.CompoundPredicate = obj_
            obj_.original_tagname_ = 'CompoundPredicate'
        elif nodeName_ == 'SimpleSetPredicate':
            obj_ = SimpleSetPredicate.factory()
            obj_.build(child_)
            self.SimpleSetPredicate = obj_
            obj_.original_tagname_ = 'SimpleSetPredicate'
        elif nodeName_ == 'True':
            obj_ = True_.factory()
            obj_.build(child_)
            self.True_ = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            obj_ = False_.factory()
            obj_.build(child_)
            self.False_ = obj_
            obj_.original_tagname_ = 'False'
        elif nodeName_ == 'Partition':
            obj_ = Partition.factory()
            obj_.build(child_)
            self.Partition = obj_
            obj_.original_tagname_ = 'Partition'
        elif nodeName_ == 'ScoreDistribution':
            obj_ = ScoreDistribution.factory()
            obj_.build(child_)
            self.ScoreDistribution.append(obj_)
            obj_.original_tagname_ = 'ScoreDistribution'
        elif nodeName_ == 'Node':
            obj_ = Node.factory()
            obj_.build(child_)
            self.Node.append(obj_)
            obj_.original_tagname_ = 'Node'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Regression':
            obj_ = Regression.factory()
            obj_.build(child_)
            self.Regression = obj_
            obj_.original_tagname_ = 'Regression'
        elif nodeName_ == 'DecisionTree':
            obj_ = DecisionTree.factory()
            obj_.build(child_)
            self.DecisionTree = obj_
            obj_.original_tagname_ = 'DecisionTree'
# end class Node


class SimplePredicate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, operator=None, value=None, Extension=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.operator = _cast(None, operator)
        self.value = _cast(None, value)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimplePredicate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimplePredicate.subclass:
            return SimplePredicate.subclass(*args_, **kwargs_)
        else:
            return SimplePredicate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_operator(self): return self.operator
    def set_operator(self, operator): self.operator = operator
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimplePredicate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SimplePredicate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimplePredicate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimplePredicate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimplePredicate'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.operator), input_name='operator')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SimplePredicate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SimplePredicate', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.operator is not None:
            element.set('operator', self.gds_format_string(self.operator))
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SimplePredicate'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            showIndent(outfile, level)
            outfile.write('operator="%s",\n' % (self.operator,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class SimplePredicate


class CompoundPredicate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, booleanOperator=None, Extension=None, SimplePredicate=None, CompoundPredicate_member=None, SimpleSetPredicate=None, True_=None, False_=None):
        self.original_tagname_ = None
        self.booleanOperator = _cast(None, booleanOperator)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if SimplePredicate is None:
            self.SimplePredicate = []
        else:
            self.SimplePredicate = SimplePredicate
        if CompoundPredicate_member is None:
            self.CompoundPredicate = []
        else:
            self.CompoundPredicate = CompoundPredicate_member
        if SimpleSetPredicate is None:
            self.SimpleSetPredicate = []
        else:
            self.SimpleSetPredicate = SimpleSetPredicate
        if True_ is None:
            self.True_ = []
        else:
            self.True_ = True_
        if False_ is None:
            self.False_ = []
        else:
            self.False_ = False_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompoundPredicate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompoundPredicate.subclass:
            return CompoundPredicate.subclass(*args_, **kwargs_)
        else:
            return CompoundPredicate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_SimplePredicate(self): return self.SimplePredicate
    def set_SimplePredicate(self, SimplePredicate): self.SimplePredicate = SimplePredicate
    def add_SimplePredicate(self, value): self.SimplePredicate.append(value)
    def insert_SimplePredicate_at(self, index, value): self.SimplePredicate.insert(index, value)
    def replace_SimplePredicate_at(self, index, value): self.SimplePredicate[index] = value
    def get_CompoundPredicate(self): return self.CompoundPredicate
    def set_CompoundPredicate(self, CompoundPredicate): self.CompoundPredicate = CompoundPredicate
    def add_CompoundPredicate(self, value): self.CompoundPredicate.append(value)
    def insert_CompoundPredicate_at(self, index, value): self.CompoundPredicate.insert(index, value)
    def replace_CompoundPredicate_at(self, index, value): self.CompoundPredicate[index] = value
    def get_SimpleSetPredicate(self): return self.SimpleSetPredicate
    def set_SimpleSetPredicate(self, SimpleSetPredicate): self.SimpleSetPredicate = SimpleSetPredicate
    def add_SimpleSetPredicate(self, value): self.SimpleSetPredicate.append(value)
    def insert_SimpleSetPredicate_at(self, index, value): self.SimpleSetPredicate.insert(index, value)
    def replace_SimpleSetPredicate_at(self, index, value): self.SimpleSetPredicate[index] = value
    def get_True(self): return self.True_
    def set_True(self, True_): self.True_ = True_
    def add_True(self, value): self.True_.append(value)
    def insert_True_at(self, index, value): self.True_.insert(index, value)
    def replace_True_at(self, index, value): self.True_[index] = value
    def get_False(self): return self.False_
    def set_False(self, False_): self.False_ = False_
    def add_False(self, value): self.False_.append(value)
    def insert_False_at(self, index, value): self.False_.insert(index, value)
    def replace_False_at(self, index, value): self.False_[index] = value
    def get_booleanOperator(self): return self.booleanOperator
    def set_booleanOperator(self, booleanOperator): self.booleanOperator = booleanOperator
    def hasContent_(self):
        if (
            self.Extension or
            self.SimplePredicate or
            self.CompoundPredicate or
            self.SimpleSetPredicate or
            self.True_ or
            self.False_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CompoundPredicate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompoundPredicate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompoundPredicate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CompoundPredicate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CompoundPredicate'):
        if self.booleanOperator is not None and 'booleanOperator' not in already_processed:
            already_processed.add('booleanOperator')
            outfile.write(' booleanOperator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.booleanOperator), input_name='booleanOperator')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CompoundPredicate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for SimplePredicate_ in self.SimplePredicate:
            SimplePredicate_.export(outfile, level, namespace_, name_='SimplePredicate', pretty_print=pretty_print)
        for CompoundPredicate_ in self.CompoundPredicate:
            CompoundPredicate_.export(outfile, level, namespace_, name_='CompoundPredicate', pretty_print=pretty_print)
        for SimpleSetPredicate_ in self.SimpleSetPredicate:
            SimpleSetPredicate_.export(outfile, level, namespace_, name_='SimpleSetPredicate', pretty_print=pretty_print)
        for True_ in self.True_:
            True_.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        for False_ in self.False_:
            False_.export(outfile, level, namespace_, name_='False', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='CompoundPredicate', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.booleanOperator is not None:
            element.set('booleanOperator', self.gds_format_string(self.booleanOperator))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for SimplePredicate_ in self.SimplePredicate:
            SimplePredicate_.to_etree(element, name_='SimplePredicate', mapping_=mapping_)
        for CompoundPredicate_ in self.CompoundPredicate:
            CompoundPredicate_.to_etree(element, name_='CompoundPredicate', mapping_=mapping_)
        for SimpleSetPredicate_ in self.SimpleSetPredicate:
            SimpleSetPredicate_.to_etree(element, name_='SimpleSetPredicate', mapping_=mapping_)
        for True__ in self.True_:
            True__.to_etree(element, name_='True', mapping_=mapping_)
        for False__ in self.False_:
            False__.to_etree(element, name_='False', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CompoundPredicate'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.booleanOperator is not None and 'booleanOperator' not in already_processed:
            already_processed.add('booleanOperator')
            showIndent(outfile, level)
            outfile.write('booleanOperator="%s",\n' % (self.booleanOperator,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SimplePredicate=[\n')
        level += 1
        for SimplePredicate_ in self.SimplePredicate:
            showIndent(outfile, level)
            outfile.write('model_.SimplePredicate(\n')
            SimplePredicate_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CompoundPredicate=[\n')
        level += 1
        for CompoundPredicate_ in self.CompoundPredicate:
            showIndent(outfile, level)
            outfile.write('model_.CompoundPredicate(\n')
            CompoundPredicate_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SimpleSetPredicate=[\n')
        level += 1
        for SimpleSetPredicate_ in self.SimpleSetPredicate:
            showIndent(outfile, level)
            outfile.write('model_.SimpleSetPredicate(\n')
            SimpleSetPredicate_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('True_=[\n')
        level += 1
        for True_ in self.True_:
            showIndent(outfile, level)
            outfile.write('model_.True_(\n')
            True_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('False_=[\n')
        level += 1
        for False_ in self.False_:
            showIndent(outfile, level)
            outfile.write('model_.False_(\n')
            False_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('booleanOperator', node)
        if value is not None and 'booleanOperator' not in already_processed:
            already_processed.add('booleanOperator')
            self.booleanOperator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'SimplePredicate':
            obj_ = SimplePredicate.factory()
            obj_.build(child_)
            self.SimplePredicate.append(obj_)
            obj_.original_tagname_ = 'SimplePredicate'
        elif nodeName_ == 'CompoundPredicate':
            obj_ = CompoundPredicate.factory()
            obj_.build(child_)
            self.CompoundPredicate.append(obj_)
            obj_.original_tagname_ = 'CompoundPredicate'
        elif nodeName_ == 'SimpleSetPredicate':
            obj_ = SimpleSetPredicate.factory()
            obj_.build(child_)
            self.SimpleSetPredicate.append(obj_)
            obj_.original_tagname_ = 'SimpleSetPredicate'
        elif nodeName_ == 'True':
            obj_ = True_.factory()
            obj_.build(child_)
            self.True_.append(obj_)
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            obj_ = False_.factory()
            obj_.build(child_)
            self.False_.append(obj_)
            obj_.original_tagname_ = 'False'
# end class CompoundPredicate


class SimpleSetPredicate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, booleanOperator=None, Extension=None, Array=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.booleanOperator = _cast(None, booleanOperator)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleSetPredicate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleSetPredicate.subclass:
            return SimpleSetPredicate.subclass(*args_, **kwargs_)
        else:
            return SimpleSetPredicate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_booleanOperator(self): return self.booleanOperator
    def set_booleanOperator(self, booleanOperator): self.booleanOperator = booleanOperator
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimpleSetPredicate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SimpleSetPredicate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleSetPredicate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimpleSetPredicate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimpleSetPredicate'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.booleanOperator is not None and 'booleanOperator' not in already_processed:
            already_processed.add('booleanOperator')
            outfile.write(' booleanOperator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.booleanOperator), input_name='booleanOperator')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SimpleSetPredicate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SimpleSetPredicate', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.booleanOperator is not None:
            element.set('booleanOperator', self.gds_format_string(self.booleanOperator))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SimpleSetPredicate'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.booleanOperator is not None and 'booleanOperator' not in already_processed:
            already_processed.add('booleanOperator')
            showIndent(outfile, level)
            outfile.write('booleanOperator="%s",\n' % (self.booleanOperator,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('booleanOperator', node)
        if value is not None and 'booleanOperator' not in already_processed:
            already_processed.add('booleanOperator')
            self.booleanOperator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class SimpleSetPredicate


class True_(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, True_)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if True_.subclass:
            return True_.subclass(*args_, **kwargs_)
        else:
            return True_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='True', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('True')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='True')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='True', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='True'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='True', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='True', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='True'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class True_


class False_(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, False_)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if False_.subclass:
            return False_.subclass(*args_, **kwargs_)
        else:
            return False_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='False', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('False')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='False')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='False', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='False'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='False', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='False', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='False'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class False_


class ScoreDistribution(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, recordCount=None, confidence=None, probability=None, Extension=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.recordCount = _cast(None, recordCount)
        self.confidence = _cast(None, confidence)
        self.probability = _cast(None, probability)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScoreDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScoreDistribution.subclass:
            return ScoreDistribution.subclass(*args_, **kwargs_)
        else:
            return ScoreDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_recordCount(self): return self.recordCount
    def set_recordCount(self, recordCount): self.recordCount = recordCount
    def get_confidence(self): return self.confidence
    def set_confidence(self, confidence): self.confidence = confidence
    def get_probability(self): return self.probability
    def set_probability(self, probability): self.probability = probability
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ScoreDistribution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ScoreDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScoreDistribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ScoreDistribution', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ScoreDistribution'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            outfile.write(' recordCount=%s' % (quote_attrib(self.recordCount), ))
        if self.confidence is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            outfile.write(' confidence=%s' % (quote_attrib(self.confidence), ))
        if self.probability is not None and 'probability' not in already_processed:
            already_processed.add('probability')
            outfile.write(' probability=%s' % (quote_attrib(self.probability), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ScoreDistribution', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ScoreDistribution', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.recordCount is not None:
            element.set('recordCount', self.recordCount)
        if self.confidence is not None:
            element.set('confidence', self.confidence)
        if self.probability is not None:
            element.set('probability', self.probability)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ScoreDistribution'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            showIndent(outfile, level)
            outfile.write('recordCount=%e,\n' % (self.recordCount,))
        if self.confidence is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            showIndent(outfile, level)
            outfile.write('confidence=%e,\n' % (self.confidence,))
        if self.probability is not None and 'probability' not in already_processed:
            already_processed.add('probability')
            showIndent(outfile, level)
            outfile.write('probability=%e,\n' % (self.probability,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('recordCount', node)
        if value is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            try:
                self.recordCount = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (recordCount): %s' % exp)
            self.validate_NUMBER(self.recordCount)    # validate type NUMBER
        value = find_attr_value_('confidence', node)
        if value is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            try:
                self.confidence = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (confidence): %s' % exp)
            self.validate_PROB_NUMBER(self.confidence)    # validate type PROB-NUMBER
        value = find_attr_value_('probability', node)
        if value is not None and 'probability' not in already_processed:
            already_processed.add('probability')
            try:
                self.probability = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (probability): %s' % exp)
            self.validate_PROB_NUMBER(self.probability)    # validate type PROB-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class ScoreDistribution


class Scorecard(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, initialScore='0', useReasonCodes=True, reasonCodeAlgorithm='pointsBelow', baselineScore=None, baselineMethod='other', isScorable=True, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, Characteristics=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.initialScore = _cast(None, initialScore)
        self.useReasonCodes = _cast(bool, useReasonCodes)
        self.reasonCodeAlgorithm = _cast(None, reasonCodeAlgorithm)
        self.baselineScore = _cast(None, baselineScore)
        self.baselineMethod = _cast(None, baselineMethod)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.ModelExplanation = ModelExplanation
        self.Targets = Targets
        self.LocalTransformations = LocalTransformations
        self.Characteristics = Characteristics
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Scorecard)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Scorecard.subclass:
            return Scorecard.subclass(*args_, **kwargs_)
        else:
            return Scorecard(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_ModelExplanation(self): return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation): self.ModelExplanation = ModelExplanation
    def get_Targets(self): return self.Targets
    def set_Targets(self, Targets): self.Targets = Targets
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_Characteristics(self): return self.Characteristics
    def set_Characteristics(self, Characteristics): self.Characteristics = Characteristics
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_initialScore(self): return self.initialScore
    def set_initialScore(self, initialScore): self.initialScore = initialScore
    def get_useReasonCodes(self): return self.useReasonCodes
    def set_useReasonCodes(self, useReasonCodes): self.useReasonCodes = useReasonCodes
    def get_reasonCodeAlgorithm(self): return self.reasonCodeAlgorithm
    def set_reasonCodeAlgorithm(self, reasonCodeAlgorithm): self.reasonCodeAlgorithm = reasonCodeAlgorithm
    def get_baselineScore(self): return self.baselineScore
    def set_baselineScore(self, baselineScore): self.baselineScore = baselineScore
    def get_baselineMethod(self): return self.baselineMethod
    def set_baselineMethod(self, baselineMethod): self.baselineMethod = baselineMethod
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.Characteristics is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Scorecard', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Scorecard')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Scorecard')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Scorecard', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Scorecard'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.initialScore != 0 and 'initialScore' not in already_processed:
            already_processed.add('initialScore')
            outfile.write(' initialScore=%s' % (quote_attrib(self.initialScore), ))
        if not self.useReasonCodes and 'useReasonCodes' not in already_processed:
            already_processed.add('useReasonCodes')
            outfile.write(' useReasonCodes="%s"' % self.gds_format_boolean(self.useReasonCodes, input_name='useReasonCodes'))
        if self.reasonCodeAlgorithm != "pointsBelow" and 'reasonCodeAlgorithm' not in already_processed:
            already_processed.add('reasonCodeAlgorithm')
            outfile.write(' reasonCodeAlgorithm=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reasonCodeAlgorithm), input_name='reasonCodeAlgorithm')), ))
        if self.baselineScore is not None and 'baselineScore' not in already_processed:
            already_processed.add('baselineScore')
            outfile.write(' baselineScore=%s' % (quote_attrib(self.baselineScore), ))
        if self.baselineMethod != "other" and 'baselineMethod' not in already_processed:
            already_processed.add('baselineMethod')
            outfile.write(' baselineMethod=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.baselineMethod), input_name='baselineMethod')), ))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='Scorecard', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            self.ModelExplanation.export(outfile, level, namespace_, name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            self.Targets.export(outfile, level, namespace_, name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        if self.Characteristics is not None:
            self.Characteristics.export(outfile, level, namespace_, name_='Characteristics', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Scorecard', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.initialScore is not None:
            element.set('initialScore', self.initialScore)
        if self.useReasonCodes is not None:
            element.set('useReasonCodes', self.gds_format_boolean(self.useReasonCodes))
        if self.reasonCodeAlgorithm is not None:
            element.set('reasonCodeAlgorithm', self.gds_format_string(self.reasonCodeAlgorithm))
        if self.baselineScore is not None:
            element.set('baselineScore', self.baselineScore)
        if self.baselineMethod is not None:
            element.set('baselineMethod', self.gds_format_string(self.baselineMethod))
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.ModelExplanation is not None:
            ModelExplanation_ = self.ModelExplanation
            ModelExplanation_.to_etree(element, name_='ModelExplanation', mapping_=mapping_)
        if self.Targets is not None:
            Targets_ = self.Targets
            Targets_.to_etree(element, name_='Targets', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        if self.Characteristics is not None:
            Characteristics_ = self.Characteristics
            Characteristics_.to_etree(element, name_='Characteristics', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Scorecard'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.initialScore is not None and 'initialScore' not in already_processed:
            already_processed.add('initialScore')
            showIndent(outfile, level)
            outfile.write('initialScore=%e,\n' % (self.initialScore,))
        if self.useReasonCodes is not None and 'useReasonCodes' not in already_processed:
            already_processed.add('useReasonCodes')
            showIndent(outfile, level)
            outfile.write('useReasonCodes=%s,\n' % (self.useReasonCodes,))
        if self.reasonCodeAlgorithm is not None and 'reasonCodeAlgorithm' not in already_processed:
            already_processed.add('reasonCodeAlgorithm')
            showIndent(outfile, level)
            outfile.write('reasonCodeAlgorithm="%s",\n' % (self.reasonCodeAlgorithm,))
        if self.baselineScore is not None and 'baselineScore' not in already_processed:
            already_processed.add('baselineScore')
            showIndent(outfile, level)
            outfile.write('baselineScore=%e,\n' % (self.baselineScore,))
        if self.baselineMethod is not None and 'baselineMethod' not in already_processed:
            already_processed.add('baselineMethod')
            showIndent(outfile, level)
            outfile.write('baselineMethod="%s",\n' % (self.baselineMethod,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelExplanation is not None:
            showIndent(outfile, level)
            outfile.write('ModelExplanation=model_.ModelExplanation(\n')
            self.ModelExplanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targets is not None:
            showIndent(outfile, level)
            outfile.write('Targets=model_.Targets(\n')
            self.Targets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Characteristics is not None:
            showIndent(outfile, level)
            outfile.write('Characteristics=model_.Characteristics(\n')
            self.Characteristics.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('initialScore', node)
        if value is not None and 'initialScore' not in already_processed:
            already_processed.add('initialScore')
            try:
                self.initialScore = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (initialScore): %s' % exp)
            self.validate_NUMBER(self.initialScore)    # validate type NUMBER
        value = find_attr_value_('useReasonCodes', node)
        if value is not None and 'useReasonCodes' not in already_processed:
            already_processed.add('useReasonCodes')
            if value in ('true', '1'):
                self.useReasonCodes = True
            elif value in ('false', '0'):
                self.useReasonCodes = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('reasonCodeAlgorithm', node)
        if value is not None and 'reasonCodeAlgorithm' not in already_processed:
            already_processed.add('reasonCodeAlgorithm')
            self.reasonCodeAlgorithm = value
        value = find_attr_value_('baselineScore', node)
        if value is not None and 'baselineScore' not in already_processed:
            already_processed.add('baselineScore')
            try:
                self.baselineScore = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (baselineScore): %s' % exp)
            self.validate_NUMBER(self.baselineScore)    # validate type NUMBER
        value = find_attr_value_('baselineMethod', node)
        if value is not None and 'baselineMethod' not in already_processed:
            already_processed.add('baselineMethod')
            self.baselineMethod = value
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory()
            obj_.build(child_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory()
            obj_.build(child_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'Characteristics':
            obj_ = Characteristics.factory()
            obj_.build(child_)
            self.Characteristics = obj_
            obj_.original_tagname_ = 'Characteristics'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Scorecard


class Characteristics(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Characteristic=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Characteristic is None:
            self.Characteristic = []
        else:
            self.Characteristic = Characteristic
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Characteristics)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Characteristics.subclass:
            return Characteristics.subclass(*args_, **kwargs_)
        else:
            return Characteristics(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Characteristic(self): return self.Characteristic
    def set_Characteristic(self, Characteristic): self.Characteristic = Characteristic
    def add_Characteristic(self, value): self.Characteristic.append(value)
    def insert_Characteristic_at(self, index, value): self.Characteristic.insert(index, value)
    def replace_Characteristic_at(self, index, value): self.Characteristic[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.Characteristic
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Characteristics', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Characteristics')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Characteristics')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Characteristics', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Characteristics'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Characteristics', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Characteristic_ in self.Characteristic:
            Characteristic_.export(outfile, level, namespace_, name_='Characteristic', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Characteristics', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Characteristic_ in self.Characteristic:
            Characteristic_.to_etree(element, name_='Characteristic', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Characteristics'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Characteristic=[\n')
        level += 1
        for Characteristic_ in self.Characteristic:
            showIndent(outfile, level)
            outfile.write('model_.Characteristic(\n')
            Characteristic_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Characteristic':
            obj_ = Characteristic.factory()
            obj_.build(child_)
            self.Characteristic.append(obj_)
            obj_.original_tagname_ = 'Characteristic'
# end class Characteristics


class Characteristic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, reasonCode=None, baselineScore=None, Extension=None, Attribute=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.reasonCode = _cast(None, reasonCode)
        self.baselineScore = _cast(None, baselineScore)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Attribute is None:
            self.Attribute = []
        else:
            self.Attribute = Attribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Characteristic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Characteristic.subclass:
            return Characteristic.subclass(*args_, **kwargs_)
        else:
            return Characteristic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def add_Attribute(self, value): self.Attribute.append(value)
    def insert_Attribute_at(self, index, value): self.Attribute.insert(index, value)
    def replace_Attribute_at(self, index, value): self.Attribute[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_reasonCode(self): return self.reasonCode
    def set_reasonCode(self, reasonCode): self.reasonCode = reasonCode
    def get_baselineScore(self): return self.baselineScore
    def set_baselineScore(self, baselineScore): self.baselineScore = baselineScore
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Characteristic', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Characteristic')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Characteristic')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Characteristic', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Characteristic'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.reasonCode is not None and 'reasonCode' not in already_processed:
            already_processed.add('reasonCode')
            outfile.write(' reasonCode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reasonCode), input_name='reasonCode')), ))
        if self.baselineScore is not None and 'baselineScore' not in already_processed:
            already_processed.add('baselineScore')
            outfile.write(' baselineScore=%s' % (quote_attrib(self.baselineScore), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Characteristic', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Attribute_ in self.Attribute:
            Attribute_.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Characteristic', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.reasonCode is not None:
            element.set('reasonCode', self.gds_format_string(self.reasonCode))
        if self.baselineScore is not None:
            element.set('baselineScore', self.baselineScore)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Attribute_ in self.Attribute:
            Attribute_.to_etree(element, name_='Attribute', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Characteristic'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.reasonCode is not None and 'reasonCode' not in already_processed:
            already_processed.add('reasonCode')
            showIndent(outfile, level)
            outfile.write('reasonCode="%s",\n' % (self.reasonCode,))
        if self.baselineScore is not None and 'baselineScore' not in already_processed:
            already_processed.add('baselineScore')
            showIndent(outfile, level)
            outfile.write('baselineScore=%e,\n' % (self.baselineScore,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Attribute=[\n')
        level += 1
        for Attribute_ in self.Attribute:
            showIndent(outfile, level)
            outfile.write('model_.Attribute(\n')
            Attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('reasonCode', node)
        if value is not None and 'reasonCode' not in already_processed:
            already_processed.add('reasonCode')
            self.reasonCode = value
        value = find_attr_value_('baselineScore', node)
        if value is not None and 'baselineScore' not in already_processed:
            already_processed.add('baselineScore')
            try:
                self.baselineScore = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (baselineScore): %s' % exp)
            self.validate_NUMBER(self.baselineScore)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Attribute':
            obj_ = Attribute.factory()
            obj_.build(child_)
            self.Attribute.append(obj_)
            obj_.original_tagname_ = 'Attribute'
# end class Characteristic


class Attribute(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, reasonCode=None, partialScore=None, Extension=None, SimplePredicate=None, CompoundPredicate=None, SimpleSetPredicate=None, True_=None, False_=None, ComplexPartialScore=None):
        self.original_tagname_ = None
        self.reasonCode = _cast(None, reasonCode)
        self.partialScore = _cast(None, partialScore)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.SimplePredicate = SimplePredicate
        self.CompoundPredicate = CompoundPredicate
        self.SimpleSetPredicate = SimpleSetPredicate
        self.True_ = True_
        self.False_ = False_
        self.ComplexPartialScore = ComplexPartialScore
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Attribute)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Attribute.subclass:
            return Attribute.subclass(*args_, **kwargs_)
        else:
            return Attribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_SimplePredicate(self): return self.SimplePredicate
    def set_SimplePredicate(self, SimplePredicate): self.SimplePredicate = SimplePredicate
    def get_CompoundPredicate(self): return self.CompoundPredicate
    def set_CompoundPredicate(self, CompoundPredicate): self.CompoundPredicate = CompoundPredicate
    def get_SimpleSetPredicate(self): return self.SimpleSetPredicate
    def set_SimpleSetPredicate(self, SimpleSetPredicate): self.SimpleSetPredicate = SimpleSetPredicate
    def get_True(self): return self.True_
    def set_True(self, True_): self.True_ = True_
    def get_False(self): return self.False_
    def set_False(self, False_): self.False_ = False_
    def get_ComplexPartialScore(self): return self.ComplexPartialScore
    def set_ComplexPartialScore(self, ComplexPartialScore): self.ComplexPartialScore = ComplexPartialScore
    def get_reasonCode(self): return self.reasonCode
    def set_reasonCode(self, reasonCode): self.reasonCode = reasonCode
    def get_partialScore(self): return self.partialScore
    def set_partialScore(self, partialScore): self.partialScore = partialScore
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.SimplePredicate is not None or
            self.CompoundPredicate is not None or
            self.SimpleSetPredicate is not None or
            self.True_ is not None or
            self.False_ is not None or
            self.ComplexPartialScore is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Attribute', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Attribute')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attribute')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Attribute', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Attribute'):
        if self.reasonCode is not None and 'reasonCode' not in already_processed:
            already_processed.add('reasonCode')
            outfile.write(' reasonCode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reasonCode), input_name='reasonCode')), ))
        if self.partialScore is not None and 'partialScore' not in already_processed:
            already_processed.add('partialScore')
            outfile.write(' partialScore=%s' % (quote_attrib(self.partialScore), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Attribute', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.SimplePredicate is not None:
            self.SimplePredicate.export(outfile, level, namespace_, name_='SimplePredicate', pretty_print=pretty_print)
        if self.CompoundPredicate is not None:
            self.CompoundPredicate.export(outfile, level, namespace_, name_='CompoundPredicate', pretty_print=pretty_print)
        if self.SimpleSetPredicate is not None:
            self.SimpleSetPredicate.export(outfile, level, namespace_, name_='SimpleSetPredicate', pretty_print=pretty_print)
        if self.True_ is not None:
            self.True_.export(outfile, level, namespace_, name_='True', pretty_print=pretty_print)
        if self.False_ is not None:
            self.False_.export(outfile, level, namespace_, name_='False', pretty_print=pretty_print)
        if self.ComplexPartialScore is not None:
            self.ComplexPartialScore.export(outfile, level, namespace_, name_='ComplexPartialScore', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Attribute', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.reasonCode is not None:
            element.set('reasonCode', self.gds_format_string(self.reasonCode))
        if self.partialScore is not None:
            element.set('partialScore', self.partialScore)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.SimplePredicate is not None:
            SimplePredicate_ = self.SimplePredicate
            SimplePredicate_.to_etree(element, name_='SimplePredicate', mapping_=mapping_)
        if self.CompoundPredicate is not None:
            CompoundPredicate_ = self.CompoundPredicate
            CompoundPredicate_.to_etree(element, name_='CompoundPredicate', mapping_=mapping_)
        if self.SimpleSetPredicate is not None:
            SimpleSetPredicate_ = self.SimpleSetPredicate
            SimpleSetPredicate_.to_etree(element, name_='SimpleSetPredicate', mapping_=mapping_)
        if self.True_ is not None:
            True__ = self.True_
            True__.to_etree(element, name_='True', mapping_=mapping_)
        if self.False_ is not None:
            False__ = self.False_
            False__.to_etree(element, name_='False', mapping_=mapping_)
        if self.ComplexPartialScore is not None:
            ComplexPartialScore_ = self.ComplexPartialScore
            ComplexPartialScore_.to_etree(element, name_='ComplexPartialScore', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Attribute'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.reasonCode is not None and 'reasonCode' not in already_processed:
            already_processed.add('reasonCode')
            showIndent(outfile, level)
            outfile.write('reasonCode="%s",\n' % (self.reasonCode,))
        if self.partialScore is not None and 'partialScore' not in already_processed:
            already_processed.add('partialScore')
            showIndent(outfile, level)
            outfile.write('partialScore=%e,\n' % (self.partialScore,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SimplePredicate is not None:
            showIndent(outfile, level)
            outfile.write('SimplePredicate=model_.SimplePredicate(\n')
            self.SimplePredicate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CompoundPredicate is not None:
            showIndent(outfile, level)
            outfile.write('CompoundPredicate=model_.CompoundPredicate(\n')
            self.CompoundPredicate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SimpleSetPredicate is not None:
            showIndent(outfile, level)
            outfile.write('SimpleSetPredicate=model_.SimpleSetPredicate(\n')
            self.SimpleSetPredicate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.True_ is not None:
            showIndent(outfile, level)
            outfile.write('True_=model_.True_(\n')
            self.True_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.False_ is not None:
            showIndent(outfile, level)
            outfile.write('False_=model_.False_(\n')
            self.False_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ComplexPartialScore is not None:
            showIndent(outfile, level)
            outfile.write('ComplexPartialScore=model_.ComplexPartialScore(\n')
            self.ComplexPartialScore.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reasonCode', node)
        if value is not None and 'reasonCode' not in already_processed:
            already_processed.add('reasonCode')
            self.reasonCode = value
        value = find_attr_value_('partialScore', node)
        if value is not None and 'partialScore' not in already_processed:
            already_processed.add('partialScore')
            try:
                self.partialScore = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (partialScore): %s' % exp)
            self.validate_NUMBER(self.partialScore)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'SimplePredicate':
            obj_ = SimplePredicate.factory()
            obj_.build(child_)
            self.SimplePredicate = obj_
            obj_.original_tagname_ = 'SimplePredicate'
        elif nodeName_ == 'CompoundPredicate':
            obj_ = CompoundPredicate.factory()
            obj_.build(child_)
            self.CompoundPredicate = obj_
            obj_.original_tagname_ = 'CompoundPredicate'
        elif nodeName_ == 'SimpleSetPredicate':
            obj_ = SimpleSetPredicate.factory()
            obj_.build(child_)
            self.SimpleSetPredicate = obj_
            obj_.original_tagname_ = 'SimpleSetPredicate'
        elif nodeName_ == 'True':
            obj_ = True_.factory()
            obj_.build(child_)
            self.True_ = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            obj_ = False_.factory()
            obj_.build(child_)
            self.False_ = obj_
            obj_.original_tagname_ = 'False'
        elif nodeName_ == 'ComplexPartialScore':
            obj_ = ComplexPartialScore.factory()
            obj_.build(child_)
            self.ComplexPartialScore = obj_
            obj_.original_tagname_ = 'ComplexPartialScore'
# end class Attribute


class ComplexPartialScore(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, FieldRef=None, Apply=None, Constant=None, NormContinuous=None, NormDiscrete=None, Discretize=None, MapValues=None, TextIndex=None, Aggregate=None, Lag=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.FieldRef = FieldRef
        self.Apply = Apply
        self.Constant = Constant
        self.NormContinuous = NormContinuous
        self.NormDiscrete = NormDiscrete
        self.Discretize = Discretize
        self.MapValues = MapValues
        self.TextIndex = TextIndex
        self.Aggregate = Aggregate
        self.Lag = Lag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComplexPartialScore)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComplexPartialScore.subclass:
            return ComplexPartialScore.subclass(*args_, **kwargs_)
        else:
            return ComplexPartialScore(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_FieldRef(self): return self.FieldRef
    def set_FieldRef(self, FieldRef): self.FieldRef = FieldRef
    def get_Apply(self): return self.Apply
    def set_Apply(self, Apply): self.Apply = Apply
    def get_Constant(self): return self.Constant
    def set_Constant(self, Constant): self.Constant = Constant
    def get_NormContinuous(self): return self.NormContinuous
    def set_NormContinuous(self, NormContinuous): self.NormContinuous = NormContinuous
    def get_NormDiscrete(self): return self.NormDiscrete
    def set_NormDiscrete(self, NormDiscrete): self.NormDiscrete = NormDiscrete
    def get_Discretize(self): return self.Discretize
    def set_Discretize(self, Discretize): self.Discretize = Discretize
    def get_MapValues(self): return self.MapValues
    def set_MapValues(self, MapValues): self.MapValues = MapValues
    def get_TextIndex(self): return self.TextIndex
    def set_TextIndex(self, TextIndex): self.TextIndex = TextIndex
    def get_Aggregate(self): return self.Aggregate
    def set_Aggregate(self, Aggregate): self.Aggregate = Aggregate
    def get_Lag(self): return self.Lag
    def set_Lag(self, Lag): self.Lag = Lag
    def hasContent_(self):
        if (
            self.Extension or
            self.FieldRef is not None or
            self.Apply is not None or
            self.Constant is not None or
            self.NormContinuous is not None or
            self.NormDiscrete is not None or
            self.Discretize is not None or
            self.MapValues is not None or
            self.TextIndex is not None or
            self.Aggregate is not None or
            self.Lag is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ComplexPartialScore', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ComplexPartialScore')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComplexPartialScore')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ComplexPartialScore', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ComplexPartialScore'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ComplexPartialScore', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.FieldRef is not None:
            self.FieldRef.export(outfile, level, namespace_, name_='FieldRef', pretty_print=pretty_print)
        if self.Apply is not None:
            self.Apply.export(outfile, level, namespace_, name_='Apply', pretty_print=pretty_print)
        if self.Constant is not None:
            self.Constant.export(outfile, level, namespace_, name_='Constant', pretty_print=pretty_print)
        if self.NormContinuous is not None:
            self.NormContinuous.export(outfile, level, namespace_, name_='NormContinuous', pretty_print=pretty_print)
        if self.NormDiscrete is not None:
            self.NormDiscrete.export(outfile, level, namespace_, name_='NormDiscrete', pretty_print=pretty_print)
        if self.Discretize is not None:
            self.Discretize.export(outfile, level, namespace_, name_='Discretize', pretty_print=pretty_print)
        if self.MapValues is not None:
            self.MapValues.export(outfile, level, namespace_, name_='MapValues', pretty_print=pretty_print)
        if self.TextIndex is not None:
            self.TextIndex.export(outfile, level, namespace_, name_='TextIndex', pretty_print=pretty_print)
        if self.Aggregate is not None:
            self.Aggregate.export(outfile, level, namespace_, name_='Aggregate', pretty_print=pretty_print)
        if self.Lag is not None:
            self.Lag.export(outfile, level, namespace_, name_='Lag', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ComplexPartialScore', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.FieldRef is not None:
            FieldRef_ = self.FieldRef
            FieldRef_.to_etree(element, name_='FieldRef', mapping_=mapping_)
        if self.Apply is not None:
            Apply_ = self.Apply
            Apply_.to_etree(element, name_='Apply', mapping_=mapping_)
        if self.Constant is not None:
            Constant_ = self.Constant
            Constant_.to_etree(element, name_='Constant', mapping_=mapping_)
        if self.NormContinuous is not None:
            NormContinuous_ = self.NormContinuous
            NormContinuous_.to_etree(element, name_='NormContinuous', mapping_=mapping_)
        if self.NormDiscrete is not None:
            NormDiscrete_ = self.NormDiscrete
            NormDiscrete_.to_etree(element, name_='NormDiscrete', mapping_=mapping_)
        if self.Discretize is not None:
            Discretize_ = self.Discretize
            Discretize_.to_etree(element, name_='Discretize', mapping_=mapping_)
        if self.MapValues is not None:
            MapValues_ = self.MapValues
            MapValues_.to_etree(element, name_='MapValues', mapping_=mapping_)
        if self.TextIndex is not None:
            TextIndex_ = self.TextIndex
            TextIndex_.to_etree(element, name_='TextIndex', mapping_=mapping_)
        if self.Aggregate is not None:
            Aggregate_ = self.Aggregate
            Aggregate_.to_etree(element, name_='Aggregate', mapping_=mapping_)
        if self.Lag is not None:
            Lag_ = self.Lag
            Lag_.to_etree(element, name_='Lag', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ComplexPartialScore'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.FieldRef is not None:
            showIndent(outfile, level)
            outfile.write('FieldRef=model_.FieldRef(\n')
            self.FieldRef.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Apply is not None:
            showIndent(outfile, level)
            outfile.write('Apply=model_.Apply(\n')
            self.Apply.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Constant is not None:
            showIndent(outfile, level)
            outfile.write('Constant=model_.Constant(\n')
            self.Constant.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormContinuous is not None:
            showIndent(outfile, level)
            outfile.write('NormContinuous=model_.NormContinuous(\n')
            self.NormContinuous.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormDiscrete is not None:
            showIndent(outfile, level)
            outfile.write('NormDiscrete=model_.NormDiscrete(\n')
            self.NormDiscrete.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Discretize is not None:
            showIndent(outfile, level)
            outfile.write('Discretize=model_.Discretize(\n')
            self.Discretize.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MapValues is not None:
            showIndent(outfile, level)
            outfile.write('MapValues=model_.MapValues(\n')
            self.MapValues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextIndex is not None:
            showIndent(outfile, level)
            outfile.write('TextIndex=model_.TextIndex(\n')
            self.TextIndex.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Aggregate is not None:
            showIndent(outfile, level)
            outfile.write('Aggregate=model_.Aggregate(\n')
            self.Aggregate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Lag is not None:
            showIndent(outfile, level)
            outfile.write('Lag=model_.Lag(\n')
            self.Lag.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory()
            obj_.build(child_)
            self.FieldRef = obj_
            obj_.original_tagname_ = 'FieldRef'
        elif nodeName_ == 'Apply':
            obj_ = Apply.factory()
            obj_.build(child_)
            self.Apply = obj_
            obj_.original_tagname_ = 'Apply'
        elif nodeName_ == 'Constant':
            obj_ = Constant.factory()
            obj_.build(child_)
            self.Constant = obj_
            obj_.original_tagname_ = 'Constant'
        elif nodeName_ == 'NormContinuous':
            obj_ = NormContinuous.factory()
            obj_.build(child_)
            self.NormContinuous = obj_
            obj_.original_tagname_ = 'NormContinuous'
        elif nodeName_ == 'NormDiscrete':
            obj_ = NormDiscrete.factory()
            obj_.build(child_)
            self.NormDiscrete = obj_
            obj_.original_tagname_ = 'NormDiscrete'
        elif nodeName_ == 'Discretize':
            obj_ = Discretize.factory()
            obj_.build(child_)
            self.Discretize = obj_
            obj_.original_tagname_ = 'Discretize'
        elif nodeName_ == 'MapValues':
            obj_ = MapValues.factory()
            obj_.build(child_)
            self.MapValues = obj_
            obj_.original_tagname_ = 'MapValues'
        elif nodeName_ == 'TextIndex':
            obj_ = TextIndex.factory()
            obj_.build(child_)
            self.TextIndex = obj_
            obj_.original_tagname_ = 'TextIndex'
        elif nodeName_ == 'Aggregate':
            obj_ = Aggregate.factory()
            obj_.build(child_)
            self.Aggregate = obj_
            obj_.original_tagname_ = 'Aggregate'
        elif nodeName_ == 'Lag':
            obj_ = Lag.factory()
            obj_.build(child_)
            self.Lag = obj_
            obj_.original_tagname_ = 'Lag'
# end class ComplexPartialScore


class ModelStats(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, UnivariateStats=None, MultivariateStats=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if UnivariateStats is None:
            self.UnivariateStats = []
        else:
            self.UnivariateStats = UnivariateStats
        if MultivariateStats is None:
            self.MultivariateStats = []
        else:
            self.MultivariateStats = MultivariateStats
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ModelStats)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ModelStats.subclass:
            return ModelStats.subclass(*args_, **kwargs_)
        else:
            return ModelStats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_UnivariateStats(self): return self.UnivariateStats
    def set_UnivariateStats(self, UnivariateStats): self.UnivariateStats = UnivariateStats
    def add_UnivariateStats(self, value): self.UnivariateStats.append(value)
    def insert_UnivariateStats_at(self, index, value): self.UnivariateStats.insert(index, value)
    def replace_UnivariateStats_at(self, index, value): self.UnivariateStats[index] = value
    def get_MultivariateStats(self): return self.MultivariateStats
    def set_MultivariateStats(self, MultivariateStats): self.MultivariateStats = MultivariateStats
    def add_MultivariateStats(self, value): self.MultivariateStats.append(value)
    def insert_MultivariateStats_at(self, index, value): self.MultivariateStats.insert(index, value)
    def replace_MultivariateStats_at(self, index, value): self.MultivariateStats[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.UnivariateStats or
            self.MultivariateStats
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ModelStats', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ModelStats')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModelStats')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ModelStats', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ModelStats'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ModelStats', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for UnivariateStats_ in self.UnivariateStats:
            UnivariateStats_.export(outfile, level, namespace_, name_='UnivariateStats', pretty_print=pretty_print)
        for MultivariateStats_ in self.MultivariateStats:
            MultivariateStats_.export(outfile, level, namespace_, name_='MultivariateStats', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ModelStats', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for UnivariateStats_ in self.UnivariateStats:
            UnivariateStats_.to_etree(element, name_='UnivariateStats', mapping_=mapping_)
        for MultivariateStats_ in self.MultivariateStats:
            MultivariateStats_.to_etree(element, name_='MultivariateStats', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ModelStats'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('UnivariateStats=[\n')
        level += 1
        for UnivariateStats_ in self.UnivariateStats:
            showIndent(outfile, level)
            outfile.write('model_.UnivariateStats(\n')
            UnivariateStats_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MultivariateStats=[\n')
        level += 1
        for MultivariateStats_ in self.MultivariateStats:
            showIndent(outfile, level)
            outfile.write('model_.MultivariateStats(\n')
            MultivariateStats_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'UnivariateStats':
            obj_ = UnivariateStats.factory()
            obj_.build(child_)
            self.UnivariateStats.append(obj_)
            obj_.original_tagname_ = 'UnivariateStats'
        elif nodeName_ == 'MultivariateStats':
            obj_ = MultivariateStats.factory()
            obj_.build(child_)
            self.MultivariateStats.append(obj_)
            obj_.original_tagname_ = 'MultivariateStats'
# end class ModelStats


class UnivariateStats(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, weighted='0', Extension=None, Counts=None, NumericInfo=None, DiscrStats=None, ContStats=None, Anova=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.weighted = _cast(None, weighted)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Counts = Counts
        self.NumericInfo = NumericInfo
        self.DiscrStats = DiscrStats
        self.ContStats = ContStats
        self.Anova = Anova
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnivariateStats)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnivariateStats.subclass:
            return UnivariateStats.subclass(*args_, **kwargs_)
        else:
            return UnivariateStats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Counts(self): return self.Counts
    def set_Counts(self, Counts): self.Counts = Counts
    def get_NumericInfo(self): return self.NumericInfo
    def set_NumericInfo(self, NumericInfo): self.NumericInfo = NumericInfo
    def get_DiscrStats(self): return self.DiscrStats
    def set_DiscrStats(self, DiscrStats): self.DiscrStats = DiscrStats
    def get_ContStats(self): return self.ContStats
    def set_ContStats(self, ContStats): self.ContStats = ContStats
    def get_Anova(self): return self.Anova
    def set_Anova(self, Anova): self.Anova = Anova
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_weighted(self): return self.weighted
    def set_weighted(self, weighted): self.weighted = weighted
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Counts is not None or
            self.NumericInfo is not None or
            self.DiscrStats is not None or
            self.ContStats is not None or
            self.Anova is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnivariateStats', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnivariateStats')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnivariateStats')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnivariateStats', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnivariateStats'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.weighted != "0" and 'weighted' not in already_processed:
            already_processed.add('weighted')
            outfile.write(' weighted=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.weighted), input_name='weighted')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UnivariateStats', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Counts is not None:
            self.Counts.export(outfile, level, namespace_, name_='Counts', pretty_print=pretty_print)
        if self.NumericInfo is not None:
            self.NumericInfo.export(outfile, level, namespace_, name_='NumericInfo', pretty_print=pretty_print)
        if self.DiscrStats is not None:
            self.DiscrStats.export(outfile, level, namespace_, name_='DiscrStats', pretty_print=pretty_print)
        if self.ContStats is not None:
            self.ContStats.export(outfile, level, namespace_, name_='ContStats', pretty_print=pretty_print)
        if self.Anova is not None:
            self.Anova.export(outfile, level, namespace_, name_='Anova', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='UnivariateStats', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.weighted is not None:
            element.set('weighted', self.gds_format_string(self.weighted))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Counts is not None:
            Counts_ = self.Counts
            Counts_.to_etree(element, name_='Counts', mapping_=mapping_)
        if self.NumericInfo is not None:
            NumericInfo_ = self.NumericInfo
            NumericInfo_.to_etree(element, name_='NumericInfo', mapping_=mapping_)
        if self.DiscrStats is not None:
            DiscrStats_ = self.DiscrStats
            DiscrStats_.to_etree(element, name_='DiscrStats', mapping_=mapping_)
        if self.ContStats is not None:
            ContStats_ = self.ContStats
            ContStats_.to_etree(element, name_='ContStats', mapping_=mapping_)
        if self.Anova is not None:
            Anova_ = self.Anova
            Anova_.to_etree(element, name_='Anova', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UnivariateStats'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.weighted is not None and 'weighted' not in already_processed:
            already_processed.add('weighted')
            showIndent(outfile, level)
            outfile.write('weighted="%s",\n' % (self.weighted,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Counts is not None:
            showIndent(outfile, level)
            outfile.write('Counts=model_.Counts(\n')
            self.Counts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NumericInfo is not None:
            showIndent(outfile, level)
            outfile.write('NumericInfo=model_.NumericInfo(\n')
            self.NumericInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DiscrStats is not None:
            showIndent(outfile, level)
            outfile.write('DiscrStats=model_.DiscrStats(\n')
            self.DiscrStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ContStats is not None:
            showIndent(outfile, level)
            outfile.write('ContStats=model_.ContStats(\n')
            self.ContStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Anova is not None:
            showIndent(outfile, level)
            outfile.write('Anova=model_.Anova(\n')
            self.Anova.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('weighted', node)
        if value is not None and 'weighted' not in already_processed:
            already_processed.add('weighted')
            self.weighted = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Counts':
            obj_ = Counts.factory()
            obj_.build(child_)
            self.Counts = obj_
            obj_.original_tagname_ = 'Counts'
        elif nodeName_ == 'NumericInfo':
            obj_ = NumericInfo.factory()
            obj_.build(child_)
            self.NumericInfo = obj_
            obj_.original_tagname_ = 'NumericInfo'
        elif nodeName_ == 'DiscrStats':
            obj_ = DiscrStats.factory()
            obj_.build(child_)
            self.DiscrStats = obj_
            obj_.original_tagname_ = 'DiscrStats'
        elif nodeName_ == 'ContStats':
            obj_ = ContStats.factory()
            obj_.build(child_)
            self.ContStats = obj_
            obj_.original_tagname_ = 'ContStats'
        elif nodeName_ == 'Anova':
            obj_ = Anova.factory()
            obj_.build(child_)
            self.Anova = obj_
            obj_.original_tagname_ = 'Anova'
# end class UnivariateStats


class Counts(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, totalFreq=None, missingFreq=None, invalidFreq=None, cardinality=None, Extension=None):
        self.original_tagname_ = None
        self.totalFreq = _cast(None, totalFreq)
        self.missingFreq = _cast(None, missingFreq)
        self.invalidFreq = _cast(None, invalidFreq)
        self.cardinality = _cast(int, cardinality)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Counts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Counts.subclass:
            return Counts.subclass(*args_, **kwargs_)
        else:
            return Counts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_totalFreq(self): return self.totalFreq
    def set_totalFreq(self, totalFreq): self.totalFreq = totalFreq
    def get_missingFreq(self): return self.missingFreq
    def set_missingFreq(self, missingFreq): self.missingFreq = missingFreq
    def get_invalidFreq(self): return self.invalidFreq
    def set_invalidFreq(self, invalidFreq): self.invalidFreq = invalidFreq
    def get_cardinality(self): return self.cardinality
    def set_cardinality(self, cardinality): self.cardinality = cardinality
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Counts', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Counts')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Counts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Counts', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Counts'):
        if self.totalFreq is not None and 'totalFreq' not in already_processed:
            already_processed.add('totalFreq')
            outfile.write(' totalFreq=%s' % (quote_attrib(self.totalFreq), ))
        if self.missingFreq is not None and 'missingFreq' not in already_processed:
            already_processed.add('missingFreq')
            outfile.write(' missingFreq=%s' % (quote_attrib(self.missingFreq), ))
        if self.invalidFreq is not None and 'invalidFreq' not in already_processed:
            already_processed.add('invalidFreq')
            outfile.write(' invalidFreq=%s' % (quote_attrib(self.invalidFreq), ))
        if self.cardinality is not None and 'cardinality' not in already_processed:
            already_processed.add('cardinality')
            outfile.write(' cardinality="%s"' % self.gds_format_integer(self.cardinality, input_name='cardinality'))
    def exportChildren(self, outfile, level, namespace_='', name_='Counts', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Counts', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.totalFreq is not None:
            element.set('totalFreq', self.totalFreq)
        if self.missingFreq is not None:
            element.set('missingFreq', self.missingFreq)
        if self.invalidFreq is not None:
            element.set('invalidFreq', self.invalidFreq)
        if self.cardinality is not None:
            element.set('cardinality', self.gds_format_integer(self.cardinality))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Counts'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.totalFreq is not None and 'totalFreq' not in already_processed:
            already_processed.add('totalFreq')
            showIndent(outfile, level)
            outfile.write('totalFreq=%e,\n' % (self.totalFreq,))
        if self.missingFreq is not None and 'missingFreq' not in already_processed:
            already_processed.add('missingFreq')
            showIndent(outfile, level)
            outfile.write('missingFreq=%e,\n' % (self.missingFreq,))
        if self.invalidFreq is not None and 'invalidFreq' not in already_processed:
            already_processed.add('invalidFreq')
            showIndent(outfile, level)
            outfile.write('invalidFreq=%e,\n' % (self.invalidFreq,))
        if self.cardinality is not None and 'cardinality' not in already_processed:
            already_processed.add('cardinality')
            showIndent(outfile, level)
            outfile.write('cardinality=%d,\n' % (self.cardinality,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('totalFreq', node)
        if value is not None and 'totalFreq' not in already_processed:
            already_processed.add('totalFreq')
            try:
                self.totalFreq = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (totalFreq): %s' % exp)
            self.validate_NUMBER(self.totalFreq)    # validate type NUMBER
        value = find_attr_value_('missingFreq', node)
        if value is not None and 'missingFreq' not in already_processed:
            already_processed.add('missingFreq')
            try:
                self.missingFreq = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (missingFreq): %s' % exp)
            self.validate_NUMBER(self.missingFreq)    # validate type NUMBER
        value = find_attr_value_('invalidFreq', node)
        if value is not None and 'invalidFreq' not in already_processed:
            already_processed.add('invalidFreq')
            try:
                self.invalidFreq = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (invalidFreq): %s' % exp)
            self.validate_NUMBER(self.invalidFreq)    # validate type NUMBER
        value = find_attr_value_('cardinality', node)
        if value is not None and 'cardinality' not in already_processed:
            already_processed.add('cardinality')
            try:
                self.cardinality = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.cardinality < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Counts


class NumericInfo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, minimum=None, maximum=None, mean=None, standardDeviation=None, median=None, interQuartileRange=None, Extension=None, Quantile=None):
        self.original_tagname_ = None
        self.minimum = _cast(None, minimum)
        self.maximum = _cast(None, maximum)
        self.mean = _cast(None, mean)
        self.standardDeviation = _cast(None, standardDeviation)
        self.median = _cast(None, median)
        self.interQuartileRange = _cast(None, interQuartileRange)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Quantile is None:
            self.Quantile = []
        else:
            self.Quantile = Quantile
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumericInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumericInfo.subclass:
            return NumericInfo.subclass(*args_, **kwargs_)
        else:
            return NumericInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Quantile(self): return self.Quantile
    def set_Quantile(self, Quantile): self.Quantile = Quantile
    def add_Quantile(self, value): self.Quantile.append(value)
    def insert_Quantile_at(self, index, value): self.Quantile.insert(index, value)
    def replace_Quantile_at(self, index, value): self.Quantile[index] = value
    def get_minimum(self): return self.minimum
    def set_minimum(self, minimum): self.minimum = minimum
    def get_maximum(self): return self.maximum
    def set_maximum(self, maximum): self.maximum = maximum
    def get_mean(self): return self.mean
    def set_mean(self, mean): self.mean = mean
    def get_standardDeviation(self): return self.standardDeviation
    def set_standardDeviation(self, standardDeviation): self.standardDeviation = standardDeviation
    def get_median(self): return self.median
    def set_median(self, median): self.median = median
    def get_interQuartileRange(self): return self.interQuartileRange
    def set_interQuartileRange(self, interQuartileRange): self.interQuartileRange = interQuartileRange
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Quantile
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NumericInfo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NumericInfo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumericInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NumericInfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NumericInfo'):
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum=%s' % (quote_attrib(self.minimum), ))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum=%s' % (quote_attrib(self.maximum), ))
        if self.mean is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            outfile.write(' mean=%s' % (quote_attrib(self.mean), ))
        if self.standardDeviation is not None and 'standardDeviation' not in already_processed:
            already_processed.add('standardDeviation')
            outfile.write(' standardDeviation=%s' % (quote_attrib(self.standardDeviation), ))
        if self.median is not None and 'median' not in already_processed:
            already_processed.add('median')
            outfile.write(' median=%s' % (quote_attrib(self.median), ))
        if self.interQuartileRange is not None and 'interQuartileRange' not in already_processed:
            already_processed.add('interQuartileRange')
            outfile.write(' interQuartileRange=%s' % (quote_attrib(self.interQuartileRange), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NumericInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Quantile_ in self.Quantile:
            Quantile_.export(outfile, level, namespace_, name_='Quantile', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NumericInfo', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.minimum is not None:
            element.set('minimum', self.minimum)
        if self.maximum is not None:
            element.set('maximum', self.maximum)
        if self.mean is not None:
            element.set('mean', self.mean)
        if self.standardDeviation is not None:
            element.set('standardDeviation', self.standardDeviation)
        if self.median is not None:
            element.set('median', self.median)
        if self.interQuartileRange is not None:
            element.set('interQuartileRange', self.interQuartileRange)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Quantile_ in self.Quantile:
            Quantile_.to_etree(element, name_='Quantile', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NumericInfo'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            showIndent(outfile, level)
            outfile.write('minimum=%e,\n' % (self.minimum,))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            showIndent(outfile, level)
            outfile.write('maximum=%e,\n' % (self.maximum,))
        if self.mean is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            showIndent(outfile, level)
            outfile.write('mean=%e,\n' % (self.mean,))
        if self.standardDeviation is not None and 'standardDeviation' not in already_processed:
            already_processed.add('standardDeviation')
            showIndent(outfile, level)
            outfile.write('standardDeviation=%e,\n' % (self.standardDeviation,))
        if self.median is not None and 'median' not in already_processed:
            already_processed.add('median')
            showIndent(outfile, level)
            outfile.write('median=%e,\n' % (self.median,))
        if self.interQuartileRange is not None and 'interQuartileRange' not in already_processed:
            already_processed.add('interQuartileRange')
            showIndent(outfile, level)
            outfile.write('interQuartileRange=%e,\n' % (self.interQuartileRange,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Quantile=[\n')
        level += 1
        for Quantile_ in self.Quantile:
            showIndent(outfile, level)
            outfile.write('model_.Quantile(\n')
            Quantile_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            try:
                self.minimum = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (minimum): %s' % exp)
            self.validate_NUMBER(self.minimum)    # validate type NUMBER
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            try:
                self.maximum = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (maximum): %s' % exp)
            self.validate_NUMBER(self.maximum)    # validate type NUMBER
        value = find_attr_value_('mean', node)
        if value is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            try:
                self.mean = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (mean): %s' % exp)
            self.validate_NUMBER(self.mean)    # validate type NUMBER
        value = find_attr_value_('standardDeviation', node)
        if value is not None and 'standardDeviation' not in already_processed:
            already_processed.add('standardDeviation')
            try:
                self.standardDeviation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (standardDeviation): %s' % exp)
            self.validate_NUMBER(self.standardDeviation)    # validate type NUMBER
        value = find_attr_value_('median', node)
        if value is not None and 'median' not in already_processed:
            already_processed.add('median')
            try:
                self.median = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (median): %s' % exp)
            self.validate_NUMBER(self.median)    # validate type NUMBER
        value = find_attr_value_('interQuartileRange', node)
        if value is not None and 'interQuartileRange' not in already_processed:
            already_processed.add('interQuartileRange')
            try:
                self.interQuartileRange = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (interQuartileRange): %s' % exp)
            self.validate_NUMBER(self.interQuartileRange)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Quantile':
            obj_ = Quantile.factory()
            obj_.build(child_)
            self.Quantile.append(obj_)
            obj_.original_tagname_ = 'Quantile'
# end class NumericInfo


class Quantile(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, quantileLimit=None, quantileValue=None, Extension=None):
        self.original_tagname_ = None
        self.quantileLimit = _cast(None, quantileLimit)
        self.quantileValue = _cast(None, quantileValue)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Quantile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Quantile.subclass:
            return Quantile.subclass(*args_, **kwargs_)
        else:
            return Quantile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_quantileLimit(self): return self.quantileLimit
    def set_quantileLimit(self, quantileLimit): self.quantileLimit = quantileLimit
    def get_quantileValue(self): return self.quantileValue
    def set_quantileValue(self, quantileValue): self.quantileValue = quantileValue
    def validate_PERCENTAGE_NUMBER(self, value):
        # Validate type PERCENTAGE-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Quantile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Quantile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Quantile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Quantile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Quantile'):
        if self.quantileLimit is not None and 'quantileLimit' not in already_processed:
            already_processed.add('quantileLimit')
            outfile.write(' quantileLimit=%s' % (quote_attrib(self.quantileLimit), ))
        if self.quantileValue is not None and 'quantileValue' not in already_processed:
            already_processed.add('quantileValue')
            outfile.write(' quantileValue=%s' % (quote_attrib(self.quantileValue), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Quantile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Quantile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.quantileLimit is not None:
            element.set('quantileLimit', self.quantileLimit)
        if self.quantileValue is not None:
            element.set('quantileValue', self.quantileValue)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Quantile'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.quantileLimit is not None and 'quantileLimit' not in already_processed:
            already_processed.add('quantileLimit')
            showIndent(outfile, level)
            outfile.write('quantileLimit=%e,\n' % (self.quantileLimit,))
        if self.quantileValue is not None and 'quantileValue' not in already_processed:
            already_processed.add('quantileValue')
            showIndent(outfile, level)
            outfile.write('quantileValue=%e,\n' % (self.quantileValue,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quantileLimit', node)
        if value is not None and 'quantileLimit' not in already_processed:
            already_processed.add('quantileLimit')
            try:
                self.quantileLimit = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (quantileLimit): %s' % exp)
            self.validate_PERCENTAGE_NUMBER(self.quantileLimit)    # validate type PERCENTAGE-NUMBER
        value = find_attr_value_('quantileValue', node)
        if value is not None and 'quantileValue' not in already_processed:
            already_processed.add('quantileValue')
            try:
                self.quantileValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (quantileValue): %s' % exp)
            self.validate_NUMBER(self.quantileValue)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Quantile


class DiscrStats(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modalValue=None, Extension=None, Array=None):
        self.original_tagname_ = None
        self.modalValue = _cast(None, modalValue)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Array is None:
            self.Array = []
        else:
            self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiscrStats)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiscrStats.subclass:
            return DiscrStats.subclass(*args_, **kwargs_)
        else:
            return DiscrStats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def add_Array(self, value): self.Array.append(value)
    def insert_Array_at(self, index, value): self.Array.insert(index, value)
    def replace_Array_at(self, index, value): self.Array[index] = value
    def get_modalValue(self): return self.modalValue
    def set_modalValue(self, modalValue): self.modalValue = modalValue
    def hasContent_(self):
        if (
            self.Extension or
            self.Array
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiscrStats', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DiscrStats')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiscrStats')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DiscrStats', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiscrStats'):
        if self.modalValue is not None and 'modalValue' not in already_processed:
            already_processed.add('modalValue')
            outfile.write(' modalValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modalValue), input_name='modalValue')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DiscrStats', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Array_ in self.Array:
            Array_.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DiscrStats', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modalValue is not None:
            element.set('modalValue', self.gds_format_string(self.modalValue))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Array_ in self.Array:
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DiscrStats'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modalValue is not None and 'modalValue' not in already_processed:
            already_processed.add('modalValue')
            showIndent(outfile, level)
            outfile.write('modalValue="%s",\n' % (self.modalValue,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Array=[\n')
        level += 1
        for Array_ in self.Array:
            showIndent(outfile, level)
            outfile.write('model_.Array(\n')
            Array_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modalValue', node)
        if value is not None and 'modalValue' not in already_processed:
            already_processed.add('modalValue')
            self.modalValue = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array.append(obj_)
            obj_.original_tagname_ = 'Array'
# end class DiscrStats


class ContStats(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, totalValuesSum=None, totalSquaresSum=None, Extension=None, Interval=None, NUM_ARRAY=None):
        self.original_tagname_ = None
        self.totalValuesSum = _cast(None, totalValuesSum)
        self.totalSquaresSum = _cast(None, totalSquaresSum)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Interval is None:
            self.Interval = []
        else:
            self.Interval = Interval
        if NUM_ARRAY is None:
            self.NUM_ARRAY = []
        else:
            self.NUM_ARRAY = NUM_ARRAY
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContStats)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContStats.subclass:
            return ContStats.subclass(*args_, **kwargs_)
        else:
            return ContStats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Interval(self): return self.Interval
    def set_Interval(self, Interval): self.Interval = Interval
    def add_Interval(self, value): self.Interval.append(value)
    def insert_Interval_at(self, index, value): self.Interval.insert(index, value)
    def replace_Interval_at(self, index, value): self.Interval[index] = value
    def get_NUM_ARRAY(self): return self.NUM_ARRAY
    def set_NUM_ARRAY(self, NUM_ARRAY): self.NUM_ARRAY = NUM_ARRAY
    def add_NUM_ARRAY(self, value): self.NUM_ARRAY.append(value)
    def insert_NUM_ARRAY_at(self, index, value): self.NUM_ARRAY.insert(index, value)
    def replace_NUM_ARRAY_at(self, index, value): self.NUM_ARRAY[index] = value
    def get_totalValuesSum(self): return self.totalValuesSum
    def set_totalValuesSum(self, totalValuesSum): self.totalValuesSum = totalValuesSum
    def get_totalSquaresSum(self): return self.totalSquaresSum
    def set_totalSquaresSum(self, totalSquaresSum): self.totalSquaresSum = totalSquaresSum
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Interval or
            self.NUM_ARRAY
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContStats', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContStats')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContStats')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContStats', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContStats'):
        if self.totalValuesSum is not None and 'totalValuesSum' not in already_processed:
            already_processed.add('totalValuesSum')
            outfile.write(' totalValuesSum=%s' % (quote_attrib(self.totalValuesSum), ))
        if self.totalSquaresSum is not None and 'totalSquaresSum' not in already_processed:
            already_processed.add('totalSquaresSum')
            outfile.write(' totalSquaresSum=%s' % (quote_attrib(self.totalSquaresSum), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ContStats', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Interval_ in self.Interval:
            Interval_.export(outfile, level, namespace_, name_='Interval', pretty_print=pretty_print)
        for NUM_ARRAY_ in self.NUM_ARRAY:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNUM-ARRAY>%s</%sNUM-ARRAY>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(NUM_ARRAY_), input_name='NUM-ARRAY')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='ContStats', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.totalValuesSum is not None:
            element.set('totalValuesSum', self.totalValuesSum)
        if self.totalSquaresSum is not None:
            element.set('totalSquaresSum', self.totalSquaresSum)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Interval_ in self.Interval:
            Interval_.to_etree(element, name_='Interval', mapping_=mapping_)
        for NUM_ARRAY_ in self.NUM_ARRAY:
            etree_.SubElement(element, '{http://www.dmg.org/PMML-4_4}NUM-ARRAY').text = self.gds_format_string(NUM_ARRAY_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ContStats'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.totalValuesSum is not None and 'totalValuesSum' not in already_processed:
            already_processed.add('totalValuesSum')
            showIndent(outfile, level)
            outfile.write('totalValuesSum=%e,\n' % (self.totalValuesSum,))
        if self.totalSquaresSum is not None and 'totalSquaresSum' not in already_processed:
            already_processed.add('totalSquaresSum')
            showIndent(outfile, level)
            outfile.write('totalSquaresSum=%e,\n' % (self.totalSquaresSum,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Interval=[\n')
        level += 1
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('model_.Interval(\n')
            Interval_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NUM_ARRAY=[\n')
        level += 1
        for NUM_ARRAY_ in self.NUM_ARRAY:
            showIndent(outfile, level)
            outfile.write('%s,\n' % self.gds_encode(quote_python(NUM_ARRAY_)))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('totalValuesSum', node)
        if value is not None and 'totalValuesSum' not in already_processed:
            already_processed.add('totalValuesSum')
            try:
                self.totalValuesSum = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (totalValuesSum): %s' % exp)
            self.validate_NUMBER(self.totalValuesSum)    # validate type NUMBER
        value = find_attr_value_('totalSquaresSum', node)
        if value is not None and 'totalSquaresSum' not in already_processed:
            already_processed.add('totalSquaresSum')
            try:
                self.totalSquaresSum = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (totalSquaresSum): %s' % exp)
            self.validate_NUMBER(self.totalSquaresSum)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Interval':
            obj_ = Interval.factory()
            obj_.build(child_)
            self.Interval.append(obj_)
            obj_.original_tagname_ = 'Interval'
        elif nodeName_ == 'NUM-ARRAY':
            NUM_ARRAY_ = child_.text
            NUM_ARRAY_ = self.gds_validate_string(NUM_ARRAY_, node, 'NUM_ARRAY')
            self.NUM_ARRAY.append(NUM_ARRAY_)
# end class ContStats


class MultivariateStats(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, targetCategory=None, Extension=None, MultivariateStat=None):
        self.original_tagname_ = None
        self.targetCategory = _cast(None, targetCategory)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if MultivariateStat is None:
            self.MultivariateStat = []
        else:
            self.MultivariateStat = MultivariateStat
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MultivariateStats)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MultivariateStats.subclass:
            return MultivariateStats.subclass(*args_, **kwargs_)
        else:
            return MultivariateStats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_MultivariateStat(self): return self.MultivariateStat
    def set_MultivariateStat(self, MultivariateStat): self.MultivariateStat = MultivariateStat
    def add_MultivariateStat(self, value): self.MultivariateStat.append(value)
    def insert_MultivariateStat_at(self, index, value): self.MultivariateStat.insert(index, value)
    def replace_MultivariateStat_at(self, index, value): self.MultivariateStat[index] = value
    def get_targetCategory(self): return self.targetCategory
    def set_targetCategory(self, targetCategory): self.targetCategory = targetCategory
    def hasContent_(self):
        if (
            self.Extension or
            self.MultivariateStat
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MultivariateStats', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MultivariateStats')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultivariateStats')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MultivariateStats', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultivariateStats'):
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            outfile.write(' targetCategory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetCategory), input_name='targetCategory')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MultivariateStats', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for MultivariateStat_ in self.MultivariateStat:
            MultivariateStat_.export(outfile, level, namespace_, name_='MultivariateStat', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MultivariateStats', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.targetCategory is not None:
            element.set('targetCategory', self.gds_format_string(self.targetCategory))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for MultivariateStat_ in self.MultivariateStat:
            MultivariateStat_.to_etree(element, name_='MultivariateStat', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MultivariateStats'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            showIndent(outfile, level)
            outfile.write('targetCategory="%s",\n' % (self.targetCategory,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MultivariateStat=[\n')
        level += 1
        for MultivariateStat_ in self.MultivariateStat:
            showIndent(outfile, level)
            outfile.write('model_.MultivariateStat(\n')
            MultivariateStat_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('targetCategory', node)
        if value is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            self.targetCategory = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'MultivariateStat':
            obj_ = MultivariateStat.factory()
            obj_.build(child_)
            self.MultivariateStat.append(obj_)
            obj_.original_tagname_ = 'MultivariateStat'
# end class MultivariateStats


class MultivariateStat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, category=None, exponent='1', isIntercept=False, importance=None, stdError=None, tValue=None, chiSquareValue=None, fStatistic=None, dF=None, pValueAlpha=None, pValueInitial=None, pValueFinal=None, confidenceLevel='0.95', confidenceLowerBound=None, confidenceUpperBound=None, Extension=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.category = _cast(None, category)
        self.exponent = _cast(None, exponent)
        self.isIntercept = _cast(bool, isIntercept)
        self.importance = _cast(None, importance)
        self.stdError = _cast(None, stdError)
        self.tValue = _cast(None, tValue)
        self.chiSquareValue = _cast(None, chiSquareValue)
        self.fStatistic = _cast(None, fStatistic)
        self.dF = _cast(None, dF)
        self.pValueAlpha = _cast(None, pValueAlpha)
        self.pValueInitial = _cast(None, pValueInitial)
        self.pValueFinal = _cast(None, pValueFinal)
        self.confidenceLevel = _cast(None, confidenceLevel)
        self.confidenceLowerBound = _cast(None, confidenceLowerBound)
        self.confidenceUpperBound = _cast(None, confidenceUpperBound)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MultivariateStat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MultivariateStat.subclass:
            return MultivariateStat.subclass(*args_, **kwargs_)
        else:
            return MultivariateStat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_exponent(self): return self.exponent
    def set_exponent(self, exponent): self.exponent = exponent
    def get_isIntercept(self): return self.isIntercept
    def set_isIntercept(self, isIntercept): self.isIntercept = isIntercept
    def get_importance(self): return self.importance
    def set_importance(self, importance): self.importance = importance
    def get_stdError(self): return self.stdError
    def set_stdError(self, stdError): self.stdError = stdError
    def get_tValue(self): return self.tValue
    def set_tValue(self, tValue): self.tValue = tValue
    def get_chiSquareValue(self): return self.chiSquareValue
    def set_chiSquareValue(self, chiSquareValue): self.chiSquareValue = chiSquareValue
    def get_fStatistic(self): return self.fStatistic
    def set_fStatistic(self, fStatistic): self.fStatistic = fStatistic
    def get_dF(self): return self.dF
    def set_dF(self, dF): self.dF = dF
    def get_pValueAlpha(self): return self.pValueAlpha
    def set_pValueAlpha(self, pValueAlpha): self.pValueAlpha = pValueAlpha
    def get_pValueInitial(self): return self.pValueInitial
    def set_pValueInitial(self, pValueInitial): self.pValueInitial = pValueInitial
    def get_pValueFinal(self): return self.pValueFinal
    def set_pValueFinal(self, pValueFinal): self.pValueFinal = pValueFinal
    def get_confidenceLevel(self): return self.confidenceLevel
    def set_confidenceLevel(self, confidenceLevel): self.confidenceLevel = confidenceLevel
    def get_confidenceLowerBound(self): return self.confidenceLowerBound
    def set_confidenceLowerBound(self, confidenceLowerBound): self.confidenceLowerBound = confidenceLowerBound
    def get_confidenceUpperBound(self): return self.confidenceUpperBound
    def set_confidenceUpperBound(self, confidenceUpperBound): self.confidenceUpperBound = confidenceUpperBound
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MultivariateStat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MultivariateStat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultivariateStat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MultivariateStat', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultivariateStat'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.category), input_name='category')), ))
        if self.exponent != 1 and 'exponent' not in already_processed:
            already_processed.add('exponent')
            outfile.write(' exponent=%s' % (quote_attrib(self.exponent), ))
        if self.isIntercept and 'isIntercept' not in already_processed:
            already_processed.add('isIntercept')
            outfile.write(' isIntercept="%s"' % self.gds_format_boolean(self.isIntercept, input_name='isIntercept'))
        if self.importance is not None and 'importance' not in already_processed:
            already_processed.add('importance')
            outfile.write(' importance=%s' % (quote_attrib(self.importance), ))
        if self.stdError is not None and 'stdError' not in already_processed:
            already_processed.add('stdError')
            outfile.write(' stdError=%s' % (quote_attrib(self.stdError), ))
        if self.tValue is not None and 'tValue' not in already_processed:
            already_processed.add('tValue')
            outfile.write(' tValue=%s' % (quote_attrib(self.tValue), ))
        if self.chiSquareValue is not None and 'chiSquareValue' not in already_processed:
            already_processed.add('chiSquareValue')
            outfile.write(' chiSquareValue=%s' % (quote_attrib(self.chiSquareValue), ))
        if self.fStatistic is not None and 'fStatistic' not in already_processed:
            already_processed.add('fStatistic')
            outfile.write(' fStatistic=%s' % (quote_attrib(self.fStatistic), ))
        if self.dF is not None and 'dF' not in already_processed:
            already_processed.add('dF')
            outfile.write(' dF=%s' % (quote_attrib(self.dF), ))
        if self.pValueAlpha is not None and 'pValueAlpha' not in already_processed:
            already_processed.add('pValueAlpha')
            outfile.write(' pValueAlpha=%s' % (quote_attrib(self.pValueAlpha), ))
        if self.pValueInitial is not None and 'pValueInitial' not in already_processed:
            already_processed.add('pValueInitial')
            outfile.write(' pValueInitial=%s' % (quote_attrib(self.pValueInitial), ))
        if self.pValueFinal is not None and 'pValueFinal' not in already_processed:
            already_processed.add('pValueFinal')
            outfile.write(' pValueFinal=%s' % (quote_attrib(self.pValueFinal), ))
        if self.confidenceLevel != 0.95 and 'confidenceLevel' not in already_processed:
            already_processed.add('confidenceLevel')
            outfile.write(' confidenceLevel=%s' % (quote_attrib(self.confidenceLevel), ))
        if self.confidenceLowerBound is not None and 'confidenceLowerBound' not in already_processed:
            already_processed.add('confidenceLowerBound')
            outfile.write(' confidenceLowerBound=%s' % (quote_attrib(self.confidenceLowerBound), ))
        if self.confidenceUpperBound is not None and 'confidenceUpperBound' not in already_processed:
            already_processed.add('confidenceUpperBound')
            outfile.write(' confidenceUpperBound=%s' % (quote_attrib(self.confidenceUpperBound), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MultivariateStat', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MultivariateStat', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.category is not None:
            element.set('category', self.gds_format_string(self.category))
        if self.exponent is not None:
            element.set('exponent', self.exponent)
        if self.isIntercept is not None:
            element.set('isIntercept', self.gds_format_boolean(self.isIntercept))
        if self.importance is not None:
            element.set('importance', self.importance)
        if self.stdError is not None:
            element.set('stdError', self.stdError)
        if self.tValue is not None:
            element.set('tValue', self.tValue)
        if self.chiSquareValue is not None:
            element.set('chiSquareValue', self.chiSquareValue)
        if self.fStatistic is not None:
            element.set('fStatistic', self.fStatistic)
        if self.dF is not None:
            element.set('dF', self.dF)
        if self.pValueAlpha is not None:
            element.set('pValueAlpha', self.pValueAlpha)
        if self.pValueInitial is not None:
            element.set('pValueInitial', self.pValueInitial)
        if self.pValueFinal is not None:
            element.set('pValueFinal', self.pValueFinal)
        if self.confidenceLevel is not None:
            element.set('confidenceLevel', self.confidenceLevel)
        if self.confidenceLowerBound is not None:
            element.set('confidenceLowerBound', self.confidenceLowerBound)
        if self.confidenceUpperBound is not None:
            element.set('confidenceUpperBound', self.confidenceUpperBound)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MultivariateStat'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            showIndent(outfile, level)
            outfile.write('category="%s",\n' % (self.category,))
        if self.exponent is not None and 'exponent' not in already_processed:
            already_processed.add('exponent')
            showIndent(outfile, level)
            outfile.write('exponent=%d,\n' % (self.exponent,))
        if self.isIntercept is not None and 'isIntercept' not in already_processed:
            already_processed.add('isIntercept')
            showIndent(outfile, level)
            outfile.write('isIntercept=%s,\n' % (self.isIntercept,))
        if self.importance is not None and 'importance' not in already_processed:
            already_processed.add('importance')
            showIndent(outfile, level)
            outfile.write('importance=%e,\n' % (self.importance,))
        if self.stdError is not None and 'stdError' not in already_processed:
            already_processed.add('stdError')
            showIndent(outfile, level)
            outfile.write('stdError=%e,\n' % (self.stdError,))
        if self.tValue is not None and 'tValue' not in already_processed:
            already_processed.add('tValue')
            showIndent(outfile, level)
            outfile.write('tValue=%e,\n' % (self.tValue,))
        if self.chiSquareValue is not None and 'chiSquareValue' not in already_processed:
            already_processed.add('chiSquareValue')
            showIndent(outfile, level)
            outfile.write('chiSquareValue=%e,\n' % (self.chiSquareValue,))
        if self.fStatistic is not None and 'fStatistic' not in already_processed:
            already_processed.add('fStatistic')
            showIndent(outfile, level)
            outfile.write('fStatistic=%e,\n' % (self.fStatistic,))
        if self.dF is not None and 'dF' not in already_processed:
            already_processed.add('dF')
            showIndent(outfile, level)
            outfile.write('dF=%e,\n' % (self.dF,))
        if self.pValueAlpha is not None and 'pValueAlpha' not in already_processed:
            already_processed.add('pValueAlpha')
            showIndent(outfile, level)
            outfile.write('pValueAlpha=%e,\n' % (self.pValueAlpha,))
        if self.pValueInitial is not None and 'pValueInitial' not in already_processed:
            already_processed.add('pValueInitial')
            showIndent(outfile, level)
            outfile.write('pValueInitial=%e,\n' % (self.pValueInitial,))
        if self.pValueFinal is not None and 'pValueFinal' not in already_processed:
            already_processed.add('pValueFinal')
            showIndent(outfile, level)
            outfile.write('pValueFinal=%e,\n' % (self.pValueFinal,))
        if self.confidenceLevel is not None and 'confidenceLevel' not in already_processed:
            already_processed.add('confidenceLevel')
            showIndent(outfile, level)
            outfile.write('confidenceLevel=%e,\n' % (self.confidenceLevel,))
        if self.confidenceLowerBound is not None and 'confidenceLowerBound' not in already_processed:
            already_processed.add('confidenceLowerBound')
            showIndent(outfile, level)
            outfile.write('confidenceLowerBound=%e,\n' % (self.confidenceLowerBound,))
        if self.confidenceUpperBound is not None and 'confidenceUpperBound' not in already_processed:
            already_processed.add('confidenceUpperBound')
            showIndent(outfile, level)
            outfile.write('confidenceUpperBound=%e,\n' % (self.confidenceUpperBound,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
        value = find_attr_value_('exponent', node)
        if value is not None and 'exponent' not in already_processed:
            already_processed.add('exponent')
            try:
                self.exponent = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.exponent)    # validate type INT-NUMBER
        value = find_attr_value_('isIntercept', node)
        if value is not None and 'isIntercept' not in already_processed:
            already_processed.add('isIntercept')
            if value in ('true', '1'):
                self.isIntercept = True
            elif value in ('false', '0'):
                self.isIntercept = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('importance', node)
        if value is not None and 'importance' not in already_processed:
            already_processed.add('importance')
            try:
                self.importance = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (importance): %s' % exp)
            self.validate_PROB_NUMBER(self.importance)    # validate type PROB-NUMBER
        value = find_attr_value_('stdError', node)
        if value is not None and 'stdError' not in already_processed:
            already_processed.add('stdError')
            try:
                self.stdError = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (stdError): %s' % exp)
            self.validate_NUMBER(self.stdError)    # validate type NUMBER
        value = find_attr_value_('tValue', node)
        if value is not None and 'tValue' not in already_processed:
            already_processed.add('tValue')
            try:
                self.tValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (tValue): %s' % exp)
            self.validate_NUMBER(self.tValue)    # validate type NUMBER
        value = find_attr_value_('chiSquareValue', node)
        if value is not None and 'chiSquareValue' not in already_processed:
            already_processed.add('chiSquareValue')
            try:
                self.chiSquareValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (chiSquareValue): %s' % exp)
            self.validate_NUMBER(self.chiSquareValue)    # validate type NUMBER
        value = find_attr_value_('fStatistic', node)
        if value is not None and 'fStatistic' not in already_processed:
            already_processed.add('fStatistic')
            try:
                self.fStatistic = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (fStatistic): %s' % exp)
            self.validate_NUMBER(self.fStatistic)    # validate type NUMBER
        value = find_attr_value_('dF', node)
        if value is not None and 'dF' not in already_processed:
            already_processed.add('dF')
            try:
                self.dF = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (dF): %s' % exp)
            self.validate_NUMBER(self.dF)    # validate type NUMBER
        value = find_attr_value_('pValueAlpha', node)
        if value is not None and 'pValueAlpha' not in already_processed:
            already_processed.add('pValueAlpha')
            try:
                self.pValueAlpha = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pValueAlpha): %s' % exp)
            self.validate_PROB_NUMBER(self.pValueAlpha)    # validate type PROB-NUMBER
        value = find_attr_value_('pValueInitial', node)
        if value is not None and 'pValueInitial' not in already_processed:
            already_processed.add('pValueInitial')
            try:
                self.pValueInitial = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pValueInitial): %s' % exp)
            self.validate_PROB_NUMBER(self.pValueInitial)    # validate type PROB-NUMBER
        value = find_attr_value_('pValueFinal', node)
        if value is not None and 'pValueFinal' not in already_processed:
            already_processed.add('pValueFinal')
            try:
                self.pValueFinal = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pValueFinal): %s' % exp)
            self.validate_PROB_NUMBER(self.pValueFinal)    # validate type PROB-NUMBER
        value = find_attr_value_('confidenceLevel', node)
        if value is not None and 'confidenceLevel' not in already_processed:
            already_processed.add('confidenceLevel')
            try:
                self.confidenceLevel = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (confidenceLevel): %s' % exp)
            self.validate_PROB_NUMBER(self.confidenceLevel)    # validate type PROB-NUMBER
        value = find_attr_value_('confidenceLowerBound', node)
        if value is not None and 'confidenceLowerBound' not in already_processed:
            already_processed.add('confidenceLowerBound')
            try:
                self.confidenceLowerBound = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (confidenceLowerBound): %s' % exp)
            self.validate_NUMBER(self.confidenceLowerBound)    # validate type NUMBER
        value = find_attr_value_('confidenceUpperBound', node)
        if value is not None and 'confidenceUpperBound' not in already_processed:
            already_processed.add('confidenceUpperBound')
            try:
                self.confidenceUpperBound = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (confidenceUpperBound): %s' % exp)
            self.validate_NUMBER(self.confidenceUpperBound)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class MultivariateStat


class Anova(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, target=None, Extension=None, AnovaRow=None):
        self.original_tagname_ = None
        self.target = _cast(None, target)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if AnovaRow is None:
            self.AnovaRow = []
        else:
            self.AnovaRow = AnovaRow
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Anova)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Anova.subclass:
            return Anova.subclass(*args_, **kwargs_)
        else:
            return Anova(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_AnovaRow(self): return self.AnovaRow
    def set_AnovaRow(self, AnovaRow): self.AnovaRow = AnovaRow
    def add_AnovaRow(self, value): self.AnovaRow.append(value)
    def insert_AnovaRow_at(self, index, value): self.AnovaRow.insert(index, value)
    def replace_AnovaRow_at(self, index, value): self.AnovaRow[index] = value
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.AnovaRow
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Anova', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Anova')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Anova')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Anova', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Anova'):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (quote_attrib(self.target), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Anova', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for AnovaRow_ in self.AnovaRow:
            AnovaRow_.export(outfile, level, namespace_, name_='AnovaRow', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Anova', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.target is not None:
            element.set('target', self.target)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for AnovaRow_ in self.AnovaRow:
            AnovaRow_.to_etree(element, name_='AnovaRow', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Anova'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            showIndent(outfile, level)
            outfile.write('target="%s",\n' % (self.target,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AnovaRow=[\n')
        level += 1
        for AnovaRow_ in self.AnovaRow:
            showIndent(outfile, level)
            outfile.write('model_.AnovaRow(\n')
            AnovaRow_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
            self.validate_FIELD_NAME(self.target)    # validate type FIELD-NAME
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'AnovaRow':
            obj_ = AnovaRow.factory()
            obj_.build(child_)
            self.AnovaRow.append(obj_)
            obj_.original_tagname_ = 'AnovaRow'
# end class Anova


class AnovaRow(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, sumOfSquares=None, degreesOfFreedom=None, meanOfSquares=None, fValue=None, pValue=None, Extension=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.sumOfSquares = _cast(None, sumOfSquares)
        self.degreesOfFreedom = _cast(None, degreesOfFreedom)
        self.meanOfSquares = _cast(None, meanOfSquares)
        self.fValue = _cast(None, fValue)
        self.pValue = _cast(None, pValue)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnovaRow)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnovaRow.subclass:
            return AnovaRow.subclass(*args_, **kwargs_)
        else:
            return AnovaRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_sumOfSquares(self): return self.sumOfSquares
    def set_sumOfSquares(self, sumOfSquares): self.sumOfSquares = sumOfSquares
    def get_degreesOfFreedom(self): return self.degreesOfFreedom
    def set_degreesOfFreedom(self, degreesOfFreedom): self.degreesOfFreedom = degreesOfFreedom
    def get_meanOfSquares(self): return self.meanOfSquares
    def set_meanOfSquares(self, meanOfSquares): self.meanOfSquares = meanOfSquares
    def get_fValue(self): return self.fValue
    def set_fValue(self, fValue): self.fValue = fValue
    def get_pValue(self): return self.pValue
    def set_pValue(self, pValue): self.pValue = pValue
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AnovaRow', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AnovaRow')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnovaRow')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AnovaRow', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AnovaRow'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.sumOfSquares is not None and 'sumOfSquares' not in already_processed:
            already_processed.add('sumOfSquares')
            outfile.write(' sumOfSquares=%s' % (quote_attrib(self.sumOfSquares), ))
        if self.degreesOfFreedom is not None and 'degreesOfFreedom' not in already_processed:
            already_processed.add('degreesOfFreedom')
            outfile.write(' degreesOfFreedom=%s' % (quote_attrib(self.degreesOfFreedom), ))
        if self.meanOfSquares is not None and 'meanOfSquares' not in already_processed:
            already_processed.add('meanOfSquares')
            outfile.write(' meanOfSquares=%s' % (quote_attrib(self.meanOfSquares), ))
        if self.fValue is not None and 'fValue' not in already_processed:
            already_processed.add('fValue')
            outfile.write(' fValue=%s' % (quote_attrib(self.fValue), ))
        if self.pValue is not None and 'pValue' not in already_processed:
            already_processed.add('pValue')
            outfile.write(' pValue=%s' % (quote_attrib(self.pValue), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AnovaRow', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AnovaRow', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.sumOfSquares is not None:
            element.set('sumOfSquares', self.sumOfSquares)
        if self.degreesOfFreedom is not None:
            element.set('degreesOfFreedom', self.degreesOfFreedom)
        if self.meanOfSquares is not None:
            element.set('meanOfSquares', self.meanOfSquares)
        if self.fValue is not None:
            element.set('fValue', self.fValue)
        if self.pValue is not None:
            element.set('pValue', self.pValue)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='AnovaRow'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.sumOfSquares is not None and 'sumOfSquares' not in already_processed:
            already_processed.add('sumOfSquares')
            showIndent(outfile, level)
            outfile.write('sumOfSquares=%e,\n' % (self.sumOfSquares,))
        if self.degreesOfFreedom is not None and 'degreesOfFreedom' not in already_processed:
            already_processed.add('degreesOfFreedom')
            showIndent(outfile, level)
            outfile.write('degreesOfFreedom=%e,\n' % (self.degreesOfFreedom,))
        if self.meanOfSquares is not None and 'meanOfSquares' not in already_processed:
            already_processed.add('meanOfSquares')
            showIndent(outfile, level)
            outfile.write('meanOfSquares=%e,\n' % (self.meanOfSquares,))
        if self.fValue is not None and 'fValue' not in already_processed:
            already_processed.add('fValue')
            showIndent(outfile, level)
            outfile.write('fValue=%e,\n' % (self.fValue,))
        if self.pValue is not None and 'pValue' not in already_processed:
            already_processed.add('pValue')
            showIndent(outfile, level)
            outfile.write('pValue=%e,\n' % (self.pValue,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('sumOfSquares', node)
        if value is not None and 'sumOfSquares' not in already_processed:
            already_processed.add('sumOfSquares')
            try:
                self.sumOfSquares = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sumOfSquares): %s' % exp)
            self.validate_NUMBER(self.sumOfSquares)    # validate type NUMBER
        value = find_attr_value_('degreesOfFreedom', node)
        if value is not None and 'degreesOfFreedom' not in already_processed:
            already_processed.add('degreesOfFreedom')
            try:
                self.degreesOfFreedom = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (degreesOfFreedom): %s' % exp)
            self.validate_NUMBER(self.degreesOfFreedom)    # validate type NUMBER
        value = find_attr_value_('meanOfSquares', node)
        if value is not None and 'meanOfSquares' not in already_processed:
            already_processed.add('meanOfSquares')
            try:
                self.meanOfSquares = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (meanOfSquares): %s' % exp)
            self.validate_NUMBER(self.meanOfSquares)    # validate type NUMBER
        value = find_attr_value_('fValue', node)
        if value is not None and 'fValue' not in already_processed:
            already_processed.add('fValue')
            try:
                self.fValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (fValue): %s' % exp)
            self.validate_NUMBER(self.fValue)    # validate type NUMBER
        value = find_attr_value_('pValue', node)
        if value is not None and 'pValue' not in already_processed:
            already_processed.add('pValue')
            try:
                self.pValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pValue): %s' % exp)
            self.validate_PROB_NUMBER(self.pValue)    # validate type PROB-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class AnovaRow


class Partition(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, size=None, Extension=None, PartitionFieldStats=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.size = _cast(None, size)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if PartitionFieldStats is None:
            self.PartitionFieldStats = []
        else:
            self.PartitionFieldStats = PartitionFieldStats
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Partition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Partition.subclass:
            return Partition.subclass(*args_, **kwargs_)
        else:
            return Partition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_PartitionFieldStats(self): return self.PartitionFieldStats
    def set_PartitionFieldStats(self, PartitionFieldStats): self.PartitionFieldStats = PartitionFieldStats
    def add_PartitionFieldStats(self, value): self.PartitionFieldStats.append(value)
    def insert_PartitionFieldStats_at(self, index, value): self.PartitionFieldStats.insert(index, value)
    def replace_PartitionFieldStats_at(self, index, value): self.PartitionFieldStats[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.PartitionFieldStats
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Partition', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Partition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Partition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Partition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Partition'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (quote_attrib(self.size), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Partition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for PartitionFieldStats_ in self.PartitionFieldStats:
            PartitionFieldStats_.export(outfile, level, namespace_, name_='PartitionFieldStats', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Partition', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.size is not None:
            element.set('size', self.size)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for PartitionFieldStats_ in self.PartitionFieldStats:
            PartitionFieldStats_.to_etree(element, name_='PartitionFieldStats', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Partition'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            showIndent(outfile, level)
            outfile.write('size=%e,\n' % (self.size,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PartitionFieldStats=[\n')
        level += 1
        for PartitionFieldStats_ in self.PartitionFieldStats:
            showIndent(outfile, level)
            outfile.write('model_.PartitionFieldStats(\n')
            PartitionFieldStats_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            try:
                self.size = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (size): %s' % exp)
            self.validate_NUMBER(self.size)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'PartitionFieldStats':
            obj_ = PartitionFieldStats.factory()
            obj_.build(child_)
            self.PartitionFieldStats.append(obj_)
            obj_.original_tagname_ = 'PartitionFieldStats'
# end class Partition


class PartitionFieldStats(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, weighted='0', Extension=None, Counts=None, NumericInfo=None, Array=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.weighted = _cast(None, weighted)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Counts = Counts
        self.NumericInfo = NumericInfo
        if Array is None:
            self.Array = []
        else:
            self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartitionFieldStats)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartitionFieldStats.subclass:
            return PartitionFieldStats.subclass(*args_, **kwargs_)
        else:
            return PartitionFieldStats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Counts(self): return self.Counts
    def set_Counts(self, Counts): self.Counts = Counts
    def get_NumericInfo(self): return self.NumericInfo
    def set_NumericInfo(self, NumericInfo): self.NumericInfo = NumericInfo
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def add_Array(self, value): self.Array.append(value)
    def insert_Array_at(self, index, value): self.Array.insert(index, value)
    def replace_Array_at(self, index, value): self.Array[index] = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_weighted(self): return self.weighted
    def set_weighted(self, weighted): self.weighted = weighted
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Counts is not None or
            self.NumericInfo is not None or
            self.Array
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PartitionFieldStats', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PartitionFieldStats')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartitionFieldStats')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PartitionFieldStats', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartitionFieldStats'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.weighted != "0" and 'weighted' not in already_processed:
            already_processed.add('weighted')
            outfile.write(' weighted=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.weighted), input_name='weighted')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartitionFieldStats', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Counts is not None:
            self.Counts.export(outfile, level, namespace_, name_='Counts', pretty_print=pretty_print)
        if self.NumericInfo is not None:
            self.NumericInfo.export(outfile, level, namespace_, name_='NumericInfo', pretty_print=pretty_print)
        for Array_ in self.Array:
            Array_.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PartitionFieldStats', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.weighted is not None:
            element.set('weighted', self.gds_format_string(self.weighted))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Counts is not None:
            Counts_ = self.Counts
            Counts_.to_etree(element, name_='Counts', mapping_=mapping_)
        if self.NumericInfo is not None:
            NumericInfo_ = self.NumericInfo
            NumericInfo_.to_etree(element, name_='NumericInfo', mapping_=mapping_)
        for Array_ in self.Array:
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PartitionFieldStats'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.weighted is not None and 'weighted' not in already_processed:
            already_processed.add('weighted')
            showIndent(outfile, level)
            outfile.write('weighted="%s",\n' % (self.weighted,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Counts is not None:
            showIndent(outfile, level)
            outfile.write('Counts=model_.Counts(\n')
            self.Counts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NumericInfo is not None:
            showIndent(outfile, level)
            outfile.write('NumericInfo=model_.NumericInfo(\n')
            self.NumericInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Array=[\n')
        level += 1
        for Array_ in self.Array:
            showIndent(outfile, level)
            outfile.write('model_.Array(\n')
            Array_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('weighted', node)
        if value is not None and 'weighted' not in already_processed:
            already_processed.add('weighted')
            self.weighted = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Counts':
            obj_ = Counts.factory()
            obj_.build(child_)
            self.Counts = obj_
            obj_.original_tagname_ = 'Counts'
        elif nodeName_ == 'NumericInfo':
            obj_ = NumericInfo.factory()
            obj_.build(child_)
            self.NumericInfo = obj_
            obj_.original_tagname_ = 'NumericInfo'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array.append(obj_)
            obj_.original_tagname_ = 'Array'
# end class PartitionFieldStats


class AnomalyDetectionModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, algorithmName=None, functionName=None, algorithmType=None, sampleDataSize=None, isScorable=True, MiningSchema=None, Output=None, LocalTransformations=None, ModelVerification=None, AnomalyDetectionModel_member=None, AssociationModel=None, BayesianNetworkModel=None, BaselineModel=None, ClusteringModel=None, GaussianProcessModel=None, GeneralRegressionModel=None, MiningModel=None, NaiveBayesModel=None, NearestNeighborModel=None, NeuralNetwork=None, RegressionModel=None, RuleSetModel=None, SequenceModel=None, Scorecard=None, SupportVectorMachineModel=None, TextModel=None, TimeSeriesModel=None, TreeModel=None, MeanClusterDistances=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.algorithmName = _cast(None, algorithmName)
        self.functionName = _cast(None, functionName)
        self.algorithmType = _cast(None, algorithmType)
        self.sampleDataSize = _cast(None, sampleDataSize)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.LocalTransformations = LocalTransformations
        self.ModelVerification = ModelVerification
        self.AnomalyDetectionModel = AnomalyDetectionModel_member
        self.AssociationModel = AssociationModel
        self.BayesianNetworkModel = BayesianNetworkModel
        self.BaselineModel = BaselineModel
        self.ClusteringModel = ClusteringModel
        self.GaussianProcessModel = GaussianProcessModel
        self.GeneralRegressionModel = GeneralRegressionModel
        self.MiningModel = MiningModel
        self.NaiveBayesModel = NaiveBayesModel
        self.NearestNeighborModel = NearestNeighborModel
        self.NeuralNetwork = NeuralNetwork
        self.RegressionModel = RegressionModel
        self.RuleSetModel = RuleSetModel
        self.SequenceModel = SequenceModel
        self.Scorecard = Scorecard
        self.SupportVectorMachineModel = SupportVectorMachineModel
        self.TextModel = TextModel
        self.TimeSeriesModel = TimeSeriesModel
        self.TreeModel = TreeModel
        self.MeanClusterDistances = MeanClusterDistances
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnomalyDetectionModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnomalyDetectionModel.subclass:
            return AnomalyDetectionModel.subclass(*args_, **kwargs_)
        else:
            return AnomalyDetectionModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_AnomalyDetectionModel(self): return self.AnomalyDetectionModel
    def set_AnomalyDetectionModel(self, AnomalyDetectionModel): self.AnomalyDetectionModel = AnomalyDetectionModel
    def get_AssociationModel(self): return self.AssociationModel
    def set_AssociationModel(self, AssociationModel): self.AssociationModel = AssociationModel
    def get_BayesianNetworkModel(self): return self.BayesianNetworkModel
    def set_BayesianNetworkModel(self, BayesianNetworkModel): self.BayesianNetworkModel = BayesianNetworkModel
    def get_BaselineModel(self): return self.BaselineModel
    def set_BaselineModel(self, BaselineModel): self.BaselineModel = BaselineModel
    def get_ClusteringModel(self): return self.ClusteringModel
    def set_ClusteringModel(self, ClusteringModel): self.ClusteringModel = ClusteringModel
    def get_GaussianProcessModel(self): return self.GaussianProcessModel
    def set_GaussianProcessModel(self, GaussianProcessModel): self.GaussianProcessModel = GaussianProcessModel
    def get_GeneralRegressionModel(self): return self.GeneralRegressionModel
    def set_GeneralRegressionModel(self, GeneralRegressionModel): self.GeneralRegressionModel = GeneralRegressionModel
    def get_MiningModel(self): return self.MiningModel
    def set_MiningModel(self, MiningModel): self.MiningModel = MiningModel
    def get_NaiveBayesModel(self): return self.NaiveBayesModel
    def set_NaiveBayesModel(self, NaiveBayesModel): self.NaiveBayesModel = NaiveBayesModel
    def get_NearestNeighborModel(self): return self.NearestNeighborModel
    def set_NearestNeighborModel(self, NearestNeighborModel): self.NearestNeighborModel = NearestNeighborModel
    def get_NeuralNetwork(self): return self.NeuralNetwork
    def set_NeuralNetwork(self, NeuralNetwork): self.NeuralNetwork = NeuralNetwork
    def get_RegressionModel(self): return self.RegressionModel
    def set_RegressionModel(self, RegressionModel): self.RegressionModel = RegressionModel
    def get_RuleSetModel(self): return self.RuleSetModel
    def set_RuleSetModel(self, RuleSetModel): self.RuleSetModel = RuleSetModel
    def get_SequenceModel(self): return self.SequenceModel
    def set_SequenceModel(self, SequenceModel): self.SequenceModel = SequenceModel
    def get_Scorecard(self): return self.Scorecard
    def set_Scorecard(self, Scorecard): self.Scorecard = Scorecard
    def get_SupportVectorMachineModel(self): return self.SupportVectorMachineModel
    def set_SupportVectorMachineModel(self, SupportVectorMachineModel): self.SupportVectorMachineModel = SupportVectorMachineModel
    def get_TextModel(self): return self.TextModel
    def set_TextModel(self, TextModel): self.TextModel = TextModel
    def get_TimeSeriesModel(self): return self.TimeSeriesModel
    def set_TimeSeriesModel(self, TimeSeriesModel): self.TimeSeriesModel = TimeSeriesModel
    def get_TreeModel(self): return self.TreeModel
    def set_TreeModel(self, TreeModel): self.TreeModel = TreeModel
    def get_MeanClusterDistances(self): return self.MeanClusterDistances
    def set_MeanClusterDistances(self, MeanClusterDistances): self.MeanClusterDistances = MeanClusterDistances
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmType(self): return self.algorithmType
    def set_algorithmType(self, algorithmType): self.algorithmType = algorithmType
    def get_sampleDataSize(self): return self.sampleDataSize
    def set_sampleDataSize(self, sampleDataSize): self.sampleDataSize = sampleDataSize
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_ALGORITHM_TYPE(self, value):
        # Validate type ALGORITHM-TYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['iforest', 'ocsvm', 'clusterMeanDist', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ALGORITHM-TYPE' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.LocalTransformations is not None or
            self.ModelVerification is not None or
            self.AnomalyDetectionModel is not None or
            self.AssociationModel is not None or
            self.BayesianNetworkModel is not None or
            self.BaselineModel is not None or
            self.ClusteringModel is not None or
            self.GaussianProcessModel is not None or
            self.GeneralRegressionModel is not None or
            self.MiningModel is not None or
            self.NaiveBayesModel is not None or
            self.NearestNeighborModel is not None or
            self.NeuralNetwork is not None or
            self.RegressionModel is not None or
            self.RuleSetModel is not None or
            self.SequenceModel is not None or
            self.Scorecard is not None or
            self.SupportVectorMachineModel is not None or
            self.TextModel is not None or
            self.TimeSeriesModel is not None or
            self.TreeModel is not None or
            self.MeanClusterDistances is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AnomalyDetectionModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AnomalyDetectionModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnomalyDetectionModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AnomalyDetectionModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AnomalyDetectionModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmType is not None and 'algorithmType' not in already_processed:
            already_processed.add('algorithmType')
            outfile.write(' algorithmType=%s' % (quote_attrib(self.algorithmType), ))
        if self.sampleDataSize is not None and 'sampleDataSize' not in already_processed:
            already_processed.add('sampleDataSize')
            outfile.write(' sampleDataSize=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sampleDataSize), input_name='sampleDataSize')), ))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='AnomalyDetectionModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        if self.AnomalyDetectionModel is not None:
            self.AnomalyDetectionModel.export(outfile, level, namespace_, name_='AnomalyDetectionModel', pretty_print=pretty_print)
        if self.AssociationModel is not None:
            self.AssociationModel.export(outfile, level, namespace_, name_='AssociationModel', pretty_print=pretty_print)
        if self.BayesianNetworkModel is not None:
            self.BayesianNetworkModel.export(outfile, level, namespace_, name_='BayesianNetworkModel', pretty_print=pretty_print)
        if self.BaselineModel is not None:
            self.BaselineModel.export(outfile, level, namespace_, name_='BaselineModel', pretty_print=pretty_print)
        if self.ClusteringModel is not None:
            self.ClusteringModel.export(outfile, level, namespace_, name_='ClusteringModel', pretty_print=pretty_print)
        if self.GaussianProcessModel is not None:
            self.GaussianProcessModel.export(outfile, level, namespace_, name_='GaussianProcessModel', pretty_print=pretty_print)
        if self.GeneralRegressionModel is not None:
            self.GeneralRegressionModel.export(outfile, level, namespace_, name_='GeneralRegressionModel', pretty_print=pretty_print)
        if self.MiningModel is not None:
            self.MiningModel.export(outfile, level, namespace_, name_='MiningModel', pretty_print=pretty_print)
        if self.NaiveBayesModel is not None:
            self.NaiveBayesModel.export(outfile, level, namespace_, name_='NaiveBayesModel', pretty_print=pretty_print)
        if self.NearestNeighborModel is not None:
            self.NearestNeighborModel.export(outfile, level, namespace_, name_='NearestNeighborModel', pretty_print=pretty_print)
        if self.NeuralNetwork is not None:
            self.NeuralNetwork.export(outfile, level, namespace_, name_='NeuralNetwork', pretty_print=pretty_print)
        if self.RegressionModel is not None:
            self.RegressionModel.export(outfile, level, namespace_, name_='RegressionModel', pretty_print=pretty_print)
        if self.RuleSetModel is not None:
            self.RuleSetModel.export(outfile, level, namespace_, name_='RuleSetModel', pretty_print=pretty_print)
        if self.SequenceModel is not None:
            self.SequenceModel.export(outfile, level, namespace_, name_='SequenceModel', pretty_print=pretty_print)
        if self.Scorecard is not None:
            self.Scorecard.export(outfile, level, namespace_, name_='Scorecard', pretty_print=pretty_print)
        if self.SupportVectorMachineModel is not None:
            self.SupportVectorMachineModel.export(outfile, level, namespace_, name_='SupportVectorMachineModel', pretty_print=pretty_print)
        if self.TextModel is not None:
            self.TextModel.export(outfile, level, namespace_, name_='TextModel', pretty_print=pretty_print)
        if self.TimeSeriesModel is not None:
            self.TimeSeriesModel.export(outfile, level, namespace_, name_='TimeSeriesModel', pretty_print=pretty_print)
        if self.TreeModel is not None:
            self.TreeModel.export(outfile, level, namespace_, name_='TreeModel', pretty_print=pretty_print)
        if self.MeanClusterDistances is not None:
            self.MeanClusterDistances.export(outfile, level, namespace_, name_='MeanClusterDistances', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AnomalyDetectionModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmType is not None:
            element.set('algorithmType', self.algorithmType)
        if self.sampleDataSize is not None:
            element.set('sampleDataSize', self.gds_format_string(self.sampleDataSize))
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        if self.AnomalyDetectionModel is not None:
            AnomalyDetectionModel_ = self.AnomalyDetectionModel
            AnomalyDetectionModel_.to_etree(element, name_='AnomalyDetectionModel', mapping_=mapping_)
        if self.AssociationModel is not None:
            AssociationModel_ = self.AssociationModel
            AssociationModel_.to_etree(element, name_='AssociationModel', mapping_=mapping_)
        if self.BayesianNetworkModel is not None:
            BayesianNetworkModel_ = self.BayesianNetworkModel
            BayesianNetworkModel_.to_etree(element, name_='BayesianNetworkModel', mapping_=mapping_)
        if self.BaselineModel is not None:
            BaselineModel_ = self.BaselineModel
            BaselineModel_.to_etree(element, name_='BaselineModel', mapping_=mapping_)
        if self.ClusteringModel is not None:
            ClusteringModel_ = self.ClusteringModel
            ClusteringModel_.to_etree(element, name_='ClusteringModel', mapping_=mapping_)
        if self.GaussianProcessModel is not None:
            GaussianProcessModel_ = self.GaussianProcessModel
            GaussianProcessModel_.to_etree(element, name_='GaussianProcessModel', mapping_=mapping_)
        if self.GeneralRegressionModel is not None:
            GeneralRegressionModel_ = self.GeneralRegressionModel
            GeneralRegressionModel_.to_etree(element, name_='GeneralRegressionModel', mapping_=mapping_)
        if self.MiningModel is not None:
            MiningModel_ = self.MiningModel
            MiningModel_.to_etree(element, name_='MiningModel', mapping_=mapping_)
        if self.NaiveBayesModel is not None:
            NaiveBayesModel_ = self.NaiveBayesModel
            NaiveBayesModel_.to_etree(element, name_='NaiveBayesModel', mapping_=mapping_)
        if self.NearestNeighborModel is not None:
            NearestNeighborModel_ = self.NearestNeighborModel
            NearestNeighborModel_.to_etree(element, name_='NearestNeighborModel', mapping_=mapping_)
        if self.NeuralNetwork is not None:
            NeuralNetwork_ = self.NeuralNetwork
            NeuralNetwork_.to_etree(element, name_='NeuralNetwork', mapping_=mapping_)
        if self.RegressionModel is not None:
            RegressionModel_ = self.RegressionModel
            RegressionModel_.to_etree(element, name_='RegressionModel', mapping_=mapping_)
        if self.RuleSetModel is not None:
            RuleSetModel_ = self.RuleSetModel
            RuleSetModel_.to_etree(element, name_='RuleSetModel', mapping_=mapping_)
        if self.SequenceModel is not None:
            SequenceModel_ = self.SequenceModel
            SequenceModel_.to_etree(element, name_='SequenceModel', mapping_=mapping_)
        if self.Scorecard is not None:
            Scorecard_ = self.Scorecard
            Scorecard_.to_etree(element, name_='Scorecard', mapping_=mapping_)
        if self.SupportVectorMachineModel is not None:
            SupportVectorMachineModel_ = self.SupportVectorMachineModel
            SupportVectorMachineModel_.to_etree(element, name_='SupportVectorMachineModel', mapping_=mapping_)
        if self.TextModel is not None:
            TextModel_ = self.TextModel
            TextModel_.to_etree(element, name_='TextModel', mapping_=mapping_)
        if self.TimeSeriesModel is not None:
            TimeSeriesModel_ = self.TimeSeriesModel
            TimeSeriesModel_.to_etree(element, name_='TimeSeriesModel', mapping_=mapping_)
        if self.TreeModel is not None:
            TreeModel_ = self.TreeModel
            TreeModel_.to_etree(element, name_='TreeModel', mapping_=mapping_)
        if self.MeanClusterDistances is not None:
            MeanClusterDistances_ = self.MeanClusterDistances
            MeanClusterDistances_.to_etree(element, name_='MeanClusterDistances', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='AnomalyDetectionModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmType is not None and 'algorithmType' not in already_processed:
            already_processed.add('algorithmType')
            showIndent(outfile, level)
            outfile.write('algorithmType="%s",\n' % (self.algorithmType,))
        if self.sampleDataSize is not None and 'sampleDataSize' not in already_processed:
            already_processed.add('sampleDataSize')
            showIndent(outfile, level)
            outfile.write('sampleDataSize="%s",\n' % (self.sampleDataSize,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AnomalyDetectionModel is not None:
            showIndent(outfile, level)
            outfile.write('AnomalyDetectionModel=model_.AnomalyDetectionModel(\n')
            self.AnomalyDetectionModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AssociationModel is not None:
            showIndent(outfile, level)
            outfile.write('AssociationModel=model_.AssociationModel(\n')
            self.AssociationModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BayesianNetworkModel is not None:
            showIndent(outfile, level)
            outfile.write('BayesianNetworkModel=model_.BayesianNetworkModel(\n')
            self.BayesianNetworkModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BaselineModel is not None:
            showIndent(outfile, level)
            outfile.write('BaselineModel=model_.BaselineModel(\n')
            self.BaselineModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ClusteringModel is not None:
            showIndent(outfile, level)
            outfile.write('ClusteringModel=model_.ClusteringModel(\n')
            self.ClusteringModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GaussianProcessModel is not None:
            showIndent(outfile, level)
            outfile.write('GaussianProcessModel=model_.GaussianProcessModel(\n')
            self.GaussianProcessModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GeneralRegressionModel is not None:
            showIndent(outfile, level)
            outfile.write('GeneralRegressionModel=model_.GeneralRegressionModel(\n')
            self.GeneralRegressionModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MiningModel is not None:
            showIndent(outfile, level)
            outfile.write('MiningModel=model_.MiningModel(\n')
            self.MiningModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NaiveBayesModel is not None:
            showIndent(outfile, level)
            outfile.write('NaiveBayesModel=model_.NaiveBayesModel(\n')
            self.NaiveBayesModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NearestNeighborModel is not None:
            showIndent(outfile, level)
            outfile.write('NearestNeighborModel=model_.NearestNeighborModel(\n')
            self.NearestNeighborModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NeuralNetwork is not None:
            showIndent(outfile, level)
            outfile.write('NeuralNetwork=model_.NeuralNetwork(\n')
            self.NeuralNetwork.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RegressionModel is not None:
            showIndent(outfile, level)
            outfile.write('RegressionModel=model_.RegressionModel(\n')
            self.RegressionModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RuleSetModel is not None:
            showIndent(outfile, level)
            outfile.write('RuleSetModel=model_.RuleSetModel(\n')
            self.RuleSetModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SequenceModel is not None:
            showIndent(outfile, level)
            outfile.write('SequenceModel=model_.SequenceModel(\n')
            self.SequenceModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Scorecard is not None:
            showIndent(outfile, level)
            outfile.write('Scorecard=model_.Scorecard(\n')
            self.Scorecard.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SupportVectorMachineModel is not None:
            showIndent(outfile, level)
            outfile.write('SupportVectorMachineModel=model_.SupportVectorMachineModel(\n')
            self.SupportVectorMachineModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextModel is not None:
            showIndent(outfile, level)
            outfile.write('TextModel=model_.TextModel(\n')
            self.TextModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TimeSeriesModel is not None:
            showIndent(outfile, level)
            outfile.write('TimeSeriesModel=model_.TimeSeriesModel(\n')
            self.TimeSeriesModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TreeModel is not None:
            showIndent(outfile, level)
            outfile.write('TreeModel=model_.TreeModel(\n')
            self.TreeModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MeanClusterDistances is not None:
            showIndent(outfile, level)
            outfile.write('MeanClusterDistances=model_.MeanClusterDistances(\n')
            self.MeanClusterDistances.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmType', node)
        if value is not None and 'algorithmType' not in already_processed:
            already_processed.add('algorithmType')
            self.algorithmType = value
            self.validate_ALGORITHM_TYPE(self.algorithmType)    # validate type ALGORITHM-TYPE
        value = find_attr_value_('sampleDataSize', node)
        if value is not None and 'sampleDataSize' not in already_processed:
            already_processed.add('sampleDataSize')
            self.sampleDataSize = value
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'AnomalyDetectionModel':
            obj_ = AnomalyDetectionModel.factory()
            obj_.build(child_)
            self.AnomalyDetectionModel = obj_
            obj_.original_tagname_ = 'AnomalyDetectionModel'
        elif nodeName_ == 'AssociationModel':
            obj_ = AssociationModel.factory()
            obj_.build(child_)
            self.AssociationModel = obj_
            obj_.original_tagname_ = 'AssociationModel'
        elif nodeName_ == 'BayesianNetworkModel':
            obj_ = BayesianNetworkModel.factory()
            obj_.build(child_)
            self.BayesianNetworkModel = obj_
            obj_.original_tagname_ = 'BayesianNetworkModel'
        elif nodeName_ == 'BaselineModel':
            obj_ = BaselineModel.factory()
            obj_.build(child_)
            self.BaselineModel = obj_
            obj_.original_tagname_ = 'BaselineModel'
        elif nodeName_ == 'ClusteringModel':
            obj_ = ClusteringModel.factory()
            obj_.build(child_)
            self.ClusteringModel = obj_
            obj_.original_tagname_ = 'ClusteringModel'
        elif nodeName_ == 'GaussianProcessModel':
            obj_ = GaussianProcessModel.factory()
            obj_.build(child_)
            self.GaussianProcessModel = obj_
            obj_.original_tagname_ = 'GaussianProcessModel'
        elif nodeName_ == 'GeneralRegressionModel':
            obj_ = GeneralRegressionModel.factory()
            obj_.build(child_)
            self.GeneralRegressionModel = obj_
            obj_.original_tagname_ = 'GeneralRegressionModel'
        elif nodeName_ == 'MiningModel':
            obj_ = MiningModel.factory()
            obj_.build(child_)
            self.MiningModel = obj_
            obj_.original_tagname_ = 'MiningModel'
        elif nodeName_ == 'NaiveBayesModel':
            obj_ = NaiveBayesModel.factory()
            obj_.build(child_)
            self.NaiveBayesModel = obj_
            obj_.original_tagname_ = 'NaiveBayesModel'
        elif nodeName_ == 'NearestNeighborModel':
            obj_ = NearestNeighborModel.factory()
            obj_.build(child_)
            self.NearestNeighborModel = obj_
            obj_.original_tagname_ = 'NearestNeighborModel'
        elif nodeName_ == 'NeuralNetwork':
            obj_ = NeuralNetwork.factory()
            obj_.build(child_)
            self.NeuralNetwork = obj_
            obj_.original_tagname_ = 'NeuralNetwork'
        elif nodeName_ == 'RegressionModel':
            obj_ = RegressionModel.factory()
            obj_.build(child_)
            self.RegressionModel = obj_
            obj_.original_tagname_ = 'RegressionModel'
        elif nodeName_ == 'RuleSetModel':
            obj_ = RuleSetModel.factory()
            obj_.build(child_)
            self.RuleSetModel = obj_
            obj_.original_tagname_ = 'RuleSetModel'
        elif nodeName_ == 'SequenceModel':
            obj_ = SequenceModel.factory()
            obj_.build(child_)
            self.SequenceModel = obj_
            obj_.original_tagname_ = 'SequenceModel'
        elif nodeName_ == 'Scorecard':
            obj_ = Scorecard.factory()
            obj_.build(child_)
            self.Scorecard = obj_
            obj_.original_tagname_ = 'Scorecard'
        elif nodeName_ == 'SupportVectorMachineModel':
            obj_ = SupportVectorMachineModel.factory()
            obj_.build(child_)
            self.SupportVectorMachineModel = obj_
            obj_.original_tagname_ = 'SupportVectorMachineModel'
        elif nodeName_ == 'TextModel':
            obj_ = TextModel.factory()
            obj_.build(child_)
            self.TextModel = obj_
            obj_.original_tagname_ = 'TextModel'
        elif nodeName_ == 'TimeSeriesModel':
            obj_ = TimeSeriesModel.factory()
            obj_.build(child_)
            self.TimeSeriesModel = obj_
            obj_.original_tagname_ = 'TimeSeriesModel'
        elif nodeName_ == 'TreeModel':
            obj_ = TreeModel.factory()
            obj_.build(child_)
            self.TreeModel = obj_
            obj_.original_tagname_ = 'TreeModel'
        elif nodeName_ == 'MeanClusterDistances':
            obj_ = MeanClusterDistances.factory()
            obj_.build(child_)
            self.MeanClusterDistances = obj_
            obj_.original_tagname_ = 'MeanClusterDistances'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class AnomalyDetectionModel


class MeanClusterDistances(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeanClusterDistances)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeanClusterDistances.subclass:
            return MeanClusterDistances.subclass(*args_, **kwargs_)
        else:
            return MeanClusterDistances(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MeanClusterDistances', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeanClusterDistances')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeanClusterDistances')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MeanClusterDistances', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeanClusterDistances'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MeanClusterDistances', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MeanClusterDistances', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MeanClusterDistances'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class MeanClusterDistances


class SequenceModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, numberOfTransactions=None, maxNumberOfItemsPerTransaction=None, avgNumberOfItemsPerTransaction=None, numberOfTransactionGroups=None, maxNumberOfTAsPerTAGroup=None, avgNumberOfTAsPerTAGroup=None, isScorable=True, MiningSchema=None, ModelStats=None, LocalTransformations=None, Constraints=None, Item=None, Itemset=None, SetPredicate=None, Sequence=None, SequenceRule=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.numberOfTransactions = _cast(int, numberOfTransactions)
        self.maxNumberOfItemsPerTransaction = _cast(int, maxNumberOfItemsPerTransaction)
        self.avgNumberOfItemsPerTransaction = _cast(None, avgNumberOfItemsPerTransaction)
        self.numberOfTransactionGroups = _cast(int, numberOfTransactionGroups)
        self.maxNumberOfTAsPerTAGroup = _cast(int, maxNumberOfTAsPerTAGroup)
        self.avgNumberOfTAsPerTAGroup = _cast(None, avgNumberOfTAsPerTAGroup)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.ModelStats = ModelStats
        self.LocalTransformations = LocalTransformations
        self.Constraints = Constraints
        if Item is None:
            self.Item = []
        else:
            self.Item = Item
        if Itemset is None:
            self.Itemset = []
        else:
            self.Itemset = Itemset
        if SetPredicate is None:
            self.SetPredicate = []
        else:
            self.SetPredicate = SetPredicate
        if Sequence is None:
            self.Sequence = []
        else:
            self.Sequence = Sequence
        if SequenceRule is None:
            self.SequenceRule = []
        else:
            self.SequenceRule = SequenceRule
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SequenceModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SequenceModel.subclass:
            return SequenceModel.subclass(*args_, **kwargs_)
        else:
            return SequenceModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_Constraints(self): return self.Constraints
    def set_Constraints(self, Constraints): self.Constraints = Constraints
    def get_Item(self): return self.Item
    def set_Item(self, Item): self.Item = Item
    def add_Item(self, value): self.Item.append(value)
    def insert_Item_at(self, index, value): self.Item.insert(index, value)
    def replace_Item_at(self, index, value): self.Item[index] = value
    def get_Itemset(self): return self.Itemset
    def set_Itemset(self, Itemset): self.Itemset = Itemset
    def add_Itemset(self, value): self.Itemset.append(value)
    def insert_Itemset_at(self, index, value): self.Itemset.insert(index, value)
    def replace_Itemset_at(self, index, value): self.Itemset[index] = value
    def get_SetPredicate(self): return self.SetPredicate
    def set_SetPredicate(self, SetPredicate): self.SetPredicate = SetPredicate
    def add_SetPredicate(self, value): self.SetPredicate.append(value)
    def insert_SetPredicate_at(self, index, value): self.SetPredicate.insert(index, value)
    def replace_SetPredicate_at(self, index, value): self.SetPredicate[index] = value
    def get_Sequence(self): return self.Sequence
    def set_Sequence(self, Sequence): self.Sequence = Sequence
    def add_Sequence(self, value): self.Sequence.append(value)
    def insert_Sequence_at(self, index, value): self.Sequence.insert(index, value)
    def replace_Sequence_at(self, index, value): self.Sequence[index] = value
    def get_SequenceRule(self): return self.SequenceRule
    def set_SequenceRule(self, SequenceRule): self.SequenceRule = SequenceRule
    def add_SequenceRule(self, value): self.SequenceRule.append(value)
    def insert_SequenceRule_at(self, index, value): self.SequenceRule.insert(index, value)
    def replace_SequenceRule_at(self, index, value): self.SequenceRule[index] = value
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_numberOfTransactions(self): return self.numberOfTransactions
    def set_numberOfTransactions(self, numberOfTransactions): self.numberOfTransactions = numberOfTransactions
    def get_maxNumberOfItemsPerTransaction(self): return self.maxNumberOfItemsPerTransaction
    def set_maxNumberOfItemsPerTransaction(self, maxNumberOfItemsPerTransaction): self.maxNumberOfItemsPerTransaction = maxNumberOfItemsPerTransaction
    def get_avgNumberOfItemsPerTransaction(self): return self.avgNumberOfItemsPerTransaction
    def set_avgNumberOfItemsPerTransaction(self, avgNumberOfItemsPerTransaction): self.avgNumberOfItemsPerTransaction = avgNumberOfItemsPerTransaction
    def get_numberOfTransactionGroups(self): return self.numberOfTransactionGroups
    def set_numberOfTransactionGroups(self, numberOfTransactionGroups): self.numberOfTransactionGroups = numberOfTransactionGroups
    def get_maxNumberOfTAsPerTAGroup(self): return self.maxNumberOfTAsPerTAGroup
    def set_maxNumberOfTAsPerTAGroup(self, maxNumberOfTAsPerTAGroup): self.maxNumberOfTAsPerTAGroup = maxNumberOfTAsPerTAGroup
    def get_avgNumberOfTAsPerTAGroup(self): return self.avgNumberOfTAsPerTAGroup
    def set_avgNumberOfTAsPerTAGroup(self, avgNumberOfTAsPerTAGroup): self.avgNumberOfTAsPerTAGroup = avgNumberOfTAsPerTAGroup
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.ModelStats is not None or
            self.LocalTransformations is not None or
            self.Constraints is not None or
            self.Item or
            self.Itemset or
            self.SetPredicate or
            self.Sequence or
            self.SequenceRule or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SequenceModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SequenceModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SequenceModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SequenceModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SequenceModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.numberOfTransactions is not None and 'numberOfTransactions' not in already_processed:
            already_processed.add('numberOfTransactions')
            outfile.write(' numberOfTransactions="%s"' % self.gds_format_integer(self.numberOfTransactions, input_name='numberOfTransactions'))
        if self.maxNumberOfItemsPerTransaction is not None and 'maxNumberOfItemsPerTransaction' not in already_processed:
            already_processed.add('maxNumberOfItemsPerTransaction')
            outfile.write(' maxNumberOfItemsPerTransaction="%s"' % self.gds_format_integer(self.maxNumberOfItemsPerTransaction, input_name='maxNumberOfItemsPerTransaction'))
        if self.avgNumberOfItemsPerTransaction is not None and 'avgNumberOfItemsPerTransaction' not in already_processed:
            already_processed.add('avgNumberOfItemsPerTransaction')
            outfile.write(' avgNumberOfItemsPerTransaction=%s' % (quote_attrib(self.avgNumberOfItemsPerTransaction), ))
        if self.numberOfTransactionGroups is not None and 'numberOfTransactionGroups' not in already_processed:
            already_processed.add('numberOfTransactionGroups')
            outfile.write(' numberOfTransactionGroups="%s"' % self.gds_format_integer(self.numberOfTransactionGroups, input_name='numberOfTransactionGroups'))
        if self.maxNumberOfTAsPerTAGroup is not None and 'maxNumberOfTAsPerTAGroup' not in already_processed:
            already_processed.add('maxNumberOfTAsPerTAGroup')
            outfile.write(' maxNumberOfTAsPerTAGroup="%s"' % self.gds_format_integer(self.maxNumberOfTAsPerTAGroup, input_name='maxNumberOfTAsPerTAGroup'))
        if self.avgNumberOfTAsPerTAGroup is not None and 'avgNumberOfTAsPerTAGroup' not in already_processed:
            already_processed.add('avgNumberOfTAsPerTAGroup')
            outfile.write(' avgNumberOfTAsPerTAGroup=%s' % (quote_attrib(self.avgNumberOfTAsPerTAGroup), ))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='SequenceModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        if self.Constraints is not None:
            self.Constraints.export(outfile, level, namespace_, name_='Constraints', pretty_print=pretty_print)
        for Item_ in self.Item:
            Item_.export(outfile, level, namespace_, name_='Item', pretty_print=pretty_print)
        for Itemset_ in self.Itemset:
            Itemset_.export(outfile, level, namespace_, name_='Itemset', pretty_print=pretty_print)
        for SetPredicate_ in self.SetPredicate:
            SetPredicate_.export(outfile, level, namespace_, name_='SetPredicate', pretty_print=pretty_print)
        for Sequence_ in self.Sequence:
            Sequence_.export(outfile, level, namespace_, name_='Sequence', pretty_print=pretty_print)
        for SequenceRule_ in self.SequenceRule:
            SequenceRule_.export(outfile, level, namespace_, name_='SequenceRule', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SequenceModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.numberOfTransactions is not None:
            element.set('numberOfTransactions', self.gds_format_integer(self.numberOfTransactions))
        if self.maxNumberOfItemsPerTransaction is not None:
            element.set('maxNumberOfItemsPerTransaction', self.gds_format_integer(self.maxNumberOfItemsPerTransaction))
        if self.avgNumberOfItemsPerTransaction is not None:
            element.set('avgNumberOfItemsPerTransaction', self.avgNumberOfItemsPerTransaction)
        if self.numberOfTransactionGroups is not None:
            element.set('numberOfTransactionGroups', self.gds_format_integer(self.numberOfTransactionGroups))
        if self.maxNumberOfTAsPerTAGroup is not None:
            element.set('maxNumberOfTAsPerTAGroup', self.gds_format_integer(self.maxNumberOfTAsPerTAGroup))
        if self.avgNumberOfTAsPerTAGroup is not None:
            element.set('avgNumberOfTAsPerTAGroup', self.avgNumberOfTAsPerTAGroup)
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        if self.Constraints is not None:
            Constraints_ = self.Constraints
            Constraints_.to_etree(element, name_='Constraints', mapping_=mapping_)
        for Item_ in self.Item:
            Item_.to_etree(element, name_='Item', mapping_=mapping_)
        for Itemset_ in self.Itemset:
            Itemset_.to_etree(element, name_='Itemset', mapping_=mapping_)
        for SetPredicate_ in self.SetPredicate:
            SetPredicate_.to_etree(element, name_='SetPredicate', mapping_=mapping_)
        for Sequence_ in self.Sequence:
            Sequence_.to_etree(element, name_='Sequence', mapping_=mapping_)
        for SequenceRule_ in self.SequenceRule:
            SequenceRule_.to_etree(element, name_='SequenceRule', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SequenceModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.numberOfTransactions is not None and 'numberOfTransactions' not in already_processed:
            already_processed.add('numberOfTransactions')
            showIndent(outfile, level)
            outfile.write('numberOfTransactions=%d,\n' % (self.numberOfTransactions,))
        if self.maxNumberOfItemsPerTransaction is not None and 'maxNumberOfItemsPerTransaction' not in already_processed:
            already_processed.add('maxNumberOfItemsPerTransaction')
            showIndent(outfile, level)
            outfile.write('maxNumberOfItemsPerTransaction=%d,\n' % (self.maxNumberOfItemsPerTransaction,))
        if self.avgNumberOfItemsPerTransaction is not None and 'avgNumberOfItemsPerTransaction' not in already_processed:
            already_processed.add('avgNumberOfItemsPerTransaction')
            showIndent(outfile, level)
            outfile.write('avgNumberOfItemsPerTransaction=%e,\n' % (self.avgNumberOfItemsPerTransaction,))
        if self.numberOfTransactionGroups is not None and 'numberOfTransactionGroups' not in already_processed:
            already_processed.add('numberOfTransactionGroups')
            showIndent(outfile, level)
            outfile.write('numberOfTransactionGroups=%d,\n' % (self.numberOfTransactionGroups,))
        if self.maxNumberOfTAsPerTAGroup is not None and 'maxNumberOfTAsPerTAGroup' not in already_processed:
            already_processed.add('maxNumberOfTAsPerTAGroup')
            showIndent(outfile, level)
            outfile.write('maxNumberOfTAsPerTAGroup=%d,\n' % (self.maxNumberOfTAsPerTAGroup,))
        if self.avgNumberOfTAsPerTAGroup is not None and 'avgNumberOfTAsPerTAGroup' not in already_processed:
            already_processed.add('avgNumberOfTAsPerTAGroup')
            showIndent(outfile, level)
            outfile.write('avgNumberOfTAsPerTAGroup=%e,\n' % (self.avgNumberOfTAsPerTAGroup,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Constraints is not None:
            showIndent(outfile, level)
            outfile.write('Constraints=model_.Constraints(\n')
            self.Constraints.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Item=[\n')
        level += 1
        for Item_ in self.Item:
            showIndent(outfile, level)
            outfile.write('model_.Item(\n')
            Item_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Itemset=[\n')
        level += 1
        for Itemset_ in self.Itemset:
            showIndent(outfile, level)
            outfile.write('model_.Itemset(\n')
            Itemset_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SetPredicate=[\n')
        level += 1
        for SetPredicate_ in self.SetPredicate:
            showIndent(outfile, level)
            outfile.write('model_.SetPredicate(\n')
            SetPredicate_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Sequence=[\n')
        level += 1
        for Sequence_ in self.Sequence:
            showIndent(outfile, level)
            outfile.write('model_.Sequence(\n')
            Sequence_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SequenceRule=[\n')
        level += 1
        for SequenceRule_ in self.SequenceRule:
            showIndent(outfile, level)
            outfile.write('model_.SequenceRule(\n')
            SequenceRule_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('numberOfTransactions', node)
        if value is not None and 'numberOfTransactions' not in already_processed:
            already_processed.add('numberOfTransactions')
            try:
                self.numberOfTransactions = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfTransactions < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('maxNumberOfItemsPerTransaction', node)
        if value is not None and 'maxNumberOfItemsPerTransaction' not in already_processed:
            already_processed.add('maxNumberOfItemsPerTransaction')
            try:
                self.maxNumberOfItemsPerTransaction = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.maxNumberOfItemsPerTransaction < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('avgNumberOfItemsPerTransaction', node)
        if value is not None and 'avgNumberOfItemsPerTransaction' not in already_processed:
            already_processed.add('avgNumberOfItemsPerTransaction')
            try:
                self.avgNumberOfItemsPerTransaction = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (avgNumberOfItemsPerTransaction): %s' % exp)
            self.validate_REAL_NUMBER(self.avgNumberOfItemsPerTransaction)    # validate type REAL-NUMBER
        value = find_attr_value_('numberOfTransactionGroups', node)
        if value is not None and 'numberOfTransactionGroups' not in already_processed:
            already_processed.add('numberOfTransactionGroups')
            try:
                self.numberOfTransactionGroups = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfTransactionGroups < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('maxNumberOfTAsPerTAGroup', node)
        if value is not None and 'maxNumberOfTAsPerTAGroup' not in already_processed:
            already_processed.add('maxNumberOfTAsPerTAGroup')
            try:
                self.maxNumberOfTAsPerTAGroup = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.maxNumberOfTAsPerTAGroup < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('avgNumberOfTAsPerTAGroup', node)
        if value is not None and 'avgNumberOfTAsPerTAGroup' not in already_processed:
            already_processed.add('avgNumberOfTAsPerTAGroup')
            try:
                self.avgNumberOfTAsPerTAGroup = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (avgNumberOfTAsPerTAGroup): %s' % exp)
            self.validate_REAL_NUMBER(self.avgNumberOfTAsPerTAGroup)    # validate type REAL-NUMBER
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'Constraints':
            obj_ = Constraints.factory()
            obj_.build(child_)
            self.Constraints = obj_
            obj_.original_tagname_ = 'Constraints'
        elif nodeName_ == 'Item':
            obj_ = Item.factory()
            obj_.build(child_)
            self.Item.append(obj_)
            obj_.original_tagname_ = 'Item'
        elif nodeName_ == 'Itemset':
            obj_ = Itemset.factory()
            obj_.build(child_)
            self.Itemset.append(obj_)
            obj_.original_tagname_ = 'Itemset'
        elif nodeName_ == 'SetPredicate':
            obj_ = SetPredicate.factory()
            obj_.build(child_)
            self.SetPredicate.append(obj_)
            obj_.original_tagname_ = 'SetPredicate'
        elif nodeName_ == 'Sequence':
            obj_ = Sequence.factory()
            obj_.build(child_)
            self.Sequence.append(obj_)
            obj_.original_tagname_ = 'Sequence'
        elif nodeName_ == 'SequenceRule':
            obj_ = SequenceRule.factory()
            obj_.build(child_)
            self.SequenceRule.append(obj_)
            obj_.original_tagname_ = 'SequenceRule'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class SequenceModel


class Constraints(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, minimumNumberOfItems=1, maximumNumberOfItems=None, minimumNumberOfAntecedentItems=1, maximumNumberOfAntecedentItems=None, minimumNumberOfConsequentItems=1, maximumNumberOfConsequentItems=None, minimumSupport='0', minimumConfidence='0', minimumLift='0', minimumTotalSequenceTime='0', maximumTotalSequenceTime=None, minimumItemsetSeparationTime='0', maximumItemsetSeparationTime=None, minimumAntConsSeparationTime='0', maximumAntConsSeparationTime=None, Extension=None):
        self.original_tagname_ = None
        self.minimumNumberOfItems = _cast(int, minimumNumberOfItems)
        self.maximumNumberOfItems = _cast(int, maximumNumberOfItems)
        self.minimumNumberOfAntecedentItems = _cast(int, minimumNumberOfAntecedentItems)
        self.maximumNumberOfAntecedentItems = _cast(int, maximumNumberOfAntecedentItems)
        self.minimumNumberOfConsequentItems = _cast(int, minimumNumberOfConsequentItems)
        self.maximumNumberOfConsequentItems = _cast(int, maximumNumberOfConsequentItems)
        self.minimumSupport = _cast(None, minimumSupport)
        self.minimumConfidence = _cast(None, minimumConfidence)
        self.minimumLift = _cast(None, minimumLift)
        self.minimumTotalSequenceTime = _cast(None, minimumTotalSequenceTime)
        self.maximumTotalSequenceTime = _cast(None, maximumTotalSequenceTime)
        self.minimumItemsetSeparationTime = _cast(None, minimumItemsetSeparationTime)
        self.maximumItemsetSeparationTime = _cast(None, maximumItemsetSeparationTime)
        self.minimumAntConsSeparationTime = _cast(None, minimumAntConsSeparationTime)
        self.maximumAntConsSeparationTime = _cast(None, maximumAntConsSeparationTime)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Constraints)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Constraints.subclass:
            return Constraints.subclass(*args_, **kwargs_)
        else:
            return Constraints(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_minimumNumberOfItems(self): return self.minimumNumberOfItems
    def set_minimumNumberOfItems(self, minimumNumberOfItems): self.minimumNumberOfItems = minimumNumberOfItems
    def get_maximumNumberOfItems(self): return self.maximumNumberOfItems
    def set_maximumNumberOfItems(self, maximumNumberOfItems): self.maximumNumberOfItems = maximumNumberOfItems
    def get_minimumNumberOfAntecedentItems(self): return self.minimumNumberOfAntecedentItems
    def set_minimumNumberOfAntecedentItems(self, minimumNumberOfAntecedentItems): self.minimumNumberOfAntecedentItems = minimumNumberOfAntecedentItems
    def get_maximumNumberOfAntecedentItems(self): return self.maximumNumberOfAntecedentItems
    def set_maximumNumberOfAntecedentItems(self, maximumNumberOfAntecedentItems): self.maximumNumberOfAntecedentItems = maximumNumberOfAntecedentItems
    def get_minimumNumberOfConsequentItems(self): return self.minimumNumberOfConsequentItems
    def set_minimumNumberOfConsequentItems(self, minimumNumberOfConsequentItems): self.minimumNumberOfConsequentItems = minimumNumberOfConsequentItems
    def get_maximumNumberOfConsequentItems(self): return self.maximumNumberOfConsequentItems
    def set_maximumNumberOfConsequentItems(self, maximumNumberOfConsequentItems): self.maximumNumberOfConsequentItems = maximumNumberOfConsequentItems
    def get_minimumSupport(self): return self.minimumSupport
    def set_minimumSupport(self, minimumSupport): self.minimumSupport = minimumSupport
    def get_minimumConfidence(self): return self.minimumConfidence
    def set_minimumConfidence(self, minimumConfidence): self.minimumConfidence = minimumConfidence
    def get_minimumLift(self): return self.minimumLift
    def set_minimumLift(self, minimumLift): self.minimumLift = minimumLift
    def get_minimumTotalSequenceTime(self): return self.minimumTotalSequenceTime
    def set_minimumTotalSequenceTime(self, minimumTotalSequenceTime): self.minimumTotalSequenceTime = minimumTotalSequenceTime
    def get_maximumTotalSequenceTime(self): return self.maximumTotalSequenceTime
    def set_maximumTotalSequenceTime(self, maximumTotalSequenceTime): self.maximumTotalSequenceTime = maximumTotalSequenceTime
    def get_minimumItemsetSeparationTime(self): return self.minimumItemsetSeparationTime
    def set_minimumItemsetSeparationTime(self, minimumItemsetSeparationTime): self.minimumItemsetSeparationTime = minimumItemsetSeparationTime
    def get_maximumItemsetSeparationTime(self): return self.maximumItemsetSeparationTime
    def set_maximumItemsetSeparationTime(self, maximumItemsetSeparationTime): self.maximumItemsetSeparationTime = maximumItemsetSeparationTime
    def get_minimumAntConsSeparationTime(self): return self.minimumAntConsSeparationTime
    def set_minimumAntConsSeparationTime(self, minimumAntConsSeparationTime): self.minimumAntConsSeparationTime = minimumAntConsSeparationTime
    def get_maximumAntConsSeparationTime(self): return self.maximumAntConsSeparationTime
    def set_maximumAntConsSeparationTime(self, maximumAntConsSeparationTime): self.maximumAntConsSeparationTime = maximumAntConsSeparationTime
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Constraints', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Constraints')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Constraints')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Constraints', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Constraints'):
        if self.minimumNumberOfItems != 1 and 'minimumNumberOfItems' not in already_processed:
            already_processed.add('minimumNumberOfItems')
            outfile.write(' minimumNumberOfItems="%s"' % self.gds_format_integer(self.minimumNumberOfItems, input_name='minimumNumberOfItems'))
        if self.maximumNumberOfItems is not None and 'maximumNumberOfItems' not in already_processed:
            already_processed.add('maximumNumberOfItems')
            outfile.write(' maximumNumberOfItems="%s"' % self.gds_format_integer(self.maximumNumberOfItems, input_name='maximumNumberOfItems'))
        if self.minimumNumberOfAntecedentItems != 1 and 'minimumNumberOfAntecedentItems' not in already_processed:
            already_processed.add('minimumNumberOfAntecedentItems')
            outfile.write(' minimumNumberOfAntecedentItems="%s"' % self.gds_format_integer(self.minimumNumberOfAntecedentItems, input_name='minimumNumberOfAntecedentItems'))
        if self.maximumNumberOfAntecedentItems is not None and 'maximumNumberOfAntecedentItems' not in already_processed:
            already_processed.add('maximumNumberOfAntecedentItems')
            outfile.write(' maximumNumberOfAntecedentItems="%s"' % self.gds_format_integer(self.maximumNumberOfAntecedentItems, input_name='maximumNumberOfAntecedentItems'))
        if self.minimumNumberOfConsequentItems != 1 and 'minimumNumberOfConsequentItems' not in already_processed:
            already_processed.add('minimumNumberOfConsequentItems')
            outfile.write(' minimumNumberOfConsequentItems="%s"' % self.gds_format_integer(self.minimumNumberOfConsequentItems, input_name='minimumNumberOfConsequentItems'))
        if self.maximumNumberOfConsequentItems is not None and 'maximumNumberOfConsequentItems' not in already_processed:
            already_processed.add('maximumNumberOfConsequentItems')
            outfile.write(' maximumNumberOfConsequentItems="%s"' % self.gds_format_integer(self.maximumNumberOfConsequentItems, input_name='maximumNumberOfConsequentItems'))
        if self.minimumSupport != 0 and 'minimumSupport' not in already_processed:
            already_processed.add('minimumSupport')
            outfile.write(' minimumSupport=%s' % (quote_attrib(self.minimumSupport), ))
        if self.minimumConfidence != 0 and 'minimumConfidence' not in already_processed:
            already_processed.add('minimumConfidence')
            outfile.write(' minimumConfidence=%s' % (quote_attrib(self.minimumConfidence), ))
        if self.minimumLift != 0 and 'minimumLift' not in already_processed:
            already_processed.add('minimumLift')
            outfile.write(' minimumLift=%s' % (quote_attrib(self.minimumLift), ))
        if self.minimumTotalSequenceTime != 0 and 'minimumTotalSequenceTime' not in already_processed:
            already_processed.add('minimumTotalSequenceTime')
            outfile.write(' minimumTotalSequenceTime=%s' % (quote_attrib(self.minimumTotalSequenceTime), ))
        if self.maximumTotalSequenceTime is not None and 'maximumTotalSequenceTime' not in already_processed:
            already_processed.add('maximumTotalSequenceTime')
            outfile.write(' maximumTotalSequenceTime=%s' % (quote_attrib(self.maximumTotalSequenceTime), ))
        if self.minimumItemsetSeparationTime != 0 and 'minimumItemsetSeparationTime' not in already_processed:
            already_processed.add('minimumItemsetSeparationTime')
            outfile.write(' minimumItemsetSeparationTime=%s' % (quote_attrib(self.minimumItemsetSeparationTime), ))
        if self.maximumItemsetSeparationTime is not None and 'maximumItemsetSeparationTime' not in already_processed:
            already_processed.add('maximumItemsetSeparationTime')
            outfile.write(' maximumItemsetSeparationTime=%s' % (quote_attrib(self.maximumItemsetSeparationTime), ))
        if self.minimumAntConsSeparationTime != 0 and 'minimumAntConsSeparationTime' not in already_processed:
            already_processed.add('minimumAntConsSeparationTime')
            outfile.write(' minimumAntConsSeparationTime=%s' % (quote_attrib(self.minimumAntConsSeparationTime), ))
        if self.maximumAntConsSeparationTime is not None and 'maximumAntConsSeparationTime' not in already_processed:
            already_processed.add('maximumAntConsSeparationTime')
            outfile.write(' maximumAntConsSeparationTime=%s' % (quote_attrib(self.maximumAntConsSeparationTime), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Constraints', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Constraints', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.minimumNumberOfItems is not None:
            element.set('minimumNumberOfItems', self.gds_format_integer(self.minimumNumberOfItems))
        if self.maximumNumberOfItems is not None:
            element.set('maximumNumberOfItems', self.gds_format_integer(self.maximumNumberOfItems))
        if self.minimumNumberOfAntecedentItems is not None:
            element.set('minimumNumberOfAntecedentItems', self.gds_format_integer(self.minimumNumberOfAntecedentItems))
        if self.maximumNumberOfAntecedentItems is not None:
            element.set('maximumNumberOfAntecedentItems', self.gds_format_integer(self.maximumNumberOfAntecedentItems))
        if self.minimumNumberOfConsequentItems is not None:
            element.set('minimumNumberOfConsequentItems', self.gds_format_integer(self.minimumNumberOfConsequentItems))
        if self.maximumNumberOfConsequentItems is not None:
            element.set('maximumNumberOfConsequentItems', self.gds_format_integer(self.maximumNumberOfConsequentItems))
        if self.minimumSupport is not None:
            element.set('minimumSupport', self.minimumSupport)
        if self.minimumConfidence is not None:
            element.set('minimumConfidence', self.minimumConfidence)
        if self.minimumLift is not None:
            element.set('minimumLift', self.minimumLift)
        if self.minimumTotalSequenceTime is not None:
            element.set('minimumTotalSequenceTime', self.minimumTotalSequenceTime)
        if self.maximumTotalSequenceTime is not None:
            element.set('maximumTotalSequenceTime', self.maximumTotalSequenceTime)
        if self.minimumItemsetSeparationTime is not None:
            element.set('minimumItemsetSeparationTime', self.minimumItemsetSeparationTime)
        if self.maximumItemsetSeparationTime is not None:
            element.set('maximumItemsetSeparationTime', self.maximumItemsetSeparationTime)
        if self.minimumAntConsSeparationTime is not None:
            element.set('minimumAntConsSeparationTime', self.minimumAntConsSeparationTime)
        if self.maximumAntConsSeparationTime is not None:
            element.set('maximumAntConsSeparationTime', self.maximumAntConsSeparationTime)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Constraints'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.minimumNumberOfItems is not None and 'minimumNumberOfItems' not in already_processed:
            already_processed.add('minimumNumberOfItems')
            showIndent(outfile, level)
            outfile.write('minimumNumberOfItems=%d,\n' % (self.minimumNumberOfItems,))
        if self.maximumNumberOfItems is not None and 'maximumNumberOfItems' not in already_processed:
            already_processed.add('maximumNumberOfItems')
            showIndent(outfile, level)
            outfile.write('maximumNumberOfItems=%d,\n' % (self.maximumNumberOfItems,))
        if self.minimumNumberOfAntecedentItems is not None and 'minimumNumberOfAntecedentItems' not in already_processed:
            already_processed.add('minimumNumberOfAntecedentItems')
            showIndent(outfile, level)
            outfile.write('minimumNumberOfAntecedentItems=%d,\n' % (self.minimumNumberOfAntecedentItems,))
        if self.maximumNumberOfAntecedentItems is not None and 'maximumNumberOfAntecedentItems' not in already_processed:
            already_processed.add('maximumNumberOfAntecedentItems')
            showIndent(outfile, level)
            outfile.write('maximumNumberOfAntecedentItems=%d,\n' % (self.maximumNumberOfAntecedentItems,))
        if self.minimumNumberOfConsequentItems is not None and 'minimumNumberOfConsequentItems' not in already_processed:
            already_processed.add('minimumNumberOfConsequentItems')
            showIndent(outfile, level)
            outfile.write('minimumNumberOfConsequentItems=%d,\n' % (self.minimumNumberOfConsequentItems,))
        if self.maximumNumberOfConsequentItems is not None and 'maximumNumberOfConsequentItems' not in already_processed:
            already_processed.add('maximumNumberOfConsequentItems')
            showIndent(outfile, level)
            outfile.write('maximumNumberOfConsequentItems=%d,\n' % (self.maximumNumberOfConsequentItems,))
        if self.minimumSupport is not None and 'minimumSupport' not in already_processed:
            already_processed.add('minimumSupport')
            showIndent(outfile, level)
            outfile.write('minimumSupport=%e,\n' % (self.minimumSupport,))
        if self.minimumConfidence is not None and 'minimumConfidence' not in already_processed:
            already_processed.add('minimumConfidence')
            showIndent(outfile, level)
            outfile.write('minimumConfidence=%e,\n' % (self.minimumConfidence,))
        if self.minimumLift is not None and 'minimumLift' not in already_processed:
            already_processed.add('minimumLift')
            showIndent(outfile, level)
            outfile.write('minimumLift=%e,\n' % (self.minimumLift,))
        if self.minimumTotalSequenceTime is not None and 'minimumTotalSequenceTime' not in already_processed:
            already_processed.add('minimumTotalSequenceTime')
            showIndent(outfile, level)
            outfile.write('minimumTotalSequenceTime=%e,\n' % (self.minimumTotalSequenceTime,))
        if self.maximumTotalSequenceTime is not None and 'maximumTotalSequenceTime' not in already_processed:
            already_processed.add('maximumTotalSequenceTime')
            showIndent(outfile, level)
            outfile.write('maximumTotalSequenceTime=%e,\n' % (self.maximumTotalSequenceTime,))
        if self.minimumItemsetSeparationTime is not None and 'minimumItemsetSeparationTime' not in already_processed:
            already_processed.add('minimumItemsetSeparationTime')
            showIndent(outfile, level)
            outfile.write('minimumItemsetSeparationTime=%e,\n' % (self.minimumItemsetSeparationTime,))
        if self.maximumItemsetSeparationTime is not None and 'maximumItemsetSeparationTime' not in already_processed:
            already_processed.add('maximumItemsetSeparationTime')
            showIndent(outfile, level)
            outfile.write('maximumItemsetSeparationTime=%e,\n' % (self.maximumItemsetSeparationTime,))
        if self.minimumAntConsSeparationTime is not None and 'minimumAntConsSeparationTime' not in already_processed:
            already_processed.add('minimumAntConsSeparationTime')
            showIndent(outfile, level)
            outfile.write('minimumAntConsSeparationTime=%e,\n' % (self.minimumAntConsSeparationTime,))
        if self.maximumAntConsSeparationTime is not None and 'maximumAntConsSeparationTime' not in already_processed:
            already_processed.add('maximumAntConsSeparationTime')
            showIndent(outfile, level)
            outfile.write('maximumAntConsSeparationTime=%e,\n' % (self.maximumAntConsSeparationTime,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimumNumberOfItems', node)
        if value is not None and 'minimumNumberOfItems' not in already_processed:
            already_processed.add('minimumNumberOfItems')
            try:
                self.minimumNumberOfItems = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.minimumNumberOfItems < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('maximumNumberOfItems', node)
        if value is not None and 'maximumNumberOfItems' not in already_processed:
            already_processed.add('maximumNumberOfItems')
            try:
                self.maximumNumberOfItems = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.maximumNumberOfItems < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('minimumNumberOfAntecedentItems', node)
        if value is not None and 'minimumNumberOfAntecedentItems' not in already_processed:
            already_processed.add('minimumNumberOfAntecedentItems')
            try:
                self.minimumNumberOfAntecedentItems = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.minimumNumberOfAntecedentItems < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('maximumNumberOfAntecedentItems', node)
        if value is not None and 'maximumNumberOfAntecedentItems' not in already_processed:
            already_processed.add('maximumNumberOfAntecedentItems')
            try:
                self.maximumNumberOfAntecedentItems = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.maximumNumberOfAntecedentItems < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('minimumNumberOfConsequentItems', node)
        if value is not None and 'minimumNumberOfConsequentItems' not in already_processed:
            already_processed.add('minimumNumberOfConsequentItems')
            try:
                self.minimumNumberOfConsequentItems = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.minimumNumberOfConsequentItems < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('maximumNumberOfConsequentItems', node)
        if value is not None and 'maximumNumberOfConsequentItems' not in already_processed:
            already_processed.add('maximumNumberOfConsequentItems')
            try:
                self.maximumNumberOfConsequentItems = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.maximumNumberOfConsequentItems < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('minimumSupport', node)
        if value is not None and 'minimumSupport' not in already_processed:
            already_processed.add('minimumSupport')
            try:
                self.minimumSupport = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (minimumSupport): %s' % exp)
            self.validate_REAL_NUMBER(self.minimumSupport)    # validate type REAL-NUMBER
        value = find_attr_value_('minimumConfidence', node)
        if value is not None and 'minimumConfidence' not in already_processed:
            already_processed.add('minimumConfidence')
            try:
                self.minimumConfidence = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (minimumConfidence): %s' % exp)
            self.validate_REAL_NUMBER(self.minimumConfidence)    # validate type REAL-NUMBER
        value = find_attr_value_('minimumLift', node)
        if value is not None and 'minimumLift' not in already_processed:
            already_processed.add('minimumLift')
            try:
                self.minimumLift = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (minimumLift): %s' % exp)
            self.validate_REAL_NUMBER(self.minimumLift)    # validate type REAL-NUMBER
        value = find_attr_value_('minimumTotalSequenceTime', node)
        if value is not None and 'minimumTotalSequenceTime' not in already_processed:
            already_processed.add('minimumTotalSequenceTime')
            try:
                self.minimumTotalSequenceTime = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (minimumTotalSequenceTime): %s' % exp)
            self.validate_REAL_NUMBER(self.minimumTotalSequenceTime)    # validate type REAL-NUMBER
        value = find_attr_value_('maximumTotalSequenceTime', node)
        if value is not None and 'maximumTotalSequenceTime' not in already_processed:
            already_processed.add('maximumTotalSequenceTime')
            try:
                self.maximumTotalSequenceTime = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (maximumTotalSequenceTime): %s' % exp)
            self.validate_REAL_NUMBER(self.maximumTotalSequenceTime)    # validate type REAL-NUMBER
        value = find_attr_value_('minimumItemsetSeparationTime', node)
        if value is not None and 'minimumItemsetSeparationTime' not in already_processed:
            already_processed.add('minimumItemsetSeparationTime')
            try:
                self.minimumItemsetSeparationTime = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (minimumItemsetSeparationTime): %s' % exp)
            self.validate_REAL_NUMBER(self.minimumItemsetSeparationTime)    # validate type REAL-NUMBER
        value = find_attr_value_('maximumItemsetSeparationTime', node)
        if value is not None and 'maximumItemsetSeparationTime' not in already_processed:
            already_processed.add('maximumItemsetSeparationTime')
            try:
                self.maximumItemsetSeparationTime = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (maximumItemsetSeparationTime): %s' % exp)
            self.validate_REAL_NUMBER(self.maximumItemsetSeparationTime)    # validate type REAL-NUMBER
        value = find_attr_value_('minimumAntConsSeparationTime', node)
        if value is not None and 'minimumAntConsSeparationTime' not in already_processed:
            already_processed.add('minimumAntConsSeparationTime')
            try:
                self.minimumAntConsSeparationTime = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (minimumAntConsSeparationTime): %s' % exp)
            self.validate_REAL_NUMBER(self.minimumAntConsSeparationTime)    # validate type REAL-NUMBER
        value = find_attr_value_('maximumAntConsSeparationTime', node)
        if value is not None and 'maximumAntConsSeparationTime' not in already_processed:
            already_processed.add('maximumAntConsSeparationTime')
            try:
                self.maximumAntConsSeparationTime = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (maximumAntConsSeparationTime): %s' % exp)
            self.validate_REAL_NUMBER(self.maximumAntConsSeparationTime)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Constraints


class SetPredicate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, field=None, operator=None, Extension=None, Array=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.field = _cast(None, field)
        self.operator = _cast(None, operator)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SetPredicate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SetPredicate.subclass:
            return SetPredicate.subclass(*args_, **kwargs_)
        else:
            return SetPredicate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_operator(self): return self.operator
    def set_operator(self, operator): self.operator = operator
    def validate_ELEMENT_ID(self, value):
        # Validate type ELEMENT-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SetPredicate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SetPredicate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SetPredicate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SetPredicate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SetPredicate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.operator), input_name='operator')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SetPredicate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SetPredicate', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.id is not None:
            element.set('id', self.id)
        if self.field is not None:
            element.set('field', self.field)
        if self.operator is not None:
            element.set('operator', self.gds_format_string(self.operator))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SetPredicate'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            showIndent(outfile, level)
            outfile.write('operator="%s",\n' % (self.operator,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ELEMENT_ID(self.id)    # validate type ELEMENT-ID
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class SetPredicate


class Delimiter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, delimiter=None, gap=None, Extension=None):
        self.original_tagname_ = None
        self.delimiter = _cast(None, delimiter)
        self.gap = _cast(None, gap)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Delimiter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Delimiter.subclass:
            return Delimiter.subclass(*args_, **kwargs_)
        else:
            return Delimiter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_delimiter(self): return self.delimiter
    def set_delimiter(self, delimiter): self.delimiter = delimiter
    def get_gap(self): return self.gap
    def set_gap(self, gap): self.gap = gap
    def validate_DELIMITER(self, value):
        # Validate type DELIMITER, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['sameTimeWindow', 'acrossTimeWindows']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DELIMITER' % {"value" : value.encode("utf-8")} )
    def validate_GAP(self, value):
        # Validate type GAP, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['true', 'false', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on GAP' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Delimiter', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Delimiter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Delimiter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Delimiter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Delimiter'):
        if self.delimiter is not None and 'delimiter' not in already_processed:
            already_processed.add('delimiter')
            outfile.write(' delimiter=%s' % (quote_attrib(self.delimiter), ))
        if self.gap is not None and 'gap' not in already_processed:
            already_processed.add('gap')
            outfile.write(' gap=%s' % (quote_attrib(self.gap), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Delimiter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Delimiter', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.delimiter is not None:
            element.set('delimiter', self.delimiter)
        if self.gap is not None:
            element.set('gap', self.gap)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Delimiter'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.delimiter is not None and 'delimiter' not in already_processed:
            already_processed.add('delimiter')
            showIndent(outfile, level)
            outfile.write('delimiter="%s",\n' % (self.delimiter,))
        if self.gap is not None and 'gap' not in already_processed:
            already_processed.add('gap')
            showIndent(outfile, level)
            outfile.write('gap="%s",\n' % (self.gap,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('delimiter', node)
        if value is not None and 'delimiter' not in already_processed:
            already_processed.add('delimiter')
            self.delimiter = value
            self.validate_DELIMITER(self.delimiter)    # validate type DELIMITER
        value = find_attr_value_('gap', node)
        if value is not None and 'gap' not in already_processed:
            already_processed.add('gap')
            self.gap = value
            self.validate_GAP(self.gap)    # validate type GAP
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Delimiter


class Time(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, min=None, max=None, mean=None, standardDeviation=None, Extension=None):
        self.original_tagname_ = None
        self.min = _cast(None, min)
        self.max = _cast(None, max)
        self.mean = _cast(None, mean)
        self.standardDeviation = _cast(None, standardDeviation)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Time)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Time.subclass:
            return Time.subclass(*args_, **kwargs_)
        else:
            return Time(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_min(self): return self.min
    def set_min(self, min): self.min = min
    def get_max(self): return self.max
    def set_max(self, max): self.max = max
    def get_mean(self): return self.mean
    def set_mean(self, mean): self.mean = mean
    def get_standardDeviation(self): return self.standardDeviation
    def set_standardDeviation(self, standardDeviation): self.standardDeviation = standardDeviation
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Time', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Time')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Time')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Time', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Time'):
        if self.min is not None and 'min' not in already_processed:
            already_processed.add('min')
            outfile.write(' min=%s' % (quote_attrib(self.min), ))
        if self.max is not None and 'max' not in already_processed:
            already_processed.add('max')
            outfile.write(' max=%s' % (quote_attrib(self.max), ))
        if self.mean is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            outfile.write(' mean=%s' % (quote_attrib(self.mean), ))
        if self.standardDeviation is not None and 'standardDeviation' not in already_processed:
            already_processed.add('standardDeviation')
            outfile.write(' standardDeviation=%s' % (quote_attrib(self.standardDeviation), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Time', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Time', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.min is not None:
            element.set('min', self.min)
        if self.max is not None:
            element.set('max', self.max)
        if self.mean is not None:
            element.set('mean', self.mean)
        if self.standardDeviation is not None:
            element.set('standardDeviation', self.standardDeviation)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Time'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.min is not None and 'min' not in already_processed:
            already_processed.add('min')
            showIndent(outfile, level)
            outfile.write('min=%e,\n' % (self.min,))
        if self.max is not None and 'max' not in already_processed:
            already_processed.add('max')
            showIndent(outfile, level)
            outfile.write('max=%e,\n' % (self.max,))
        if self.mean is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            showIndent(outfile, level)
            outfile.write('mean=%e,\n' % (self.mean,))
        if self.standardDeviation is not None and 'standardDeviation' not in already_processed:
            already_processed.add('standardDeviation')
            showIndent(outfile, level)
            outfile.write('standardDeviation=%e,\n' % (self.standardDeviation,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('min', node)
        if value is not None and 'min' not in already_processed:
            already_processed.add('min')
            try:
                self.min = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (min): %s' % exp)
            self.validate_NUMBER(self.min)    # validate type NUMBER
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.add('max')
            try:
                self.max = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (max): %s' % exp)
            self.validate_NUMBER(self.max)    # validate type NUMBER
        value = find_attr_value_('mean', node)
        if value is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            try:
                self.mean = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (mean): %s' % exp)
            self.validate_NUMBER(self.mean)    # validate type NUMBER
        value = find_attr_value_('standardDeviation', node)
        if value is not None and 'standardDeviation' not in already_processed:
            already_processed.add('standardDeviation')
            try:
                self.standardDeviation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (standardDeviation): %s' % exp)
            self.validate_NUMBER(self.standardDeviation)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Time


class Sequence(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, numberOfSets=None, occurrence=None, support=None, Extension=None, Delimiter=None, SetReference=None, Time=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.numberOfSets = _cast(int, numberOfSets)
        self.occurrence = _cast(None, occurrence)
        self.support = _cast(None, support)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Delimiter is None:
            self.Delimiter = []
        else:
            self.Delimiter = Delimiter
        if SetReference is None:
            self.SetReference = []
        else:
            self.SetReference = SetReference
        self.Time = Time
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Sequence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Sequence.subclass:
            return Sequence.subclass(*args_, **kwargs_)
        else:
            return Sequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Delimiter(self): return self.Delimiter
    def set_Delimiter(self, Delimiter): self.Delimiter = Delimiter
    def add_Delimiter(self, value): self.Delimiter.append(value)
    def insert_Delimiter_at(self, index, value): self.Delimiter.insert(index, value)
    def replace_Delimiter_at(self, index, value): self.Delimiter[index] = value
    def get_SetReference(self): return self.SetReference
    def set_SetReference(self, SetReference): self.SetReference = SetReference
    def add_SetReference(self, value): self.SetReference.append(value)
    def insert_SetReference_at(self, index, value): self.SetReference.insert(index, value)
    def replace_SetReference_at(self, index, value): self.SetReference[index] = value
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_numberOfSets(self): return self.numberOfSets
    def set_numberOfSets(self, numberOfSets): self.numberOfSets = numberOfSets
    def get_occurrence(self): return self.occurrence
    def set_occurrence(self, occurrence): self.occurrence = occurrence
    def get_support(self): return self.support
    def set_support(self, support): self.support = support
    def validate_ELEMENT_ID(self, value):
        # Validate type ELEMENT-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Delimiter or
            self.SetReference or
            self.Time is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Sequence', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Sequence')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Sequence')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Sequence', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Sequence'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.numberOfSets is not None and 'numberOfSets' not in already_processed:
            already_processed.add('numberOfSets')
            outfile.write(' numberOfSets="%s"' % self.gds_format_integer(self.numberOfSets, input_name='numberOfSets'))
        if self.occurrence is not None and 'occurrence' not in already_processed:
            already_processed.add('occurrence')
            outfile.write(' occurrence=%s' % (quote_attrib(self.occurrence), ))
        if self.support is not None and 'support' not in already_processed:
            already_processed.add('support')
            outfile.write(' support=%s' % (quote_attrib(self.support), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Sequence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Delimiter_ in self.Delimiter:
            Delimiter_.export(outfile, level, namespace_, name_='Delimiter', pretty_print=pretty_print)
        for SetReference_ in self.SetReference:
            SetReference_.export(outfile, level, namespace_, name_='SetReference', pretty_print=pretty_print)
        if self.Time is not None:
            self.Time.export(outfile, level, namespace_, name_='Time', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Sequence', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.id is not None:
            element.set('id', self.id)
        if self.numberOfSets is not None:
            element.set('numberOfSets', self.gds_format_integer(self.numberOfSets))
        if self.occurrence is not None:
            element.set('occurrence', self.occurrence)
        if self.support is not None:
            element.set('support', self.support)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Delimiter_ in self.Delimiter:
            Delimiter_.to_etree(element, name_='Delimiter', mapping_=mapping_)
        for SetReference_ in self.SetReference:
            SetReference_.to_etree(element, name_='SetReference', mapping_=mapping_)
        if self.Time is not None:
            Time_ = self.Time
            Time_.to_etree(element, name_='Time', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Sequence'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.numberOfSets is not None and 'numberOfSets' not in already_processed:
            already_processed.add('numberOfSets')
            showIndent(outfile, level)
            outfile.write('numberOfSets=%d,\n' % (self.numberOfSets,))
        if self.occurrence is not None and 'occurrence' not in already_processed:
            already_processed.add('occurrence')
            showIndent(outfile, level)
            outfile.write('occurrence=%d,\n' % (self.occurrence,))
        if self.support is not None and 'support' not in already_processed:
            already_processed.add('support')
            showIndent(outfile, level)
            outfile.write('support=%e,\n' % (self.support,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Delimiter=[\n')
        level += 1
        for Delimiter_ in self.Delimiter:
            showIndent(outfile, level)
            outfile.write('model_.Delimiter(\n')
            Delimiter_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SetReference=[\n')
        level += 1
        for SetReference_ in self.SetReference:
            showIndent(outfile, level)
            outfile.write('model_.SetReference(\n')
            SetReference_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=model_.Time(\n')
            self.Time.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ELEMENT_ID(self.id)    # validate type ELEMENT-ID
        value = find_attr_value_('numberOfSets', node)
        if value is not None and 'numberOfSets' not in already_processed:
            already_processed.add('numberOfSets')
            try:
                self.numberOfSets = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfSets < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('occurrence', node)
        if value is not None and 'occurrence' not in already_processed:
            already_processed.add('occurrence')
            try:
                self.occurrence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.occurrence)    # validate type INT-NUMBER
        value = find_attr_value_('support', node)
        if value is not None and 'support' not in already_processed:
            already_processed.add('support')
            try:
                self.support = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (support): %s' % exp)
            self.validate_REAL_NUMBER(self.support)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Delimiter':
            obj_ = Delimiter.factory()
            obj_.build(child_)
            self.Delimiter.append(obj_)
            obj_.original_tagname_ = 'Delimiter'
        elif nodeName_ == 'SetReference':
            obj_ = SetReference.factory()
            obj_.build(child_)
            self.SetReference.append(obj_)
            obj_.original_tagname_ = 'SetReference'
        elif nodeName_ == 'Time':
            obj_ = Time.factory()
            obj_.build(child_)
            self.Time = obj_
            obj_.original_tagname_ = 'Time'
# end class Sequence


class SetReference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, setId=None, Extension=None):
        self.original_tagname_ = None
        self.setId = _cast(None, setId)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SetReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SetReference.subclass:
            return SetReference.subclass(*args_, **kwargs_)
        else:
            return SetReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_setId(self): return self.setId
    def set_setId(self, setId): self.setId = setId
    def validate_ELEMENT_ID(self, value):
        # Validate type ELEMENT-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SetReference', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SetReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SetReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SetReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SetReference'):
        if self.setId is not None and 'setId' not in already_processed:
            already_processed.add('setId')
            outfile.write(' setId=%s' % (quote_attrib(self.setId), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SetReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SetReference', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.setId is not None:
            element.set('setId', self.setId)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SetReference'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.setId is not None and 'setId' not in already_processed:
            already_processed.add('setId')
            showIndent(outfile, level)
            outfile.write('setId="%s",\n' % (self.setId,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('setId', node)
        if value is not None and 'setId' not in already_processed:
            already_processed.add('setId')
            self.setId = value
            self.validate_ELEMENT_ID(self.setId)    # validate type ELEMENT-ID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class SetReference


class SequenceRule(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, numberOfSets=None, occurrence=None, support=None, confidence=None, lift=None, Extension=None, AntecedentSequence=None, Delimiter=None, ConsequentSequence=None, Time=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.numberOfSets = _cast(int, numberOfSets)
        self.occurrence = _cast(None, occurrence)
        self.support = _cast(None, support)
        self.confidence = _cast(None, confidence)
        self.lift = _cast(None, lift)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.AntecedentSequence = AntecedentSequence
        self.Delimiter = Delimiter
        self.ConsequentSequence = ConsequentSequence
        self.Time = Time
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SequenceRule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SequenceRule.subclass:
            return SequenceRule.subclass(*args_, **kwargs_)
        else:
            return SequenceRule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_AntecedentSequence(self): return self.AntecedentSequence
    def set_AntecedentSequence(self, AntecedentSequence): self.AntecedentSequence = AntecedentSequence
    def get_Delimiter(self): return self.Delimiter
    def set_Delimiter(self, Delimiter): self.Delimiter = Delimiter
    def get_ConsequentSequence(self): return self.ConsequentSequence
    def set_ConsequentSequence(self, ConsequentSequence): self.ConsequentSequence = ConsequentSequence
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_numberOfSets(self): return self.numberOfSets
    def set_numberOfSets(self, numberOfSets): self.numberOfSets = numberOfSets
    def get_occurrence(self): return self.occurrence
    def set_occurrence(self, occurrence): self.occurrence = occurrence
    def get_support(self): return self.support
    def set_support(self, support): self.support = support
    def get_confidence(self): return self.confidence
    def set_confidence(self, confidence): self.confidence = confidence
    def get_lift(self): return self.lift
    def set_lift(self, lift): self.lift = lift
    def validate_ELEMENT_ID(self, value):
        # Validate type ELEMENT-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.AntecedentSequence is not None or
            self.Delimiter is not None or
            self.ConsequentSequence is not None or
            self.Time is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SequenceRule', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SequenceRule')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SequenceRule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SequenceRule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SequenceRule'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.numberOfSets is not None and 'numberOfSets' not in already_processed:
            already_processed.add('numberOfSets')
            outfile.write(' numberOfSets="%s"' % self.gds_format_integer(self.numberOfSets, input_name='numberOfSets'))
        if self.occurrence is not None and 'occurrence' not in already_processed:
            already_processed.add('occurrence')
            outfile.write(' occurrence=%s' % (quote_attrib(self.occurrence), ))
        if self.support is not None and 'support' not in already_processed:
            already_processed.add('support')
            outfile.write(' support=%s' % (quote_attrib(self.support), ))
        if self.confidence is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            outfile.write(' confidence=%s' % (quote_attrib(self.confidence), ))
        if self.lift is not None and 'lift' not in already_processed:
            already_processed.add('lift')
            outfile.write(' lift=%s' % (quote_attrib(self.lift), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SequenceRule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.AntecedentSequence is not None:
            self.AntecedentSequence.export(outfile, level, namespace_, name_='AntecedentSequence', pretty_print=pretty_print)
        if self.Delimiter is not None:
            self.Delimiter.export(outfile, level, namespace_, name_='Delimiter', pretty_print=pretty_print)
        if self.ConsequentSequence is not None:
            self.ConsequentSequence.export(outfile, level, namespace_, name_='ConsequentSequence', pretty_print=pretty_print)
        if self.Time is not None:
            self.Time.export(outfile, level, namespace_, name_='Time', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SequenceRule', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.id is not None:
            element.set('id', self.id)
        if self.numberOfSets is not None:
            element.set('numberOfSets', self.gds_format_integer(self.numberOfSets))
        if self.occurrence is not None:
            element.set('occurrence', self.occurrence)
        if self.support is not None:
            element.set('support', self.support)
        if self.confidence is not None:
            element.set('confidence', self.confidence)
        if self.lift is not None:
            element.set('lift', self.lift)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.AntecedentSequence is not None:
            AntecedentSequence_ = self.AntecedentSequence
            AntecedentSequence_.to_etree(element, name_='AntecedentSequence', mapping_=mapping_)
        if self.Delimiter is not None:
            Delimiter_ = self.Delimiter
            Delimiter_.to_etree(element, name_='Delimiter', mapping_=mapping_)
        if self.ConsequentSequence is not None:
            ConsequentSequence_ = self.ConsequentSequence
            ConsequentSequence_.to_etree(element, name_='ConsequentSequence', mapping_=mapping_)
        if self.Time is not None:
            Time_ = self.Time
            Time_.to_etree(element, name_='Time', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SequenceRule'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.numberOfSets is not None and 'numberOfSets' not in already_processed:
            already_processed.add('numberOfSets')
            showIndent(outfile, level)
            outfile.write('numberOfSets=%d,\n' % (self.numberOfSets,))
        if self.occurrence is not None and 'occurrence' not in already_processed:
            already_processed.add('occurrence')
            showIndent(outfile, level)
            outfile.write('occurrence=%d,\n' % (self.occurrence,))
        if self.support is not None and 'support' not in already_processed:
            already_processed.add('support')
            showIndent(outfile, level)
            outfile.write('support=%e,\n' % (self.support,))
        if self.confidence is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            showIndent(outfile, level)
            outfile.write('confidence=%e,\n' % (self.confidence,))
        if self.lift is not None and 'lift' not in already_processed:
            already_processed.add('lift')
            showIndent(outfile, level)
            outfile.write('lift=%e,\n' % (self.lift,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.AntecedentSequence is not None:
            showIndent(outfile, level)
            outfile.write('AntecedentSequence=model_.AntecedentSequence(\n')
            self.AntecedentSequence.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('Delimiter=model_.Delimiter(\n')
            self.Delimiter.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ConsequentSequence is not None:
            showIndent(outfile, level)
            outfile.write('ConsequentSequence=model_.ConsequentSequence(\n')
            self.ConsequentSequence.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=model_.Time(\n')
            self.Time.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ELEMENT_ID(self.id)    # validate type ELEMENT-ID
        value = find_attr_value_('numberOfSets', node)
        if value is not None and 'numberOfSets' not in already_processed:
            already_processed.add('numberOfSets')
            try:
                self.numberOfSets = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfSets < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('occurrence', node)
        if value is not None and 'occurrence' not in already_processed:
            already_processed.add('occurrence')
            try:
                self.occurrence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.occurrence)    # validate type INT-NUMBER
        value = find_attr_value_('support', node)
        if value is not None and 'support' not in already_processed:
            already_processed.add('support')
            try:
                self.support = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (support): %s' % exp)
            self.validate_REAL_NUMBER(self.support)    # validate type REAL-NUMBER
        value = find_attr_value_('confidence', node)
        if value is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            try:
                self.confidence = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (confidence): %s' % exp)
            self.validate_REAL_NUMBER(self.confidence)    # validate type REAL-NUMBER
        value = find_attr_value_('lift', node)
        if value is not None and 'lift' not in already_processed:
            already_processed.add('lift')
            try:
                self.lift = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lift): %s' % exp)
            self.validate_REAL_NUMBER(self.lift)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'AntecedentSequence':
            obj_ = AntecedentSequence.factory()
            obj_.build(child_)
            self.AntecedentSequence = obj_
            obj_.original_tagname_ = 'AntecedentSequence'
        elif nodeName_ == 'Delimiter':
            obj_ = Delimiter.factory()
            obj_.build(child_)
            self.Delimiter = obj_
            obj_.original_tagname_ = 'Delimiter'
        elif nodeName_ == 'ConsequentSequence':
            obj_ = ConsequentSequence.factory()
            obj_.build(child_)
            self.ConsequentSequence = obj_
            obj_.original_tagname_ = 'ConsequentSequence'
        elif nodeName_ == 'Time':
            obj_ = Time.factory()
            obj_.build(child_)
            self.Time = obj_
            obj_.original_tagname_ = 'Time'
# end class SequenceRule


class SequenceReference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, seqId=None, Extension=None):
        self.original_tagname_ = None
        self.seqId = _cast(None, seqId)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SequenceReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SequenceReference.subclass:
            return SequenceReference.subclass(*args_, **kwargs_)
        else:
            return SequenceReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_seqId(self): return self.seqId
    def set_seqId(self, seqId): self.seqId = seqId
    def validate_ELEMENT_ID(self, value):
        # Validate type ELEMENT-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SequenceReference', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SequenceReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SequenceReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SequenceReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SequenceReference'):
        if self.seqId is not None and 'seqId' not in already_processed:
            already_processed.add('seqId')
            outfile.write(' seqId=%s' % (quote_attrib(self.seqId), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SequenceReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SequenceReference', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.seqId is not None:
            element.set('seqId', self.seqId)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SequenceReference'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.seqId is not None and 'seqId' not in already_processed:
            already_processed.add('seqId')
            showIndent(outfile, level)
            outfile.write('seqId="%s",\n' % (self.seqId,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('seqId', node)
        if value is not None and 'seqId' not in already_processed:
            already_processed.add('seqId')
            self.seqId = value
            self.validate_ELEMENT_ID(self.seqId)    # validate type ELEMENT-ID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class SequenceReference


class AntecedentSequence(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, SequenceReference=None, Time=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.SequenceReference = SequenceReference
        self.Time = Time
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AntecedentSequence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AntecedentSequence.subclass:
            return AntecedentSequence.subclass(*args_, **kwargs_)
        else:
            return AntecedentSequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_SequenceReference(self): return self.SequenceReference
    def set_SequenceReference(self, SequenceReference): self.SequenceReference = SequenceReference
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def hasContent_(self):
        if (
            self.Extension or
            self.SequenceReference is not None or
            self.Time is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AntecedentSequence', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AntecedentSequence')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AntecedentSequence')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AntecedentSequence', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AntecedentSequence'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AntecedentSequence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.SequenceReference is not None:
            self.SequenceReference.export(outfile, level, namespace_, name_='SequenceReference', pretty_print=pretty_print)
        if self.Time is not None:
            self.Time.export(outfile, level, namespace_, name_='Time', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AntecedentSequence', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.SequenceReference is not None:
            SequenceReference_ = self.SequenceReference
            SequenceReference_.to_etree(element, name_='SequenceReference', mapping_=mapping_)
        if self.Time is not None:
            Time_ = self.Time
            Time_.to_etree(element, name_='Time', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='AntecedentSequence'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SequenceReference is not None:
            showIndent(outfile, level)
            outfile.write('SequenceReference=model_.SequenceReference(\n')
            self.SequenceReference.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=model_.Time(\n')
            self.Time.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'SequenceReference':
            obj_ = SequenceReference.factory()
            obj_.build(child_)
            self.SequenceReference = obj_
            obj_.original_tagname_ = 'SequenceReference'
        elif nodeName_ == 'Time':
            obj_ = Time.factory()
            obj_.build(child_)
            self.Time = obj_
            obj_.original_tagname_ = 'Time'
# end class AntecedentSequence


class ConsequentSequence(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, SequenceReference=None, Time=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.SequenceReference = SequenceReference
        self.Time = Time
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConsequentSequence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConsequentSequence.subclass:
            return ConsequentSequence.subclass(*args_, **kwargs_)
        else:
            return ConsequentSequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_SequenceReference(self): return self.SequenceReference
    def set_SequenceReference(self, SequenceReference): self.SequenceReference = SequenceReference
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def hasContent_(self):
        if (
            self.Extension or
            self.SequenceReference is not None or
            self.Time is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConsequentSequence', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConsequentSequence')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConsequentSequence')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConsequentSequence', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConsequentSequence'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConsequentSequence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.SequenceReference is not None:
            self.SequenceReference.export(outfile, level, namespace_, name_='SequenceReference', pretty_print=pretty_print)
        if self.Time is not None:
            self.Time.export(outfile, level, namespace_, name_='Time', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ConsequentSequence', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.SequenceReference is not None:
            SequenceReference_ = self.SequenceReference
            SequenceReference_.to_etree(element, name_='SequenceReference', mapping_=mapping_)
        if self.Time is not None:
            Time_ = self.Time
            Time_.to_etree(element, name_='Time', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ConsequentSequence'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SequenceReference is not None:
            showIndent(outfile, level)
            outfile.write('SequenceReference=model_.SequenceReference(\n')
            self.SequenceReference.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=model_.Time(\n')
            self.Time.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'SequenceReference':
            obj_ = SequenceReference.factory()
            obj_.build(child_)
            self.SequenceReference = obj_
            obj_.original_tagname_ = 'SequenceReference'
        elif nodeName_ == 'Time':
            obj_ = Time.factory()
            obj_.build(child_)
            self.Time = obj_
            obj_.original_tagname_ = 'Time'
# end class ConsequentSequence


class ModelVerification(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, recordCount=None, fieldCount=None, Extension=None, VerificationFields=None, InlineTable=None):
        self.original_tagname_ = None
        self.recordCount = _cast(None, recordCount)
        self.fieldCount = _cast(None, fieldCount)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.VerificationFields = VerificationFields
        self.InlineTable = InlineTable
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ModelVerification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ModelVerification.subclass:
            return ModelVerification.subclass(*args_, **kwargs_)
        else:
            return ModelVerification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_VerificationFields(self): return self.VerificationFields
    def set_VerificationFields(self, VerificationFields): self.VerificationFields = VerificationFields
    def get_InlineTable(self): return self.InlineTable
    def set_InlineTable(self, InlineTable): self.InlineTable = InlineTable
    def get_recordCount(self): return self.recordCount
    def set_recordCount(self, recordCount): self.recordCount = recordCount
    def get_fieldCount(self): return self.fieldCount
    def set_fieldCount(self, fieldCount): self.fieldCount = fieldCount
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.VerificationFields is not None or
            self.InlineTable is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ModelVerification', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ModelVerification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModelVerification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ModelVerification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ModelVerification'):
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            outfile.write(' recordCount=%s' % (quote_attrib(self.recordCount), ))
        if self.fieldCount is not None and 'fieldCount' not in already_processed:
            already_processed.add('fieldCount')
            outfile.write(' fieldCount=%s' % (quote_attrib(self.fieldCount), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ModelVerification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.VerificationFields is not None:
            self.VerificationFields.export(outfile, level, namespace_, name_='VerificationFields', pretty_print=pretty_print)
        if self.InlineTable is not None:
            self.InlineTable.export(outfile, level, namespace_, name_='InlineTable', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ModelVerification', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.recordCount is not None:
            element.set('recordCount', self.recordCount)
        if self.fieldCount is not None:
            element.set('fieldCount', self.fieldCount)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.VerificationFields is not None:
            VerificationFields_ = self.VerificationFields
            VerificationFields_.to_etree(element, name_='VerificationFields', mapping_=mapping_)
        if self.InlineTable is not None:
            InlineTable_ = self.InlineTable
            InlineTable_.to_etree(element, name_='InlineTable', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ModelVerification'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            showIndent(outfile, level)
            outfile.write('recordCount=%d,\n' % (self.recordCount,))
        if self.fieldCount is not None and 'fieldCount' not in already_processed:
            already_processed.add('fieldCount')
            showIndent(outfile, level)
            outfile.write('fieldCount=%d,\n' % (self.fieldCount,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.VerificationFields is not None:
            showIndent(outfile, level)
            outfile.write('VerificationFields=model_.VerificationFields(\n')
            self.VerificationFields.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InlineTable is not None:
            showIndent(outfile, level)
            outfile.write('InlineTable=model_.InlineTable(\n')
            self.InlineTable.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('recordCount', node)
        if value is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            try:
                self.recordCount = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.recordCount)    # validate type INT-NUMBER
        value = find_attr_value_('fieldCount', node)
        if value is not None and 'fieldCount' not in already_processed:
            already_processed.add('fieldCount')
            try:
                self.fieldCount = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.fieldCount)    # validate type INT-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'VerificationFields':
            obj_ = VerificationFields.factory()
            obj_.build(child_)
            self.VerificationFields = obj_
            obj_.original_tagname_ = 'VerificationFields'
        elif nodeName_ == 'InlineTable':
            obj_ = InlineTable.factory()
            obj_.build(child_)
            self.InlineTable = obj_
            obj_.original_tagname_ = 'InlineTable'
# end class ModelVerification


class VerificationFields(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, VerificationField=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if VerificationField is None:
            self.VerificationField = []
        else:
            self.VerificationField = VerificationField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerificationFields)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerificationFields.subclass:
            return VerificationFields.subclass(*args_, **kwargs_)
        else:
            return VerificationFields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_VerificationField(self): return self.VerificationField
    def set_VerificationField(self, VerificationField): self.VerificationField = VerificationField
    def add_VerificationField(self, value): self.VerificationField.append(value)
    def insert_VerificationField_at(self, index, value): self.VerificationField.insert(index, value)
    def replace_VerificationField_at(self, index, value): self.VerificationField[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.VerificationField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VerificationFields', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VerificationFields')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerificationFields')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VerificationFields', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VerificationFields'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VerificationFields', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for VerificationField_ in self.VerificationField:
            VerificationField_.export(outfile, level, namespace_, name_='VerificationField', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='VerificationFields', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for VerificationField_ in self.VerificationField:
            VerificationField_.to_etree(element, name_='VerificationField', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='VerificationFields'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('VerificationField=[\n')
        level += 1
        for VerificationField_ in self.VerificationField:
            showIndent(outfile, level)
            outfile.write('model_.VerificationField(\n')
            VerificationField_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'VerificationField':
            obj_ = VerificationField.factory()
            obj_.build(child_)
            self.VerificationField.append(obj_)
            obj_.original_tagname_ = 'VerificationField'
# end class VerificationFields


class VerificationField(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, column=None, precision=1E-6, zeroThreshold=1E-16, Extension=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.column = _cast(None, column)
        self.precision = _cast(float, precision)
        self.zeroThreshold = _cast(float, zeroThreshold)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerificationField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerificationField.subclass:
            return VerificationField.subclass(*args_, **kwargs_)
        else:
            return VerificationField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_zeroThreshold(self): return self.zeroThreshold
    def set_zeroThreshold(self, zeroThreshold): self.zeroThreshold = zeroThreshold
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VerificationField', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VerificationField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerificationField')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VerificationField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VerificationField'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.column is not None and 'column' not in already_processed:
            already_processed.add('column')
            outfile.write(' column=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.column), input_name='column')), ))
        if self.precision != 1E-6 and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision="%s"' % self.gds_format_double(self.precision, input_name='precision'))
        if self.zeroThreshold != 1E-16 and 'zeroThreshold' not in already_processed:
            already_processed.add('zeroThreshold')
            outfile.write(' zeroThreshold="%s"' % self.gds_format_double(self.zeroThreshold, input_name='zeroThreshold'))
    def exportChildren(self, outfile, level, namespace_='', name_='VerificationField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='VerificationField', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.column is not None:
            element.set('column', self.gds_format_string(self.column))
        if self.precision is not None:
            element.set('precision', self.gds_format_double(self.precision))
        if self.zeroThreshold is not None:
            element.set('zeroThreshold', self.gds_format_double(self.zeroThreshold))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='VerificationField'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.column is not None and 'column' not in already_processed:
            already_processed.add('column')
            showIndent(outfile, level)
            outfile.write('column="%s",\n' % (self.column,))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            showIndent(outfile, level)
            outfile.write('precision=%e,\n' % (self.precision,))
        if self.zeroThreshold is not None and 'zeroThreshold' not in already_processed:
            already_processed.add('zeroThreshold')
            showIndent(outfile, level)
            outfile.write('zeroThreshold=%e,\n' % (self.zeroThreshold,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('column', node)
        if value is not None and 'column' not in already_processed:
            already_processed.add('column')
            self.column = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            try:
                self.precision = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (precision): %s' % exp)
        value = find_attr_value_('zeroThreshold', node)
        if value is not None and 'zeroThreshold' not in already_processed:
            already_processed.add('zeroThreshold')
            try:
                self.zeroThreshold = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (zeroThreshold): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class VerificationField


class GeneralRegressionModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, targetVariableName=None, modelType=None, modelName=None, functionName=None, algorithmName=None, targetReferenceCategory=None, cumulativeLink=None, linkFunction=None, linkParameter=None, trialsVariable=None, trialsValue=None, distribution=None, distParameter=None, offsetVariable=None, offsetValue=None, modelDF=None, endTimeVariable=None, startTimeVariable=None, subjectIDVariable=None, statusVariable=None, baselineStrataVariable=None, isScorable=True, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, ParameterList=None, FactorList=None, CovariateList=None, PPMatrix=None, PCovMatrix=None, ParamMatrix=None, EventValues=None, BaseCumHazardTables=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.targetVariableName = _cast(None, targetVariableName)
        self.modelType = _cast(None, modelType)
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.targetReferenceCategory = _cast(None, targetReferenceCategory)
        self.cumulativeLink = _cast(None, cumulativeLink)
        self.linkFunction = _cast(None, linkFunction)
        self.linkParameter = _cast(None, linkParameter)
        self.trialsVariable = _cast(None, trialsVariable)
        self.trialsValue = _cast(None, trialsValue)
        self.distribution = _cast(None, distribution)
        self.distParameter = _cast(None, distParameter)
        self.offsetVariable = _cast(None, offsetVariable)
        self.offsetValue = _cast(None, offsetValue)
        self.modelDF = _cast(None, modelDF)
        self.endTimeVariable = _cast(None, endTimeVariable)
        self.startTimeVariable = _cast(None, startTimeVariable)
        self.subjectIDVariable = _cast(None, subjectIDVariable)
        self.statusVariable = _cast(None, statusVariable)
        self.baselineStrataVariable = _cast(None, baselineStrataVariable)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.ModelExplanation = ModelExplanation
        self.Targets = Targets
        self.LocalTransformations = LocalTransformations
        self.ParameterList = ParameterList
        self.FactorList = FactorList
        self.CovariateList = CovariateList
        self.PPMatrix = PPMatrix
        self.PCovMatrix = PCovMatrix
        self.ParamMatrix = ParamMatrix
        self.EventValues = EventValues
        self.BaseCumHazardTables = BaseCumHazardTables
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralRegressionModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralRegressionModel.subclass:
            return GeneralRegressionModel.subclass(*args_, **kwargs_)
        else:
            return GeneralRegressionModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_ModelExplanation(self): return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation): self.ModelExplanation = ModelExplanation
    def get_Targets(self): return self.Targets
    def set_Targets(self, Targets): self.Targets = Targets
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_ParameterList(self): return self.ParameterList
    def set_ParameterList(self, ParameterList): self.ParameterList = ParameterList
    def get_FactorList(self): return self.FactorList
    def set_FactorList(self, FactorList): self.FactorList = FactorList
    def get_CovariateList(self): return self.CovariateList
    def set_CovariateList(self, CovariateList): self.CovariateList = CovariateList
    def get_PPMatrix(self): return self.PPMatrix
    def set_PPMatrix(self, PPMatrix): self.PPMatrix = PPMatrix
    def get_PCovMatrix(self): return self.PCovMatrix
    def set_PCovMatrix(self, PCovMatrix): self.PCovMatrix = PCovMatrix
    def get_ParamMatrix(self): return self.ParamMatrix
    def set_ParamMatrix(self, ParamMatrix): self.ParamMatrix = ParamMatrix
    def get_EventValues(self): return self.EventValues
    def set_EventValues(self, EventValues): self.EventValues = EventValues
    def get_BaseCumHazardTables(self): return self.BaseCumHazardTables
    def set_BaseCumHazardTables(self, BaseCumHazardTables): self.BaseCumHazardTables = BaseCumHazardTables
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_targetVariableName(self): return self.targetVariableName
    def set_targetVariableName(self, targetVariableName): self.targetVariableName = targetVariableName
    def get_modelType(self): return self.modelType
    def set_modelType(self, modelType): self.modelType = modelType
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_targetReferenceCategory(self): return self.targetReferenceCategory
    def set_targetReferenceCategory(self, targetReferenceCategory): self.targetReferenceCategory = targetReferenceCategory
    def get_cumulativeLink(self): return self.cumulativeLink
    def set_cumulativeLink(self, cumulativeLink): self.cumulativeLink = cumulativeLink
    def get_linkFunction(self): return self.linkFunction
    def set_linkFunction(self, linkFunction): self.linkFunction = linkFunction
    def get_linkParameter(self): return self.linkParameter
    def set_linkParameter(self, linkParameter): self.linkParameter = linkParameter
    def get_trialsVariable(self): return self.trialsVariable
    def set_trialsVariable(self, trialsVariable): self.trialsVariable = trialsVariable
    def get_trialsValue(self): return self.trialsValue
    def set_trialsValue(self, trialsValue): self.trialsValue = trialsValue
    def get_distribution(self): return self.distribution
    def set_distribution(self, distribution): self.distribution = distribution
    def get_distParameter(self): return self.distParameter
    def set_distParameter(self, distParameter): self.distParameter = distParameter
    def get_offsetVariable(self): return self.offsetVariable
    def set_offsetVariable(self, offsetVariable): self.offsetVariable = offsetVariable
    def get_offsetValue(self): return self.offsetValue
    def set_offsetValue(self, offsetValue): self.offsetValue = offsetValue
    def get_modelDF(self): return self.modelDF
    def set_modelDF(self, modelDF): self.modelDF = modelDF
    def get_endTimeVariable(self): return self.endTimeVariable
    def set_endTimeVariable(self, endTimeVariable): self.endTimeVariable = endTimeVariable
    def get_startTimeVariable(self): return self.startTimeVariable
    def set_startTimeVariable(self, startTimeVariable): self.startTimeVariable = startTimeVariable
    def get_subjectIDVariable(self): return self.subjectIDVariable
    def set_subjectIDVariable(self, subjectIDVariable): self.subjectIDVariable = subjectIDVariable
    def get_statusVariable(self): return self.statusVariable
    def set_statusVariable(self, statusVariable): self.statusVariable = statusVariable
    def get_baselineStrataVariable(self): return self.baselineStrataVariable
    def set_baselineStrataVariable(self, baselineStrataVariable): self.baselineStrataVariable = baselineStrataVariable
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_CUMULATIVE_LINK_FUNCTION(self, value):
        # Validate type CUMULATIVE-LINK-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['logit', 'probit', 'cloglog', 'loglog', 'cauchit']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CUMULATIVE-LINK-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_LINK_FUNCTION(self, value):
        # Validate type LINK-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['cloglog', 'identity', 'log', 'logc', 'logit', 'loglog', 'negbin', 'oddspower', 'power', 'probit']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LINK-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.ParameterList is not None or
            self.FactorList is not None or
            self.CovariateList is not None or
            self.PPMatrix is not None or
            self.PCovMatrix is not None or
            self.ParamMatrix is not None or
            self.EventValues is not None or
            self.BaseCumHazardTables is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GeneralRegressionModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeneralRegressionModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeneralRegressionModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GeneralRegressionModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeneralRegressionModel'):
        if self.targetVariableName is not None and 'targetVariableName' not in already_processed:
            already_processed.add('targetVariableName')
            outfile.write(' targetVariableName=%s' % (quote_attrib(self.targetVariableName), ))
        if self.modelType is not None and 'modelType' not in already_processed:
            already_processed.add('modelType')
            outfile.write(' modelType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelType), input_name='modelType')), ))
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.targetReferenceCategory is not None and 'targetReferenceCategory' not in already_processed:
            already_processed.add('targetReferenceCategory')
            outfile.write(' targetReferenceCategory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetReferenceCategory), input_name='targetReferenceCategory')), ))
        if self.cumulativeLink is not None and 'cumulativeLink' not in already_processed:
            already_processed.add('cumulativeLink')
            outfile.write(' cumulativeLink=%s' % (quote_attrib(self.cumulativeLink), ))
        if self.linkFunction is not None and 'linkFunction' not in already_processed:
            already_processed.add('linkFunction')
            outfile.write(' linkFunction=%s' % (quote_attrib(self.linkFunction), ))
        if self.linkParameter is not None and 'linkParameter' not in already_processed:
            already_processed.add('linkParameter')
            outfile.write(' linkParameter=%s' % (quote_attrib(self.linkParameter), ))
        if self.trialsVariable is not None and 'trialsVariable' not in already_processed:
            already_processed.add('trialsVariable')
            outfile.write(' trialsVariable=%s' % (quote_attrib(self.trialsVariable), ))
        if self.trialsValue is not None and 'trialsValue' not in already_processed:
            already_processed.add('trialsValue')
            outfile.write(' trialsValue=%s' % (quote_attrib(self.trialsValue), ))
        if self.distribution is not None and 'distribution' not in already_processed:
            already_processed.add('distribution')
            outfile.write(' distribution=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.distribution), input_name='distribution')), ))
        if self.distParameter is not None and 'distParameter' not in already_processed:
            already_processed.add('distParameter')
            outfile.write(' distParameter=%s' % (quote_attrib(self.distParameter), ))
        if self.offsetVariable is not None and 'offsetVariable' not in already_processed:
            already_processed.add('offsetVariable')
            outfile.write(' offsetVariable=%s' % (quote_attrib(self.offsetVariable), ))
        if self.offsetValue is not None and 'offsetValue' not in already_processed:
            already_processed.add('offsetValue')
            outfile.write(' offsetValue=%s' % (quote_attrib(self.offsetValue), ))
        if self.modelDF is not None and 'modelDF' not in already_processed:
            already_processed.add('modelDF')
            outfile.write(' modelDF=%s' % (quote_attrib(self.modelDF), ))
        if self.endTimeVariable is not None and 'endTimeVariable' not in already_processed:
            already_processed.add('endTimeVariable')
            outfile.write(' endTimeVariable=%s' % (quote_attrib(self.endTimeVariable), ))
        if self.startTimeVariable is not None and 'startTimeVariable' not in already_processed:
            already_processed.add('startTimeVariable')
            outfile.write(' startTimeVariable=%s' % (quote_attrib(self.startTimeVariable), ))
        if self.subjectIDVariable is not None and 'subjectIDVariable' not in already_processed:
            already_processed.add('subjectIDVariable')
            outfile.write(' subjectIDVariable=%s' % (quote_attrib(self.subjectIDVariable), ))
        if self.statusVariable is not None and 'statusVariable' not in already_processed:
            already_processed.add('statusVariable')
            outfile.write(' statusVariable=%s' % (quote_attrib(self.statusVariable), ))
        if self.baselineStrataVariable is not None and 'baselineStrataVariable' not in already_processed:
            already_processed.add('baselineStrataVariable')
            outfile.write(' baselineStrataVariable=%s' % (quote_attrib(self.baselineStrataVariable), ))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='GeneralRegressionModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            self.ModelExplanation.export(outfile, level, namespace_, name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            self.Targets.export(outfile, level, namespace_, name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        if self.ParameterList is not None:
            self.ParameterList.export(outfile, level, namespace_, name_='ParameterList', pretty_print=pretty_print)
        if self.FactorList is not None:
            self.FactorList.export(outfile, level, namespace_, name_='FactorList', pretty_print=pretty_print)
        if self.CovariateList is not None:
            self.CovariateList.export(outfile, level, namespace_, name_='CovariateList', pretty_print=pretty_print)
        if self.PPMatrix is not None:
            self.PPMatrix.export(outfile, level, namespace_, name_='PPMatrix', pretty_print=pretty_print)
        if self.PCovMatrix is not None:
            self.PCovMatrix.export(outfile, level, namespace_, name_='PCovMatrix', pretty_print=pretty_print)
        if self.ParamMatrix is not None:
            self.ParamMatrix.export(outfile, level, namespace_, name_='ParamMatrix', pretty_print=pretty_print)
        if self.EventValues is not None:
            self.EventValues.export(outfile, level, namespace_, name_='EventValues', pretty_print=pretty_print)
        if self.BaseCumHazardTables is not None:
            self.BaseCumHazardTables.export(outfile, level, namespace_, name_='BaseCumHazardTables', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GeneralRegressionModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.targetVariableName is not None:
            element.set('targetVariableName', self.targetVariableName)
        if self.modelType is not None:
            element.set('modelType', self.gds_format_string(self.modelType))
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.targetReferenceCategory is not None:
            element.set('targetReferenceCategory', self.gds_format_string(self.targetReferenceCategory))
        if self.cumulativeLink is not None:
            element.set('cumulativeLink', self.cumulativeLink)
        if self.linkFunction is not None:
            element.set('linkFunction', self.linkFunction)
        if self.linkParameter is not None:
            element.set('linkParameter', self.linkParameter)
        if self.trialsVariable is not None:
            element.set('trialsVariable', self.trialsVariable)
        if self.trialsValue is not None:
            element.set('trialsValue', self.trialsValue)
        if self.distribution is not None:
            element.set('distribution', self.gds_format_string(self.distribution))
        if self.distParameter is not None:
            element.set('distParameter', self.distParameter)
        if self.offsetVariable is not None:
            element.set('offsetVariable', self.offsetVariable)
        if self.offsetValue is not None:
            element.set('offsetValue', self.offsetValue)
        if self.modelDF is not None:
            element.set('modelDF', self.modelDF)
        if self.endTimeVariable is not None:
            element.set('endTimeVariable', self.endTimeVariable)
        if self.startTimeVariable is not None:
            element.set('startTimeVariable', self.startTimeVariable)
        if self.subjectIDVariable is not None:
            element.set('subjectIDVariable', self.subjectIDVariable)
        if self.statusVariable is not None:
            element.set('statusVariable', self.statusVariable)
        if self.baselineStrataVariable is not None:
            element.set('baselineStrataVariable', self.baselineStrataVariable)
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.ModelExplanation is not None:
            ModelExplanation_ = self.ModelExplanation
            ModelExplanation_.to_etree(element, name_='ModelExplanation', mapping_=mapping_)
        if self.Targets is not None:
            Targets_ = self.Targets
            Targets_.to_etree(element, name_='Targets', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        if self.ParameterList is not None:
            ParameterList_ = self.ParameterList
            ParameterList_.to_etree(element, name_='ParameterList', mapping_=mapping_)
        if self.FactorList is not None:
            FactorList_ = self.FactorList
            FactorList_.to_etree(element, name_='FactorList', mapping_=mapping_)
        if self.CovariateList is not None:
            CovariateList_ = self.CovariateList
            CovariateList_.to_etree(element, name_='CovariateList', mapping_=mapping_)
        if self.PPMatrix is not None:
            PPMatrix_ = self.PPMatrix
            PPMatrix_.to_etree(element, name_='PPMatrix', mapping_=mapping_)
        if self.PCovMatrix is not None:
            PCovMatrix_ = self.PCovMatrix
            PCovMatrix_.to_etree(element, name_='PCovMatrix', mapping_=mapping_)
        if self.ParamMatrix is not None:
            ParamMatrix_ = self.ParamMatrix
            ParamMatrix_.to_etree(element, name_='ParamMatrix', mapping_=mapping_)
        if self.EventValues is not None:
            EventValues_ = self.EventValues
            EventValues_.to_etree(element, name_='EventValues', mapping_=mapping_)
        if self.BaseCumHazardTables is not None:
            BaseCumHazardTables_ = self.BaseCumHazardTables
            BaseCumHazardTables_.to_etree(element, name_='BaseCumHazardTables', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='GeneralRegressionModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.targetVariableName is not None and 'targetVariableName' not in already_processed:
            already_processed.add('targetVariableName')
            showIndent(outfile, level)
            outfile.write('targetVariableName="%s",\n' % (self.targetVariableName,))
        if self.modelType is not None and 'modelType' not in already_processed:
            already_processed.add('modelType')
            showIndent(outfile, level)
            outfile.write('modelType="%s",\n' % (self.modelType,))
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.targetReferenceCategory is not None and 'targetReferenceCategory' not in already_processed:
            already_processed.add('targetReferenceCategory')
            showIndent(outfile, level)
            outfile.write('targetReferenceCategory="%s",\n' % (self.targetReferenceCategory,))
        if self.cumulativeLink is not None and 'cumulativeLink' not in already_processed:
            already_processed.add('cumulativeLink')
            showIndent(outfile, level)
            outfile.write('cumulativeLink="%s",\n' % (self.cumulativeLink,))
        if self.linkFunction is not None and 'linkFunction' not in already_processed:
            already_processed.add('linkFunction')
            showIndent(outfile, level)
            outfile.write('linkFunction="%s",\n' % (self.linkFunction,))
        if self.linkParameter is not None and 'linkParameter' not in already_processed:
            already_processed.add('linkParameter')
            showIndent(outfile, level)
            outfile.write('linkParameter=%e,\n' % (self.linkParameter,))
        if self.trialsVariable is not None and 'trialsVariable' not in already_processed:
            already_processed.add('trialsVariable')
            showIndent(outfile, level)
            outfile.write('trialsVariable="%s",\n' % (self.trialsVariable,))
        if self.trialsValue is not None and 'trialsValue' not in already_processed:
            already_processed.add('trialsValue')
            showIndent(outfile, level)
            outfile.write('trialsValue=%d,\n' % (self.trialsValue,))
        if self.distribution is not None and 'distribution' not in already_processed:
            already_processed.add('distribution')
            showIndent(outfile, level)
            outfile.write('distribution="%s",\n' % (self.distribution,))
        if self.distParameter is not None and 'distParameter' not in already_processed:
            already_processed.add('distParameter')
            showIndent(outfile, level)
            outfile.write('distParameter=%e,\n' % (self.distParameter,))
        if self.offsetVariable is not None and 'offsetVariable' not in already_processed:
            already_processed.add('offsetVariable')
            showIndent(outfile, level)
            outfile.write('offsetVariable="%s",\n' % (self.offsetVariable,))
        if self.offsetValue is not None and 'offsetValue' not in already_processed:
            already_processed.add('offsetValue')
            showIndent(outfile, level)
            outfile.write('offsetValue=%e,\n' % (self.offsetValue,))
        if self.modelDF is not None and 'modelDF' not in already_processed:
            already_processed.add('modelDF')
            showIndent(outfile, level)
            outfile.write('modelDF=%e,\n' % (self.modelDF,))
        if self.endTimeVariable is not None and 'endTimeVariable' not in already_processed:
            already_processed.add('endTimeVariable')
            showIndent(outfile, level)
            outfile.write('endTimeVariable="%s",\n' % (self.endTimeVariable,))
        if self.startTimeVariable is not None and 'startTimeVariable' not in already_processed:
            already_processed.add('startTimeVariable')
            showIndent(outfile, level)
            outfile.write('startTimeVariable="%s",\n' % (self.startTimeVariable,))
        if self.subjectIDVariable is not None and 'subjectIDVariable' not in already_processed:
            already_processed.add('subjectIDVariable')
            showIndent(outfile, level)
            outfile.write('subjectIDVariable="%s",\n' % (self.subjectIDVariable,))
        if self.statusVariable is not None and 'statusVariable' not in already_processed:
            already_processed.add('statusVariable')
            showIndent(outfile, level)
            outfile.write('statusVariable="%s",\n' % (self.statusVariable,))
        if self.baselineStrataVariable is not None and 'baselineStrataVariable' not in already_processed:
            already_processed.add('baselineStrataVariable')
            showIndent(outfile, level)
            outfile.write('baselineStrataVariable="%s",\n' % (self.baselineStrataVariable,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelExplanation is not None:
            showIndent(outfile, level)
            outfile.write('ModelExplanation=model_.ModelExplanation(\n')
            self.ModelExplanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targets is not None:
            showIndent(outfile, level)
            outfile.write('Targets=model_.Targets(\n')
            self.Targets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ParameterList is not None:
            showIndent(outfile, level)
            outfile.write('ParameterList=model_.ParameterList(\n')
            self.ParameterList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FactorList is not None:
            showIndent(outfile, level)
            outfile.write('FactorList=model_.FactorList(\n')
            self.FactorList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CovariateList is not None:
            showIndent(outfile, level)
            outfile.write('CovariateList=model_.CovariateList(\n')
            self.CovariateList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PPMatrix is not None:
            showIndent(outfile, level)
            outfile.write('PPMatrix=model_.PPMatrix(\n')
            self.PPMatrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PCovMatrix is not None:
            showIndent(outfile, level)
            outfile.write('PCovMatrix=model_.PCovMatrix(\n')
            self.PCovMatrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ParamMatrix is not None:
            showIndent(outfile, level)
            outfile.write('ParamMatrix=model_.ParamMatrix(\n')
            self.ParamMatrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EventValues is not None:
            showIndent(outfile, level)
            outfile.write('EventValues=model_.EventValues(\n')
            self.EventValues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BaseCumHazardTables is not None:
            showIndent(outfile, level)
            outfile.write('BaseCumHazardTables=model_.BaseCumHazardTables(\n')
            self.BaseCumHazardTables.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('targetVariableName', node)
        if value is not None and 'targetVariableName' not in already_processed:
            already_processed.add('targetVariableName')
            self.targetVariableName = value
            self.validate_FIELD_NAME(self.targetVariableName)    # validate type FIELD-NAME
        value = find_attr_value_('modelType', node)
        if value is not None and 'modelType' not in already_processed:
            already_processed.add('modelType')
            self.modelType = value
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('targetReferenceCategory', node)
        if value is not None and 'targetReferenceCategory' not in already_processed:
            already_processed.add('targetReferenceCategory')
            self.targetReferenceCategory = value
        value = find_attr_value_('cumulativeLink', node)
        if value is not None and 'cumulativeLink' not in already_processed:
            already_processed.add('cumulativeLink')
            self.cumulativeLink = value
            self.validate_CUMULATIVE_LINK_FUNCTION(self.cumulativeLink)    # validate type CUMULATIVE-LINK-FUNCTION
        value = find_attr_value_('linkFunction', node)
        if value is not None and 'linkFunction' not in already_processed:
            already_processed.add('linkFunction')
            self.linkFunction = value
            self.validate_LINK_FUNCTION(self.linkFunction)    # validate type LINK-FUNCTION
        value = find_attr_value_('linkParameter', node)
        if value is not None and 'linkParameter' not in already_processed:
            already_processed.add('linkParameter')
            try:
                self.linkParameter = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (linkParameter): %s' % exp)
            self.validate_REAL_NUMBER(self.linkParameter)    # validate type REAL-NUMBER
        value = find_attr_value_('trialsVariable', node)
        if value is not None and 'trialsVariable' not in already_processed:
            already_processed.add('trialsVariable')
            self.trialsVariable = value
            self.validate_FIELD_NAME(self.trialsVariable)    # validate type FIELD-NAME
        value = find_attr_value_('trialsValue', node)
        if value is not None and 'trialsValue' not in already_processed:
            already_processed.add('trialsValue')
            try:
                self.trialsValue = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.trialsValue)    # validate type INT-NUMBER
        value = find_attr_value_('distribution', node)
        if value is not None and 'distribution' not in already_processed:
            already_processed.add('distribution')
            self.distribution = value
        value = find_attr_value_('distParameter', node)
        if value is not None and 'distParameter' not in already_processed:
            already_processed.add('distParameter')
            try:
                self.distParameter = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (distParameter): %s' % exp)
            self.validate_REAL_NUMBER(self.distParameter)    # validate type REAL-NUMBER
        value = find_attr_value_('offsetVariable', node)
        if value is not None and 'offsetVariable' not in already_processed:
            already_processed.add('offsetVariable')
            self.offsetVariable = value
            self.validate_FIELD_NAME(self.offsetVariable)    # validate type FIELD-NAME
        value = find_attr_value_('offsetValue', node)
        if value is not None and 'offsetValue' not in already_processed:
            already_processed.add('offsetValue')
            try:
                self.offsetValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (offsetValue): %s' % exp)
            self.validate_REAL_NUMBER(self.offsetValue)    # validate type REAL-NUMBER
        value = find_attr_value_('modelDF', node)
        if value is not None and 'modelDF' not in already_processed:
            already_processed.add('modelDF')
            try:
                self.modelDF = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (modelDF): %s' % exp)
            self.validate_REAL_NUMBER(self.modelDF)    # validate type REAL-NUMBER
        value = find_attr_value_('endTimeVariable', node)
        if value is not None and 'endTimeVariable' not in already_processed:
            already_processed.add('endTimeVariable')
            self.endTimeVariable = value
            self.validate_FIELD_NAME(self.endTimeVariable)    # validate type FIELD-NAME
        value = find_attr_value_('startTimeVariable', node)
        if value is not None and 'startTimeVariable' not in already_processed:
            already_processed.add('startTimeVariable')
            self.startTimeVariable = value
            self.validate_FIELD_NAME(self.startTimeVariable)    # validate type FIELD-NAME
        value = find_attr_value_('subjectIDVariable', node)
        if value is not None and 'subjectIDVariable' not in already_processed:
            already_processed.add('subjectIDVariable')
            self.subjectIDVariable = value
            self.validate_FIELD_NAME(self.subjectIDVariable)    # validate type FIELD-NAME
        value = find_attr_value_('statusVariable', node)
        if value is not None and 'statusVariable' not in already_processed:
            already_processed.add('statusVariable')
            self.statusVariable = value
            self.validate_FIELD_NAME(self.statusVariable)    # validate type FIELD-NAME
        value = find_attr_value_('baselineStrataVariable', node)
        if value is not None and 'baselineStrataVariable' not in already_processed:
            already_processed.add('baselineStrataVariable')
            self.baselineStrataVariable = value
            self.validate_FIELD_NAME(self.baselineStrataVariable)    # validate type FIELD-NAME
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory()
            obj_.build(child_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory()
            obj_.build(child_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'ParameterList':
            obj_ = ParameterList.factory()
            obj_.build(child_)
            self.ParameterList = obj_
            obj_.original_tagname_ = 'ParameterList'
        elif nodeName_ == 'FactorList':
            obj_ = FactorList.factory()
            obj_.build(child_)
            self.FactorList = obj_
            obj_.original_tagname_ = 'FactorList'
        elif nodeName_ == 'CovariateList':
            obj_ = CovariateList.factory()
            obj_.build(child_)
            self.CovariateList = obj_
            obj_.original_tagname_ = 'CovariateList'
        elif nodeName_ == 'PPMatrix':
            obj_ = PPMatrix.factory()
            obj_.build(child_)
            self.PPMatrix = obj_
            obj_.original_tagname_ = 'PPMatrix'
        elif nodeName_ == 'PCovMatrix':
            obj_ = PCovMatrix.factory()
            obj_.build(child_)
            self.PCovMatrix = obj_
            obj_.original_tagname_ = 'PCovMatrix'
        elif nodeName_ == 'ParamMatrix':
            obj_ = ParamMatrix.factory()
            obj_.build(child_)
            self.ParamMatrix = obj_
            obj_.original_tagname_ = 'ParamMatrix'
        elif nodeName_ == 'EventValues':
            obj_ = EventValues.factory()
            obj_.build(child_)
            self.EventValues = obj_
            obj_.original_tagname_ = 'EventValues'
        elif nodeName_ == 'BaseCumHazardTables':
            obj_ = BaseCumHazardTables.factory()
            obj_.build(child_)
            self.BaseCumHazardTables = obj_
            obj_.original_tagname_ = 'BaseCumHazardTables'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class GeneralRegressionModel


class ParameterList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Parameter=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterList.subclass:
            return ParameterList.subclass(*args_, **kwargs_)
        else:
            return ParameterList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Parameter(self): return self.Parameter
    def set_Parameter(self, Parameter): self.Parameter = Parameter
    def add_Parameter(self, value): self.Parameter.append(value)
    def insert_Parameter_at(self, index, value): self.Parameter.insert(index, value)
    def replace_Parameter_at(self, index, value): self.Parameter[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.Parameter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ParameterList', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParameterList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ParameterList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParameterList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ParameterList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Parameter_ in self.Parameter:
            Parameter_.export(outfile, level, namespace_, name_='Parameter', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ParameterList', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Parameter_ in self.Parameter:
            Parameter_.to_etree(element, name_='Parameter', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ParameterList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Parameter=[\n')
        level += 1
        for Parameter_ in self.Parameter:
            showIndent(outfile, level)
            outfile.write('model_.Parameter(\n')
            Parameter_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Parameter':
            obj_ = Parameter.factory()
            obj_.build(child_)
            self.Parameter.append(obj_)
            obj_.original_tagname_ = 'Parameter'
# end class ParameterList


class Parameter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, label=None, referencePoint='0', Extension=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.label = _cast(None, label)
        self.referencePoint = _cast(None, referencePoint)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Parameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Parameter.subclass:
            return Parameter.subclass(*args_, **kwargs_)
        else:
            return Parameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_referencePoint(self): return self.referencePoint
    def set_referencePoint(self, referencePoint): self.referencePoint = referencePoint
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Parameter', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Parameter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Parameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Parameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Parameter'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.referencePoint != 0 and 'referencePoint' not in already_processed:
            already_processed.add('referencePoint')
            outfile.write(' referencePoint=%s' % (quote_attrib(self.referencePoint), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Parameter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Parameter', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.label is not None:
            element.set('label', self.gds_format_string(self.label))
        if self.referencePoint is not None:
            element.set('referencePoint', self.referencePoint)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Parameter'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            showIndent(outfile, level)
            outfile.write('label="%s",\n' % (self.label,))
        if self.referencePoint is not None and 'referencePoint' not in already_processed:
            already_processed.add('referencePoint')
            showIndent(outfile, level)
            outfile.write('referencePoint=%e,\n' % (self.referencePoint,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('referencePoint', node)
        if value is not None and 'referencePoint' not in already_processed:
            already_processed.add('referencePoint')
            try:
                self.referencePoint = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (referencePoint): %s' % exp)
            self.validate_REAL_NUMBER(self.referencePoint)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Parameter


class FactorList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Predictor=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Predictor is None:
            self.Predictor = []
        else:
            self.Predictor = Predictor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FactorList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FactorList.subclass:
            return FactorList.subclass(*args_, **kwargs_)
        else:
            return FactorList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Predictor(self): return self.Predictor
    def set_Predictor(self, Predictor): self.Predictor = Predictor
    def add_Predictor(self, value): self.Predictor.append(value)
    def insert_Predictor_at(self, index, value): self.Predictor.insert(index, value)
    def replace_Predictor_at(self, index, value): self.Predictor[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.Predictor
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FactorList', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FactorList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FactorList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FactorList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FactorList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FactorList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Predictor_ in self.Predictor:
            Predictor_.export(outfile, level, namespace_, name_='Predictor', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='FactorList', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Predictor_ in self.Predictor:
            Predictor_.to_etree(element, name_='Predictor', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FactorList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Predictor=[\n')
        level += 1
        for Predictor_ in self.Predictor:
            showIndent(outfile, level)
            outfile.write('model_.Predictor(\n')
            Predictor_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Predictor':
            obj_ = Predictor.factory()
            obj_.build(child_)
            self.Predictor.append(obj_)
            obj_.original_tagname_ = 'Predictor'
# end class FactorList


class CovariateList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Predictor=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Predictor is None:
            self.Predictor = []
        else:
            self.Predictor = Predictor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CovariateList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CovariateList.subclass:
            return CovariateList.subclass(*args_, **kwargs_)
        else:
            return CovariateList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Predictor(self): return self.Predictor
    def set_Predictor(self, Predictor): self.Predictor = Predictor
    def add_Predictor(self, value): self.Predictor.append(value)
    def insert_Predictor_at(self, index, value): self.Predictor.insert(index, value)
    def replace_Predictor_at(self, index, value): self.Predictor[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.Predictor
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CovariateList', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CovariateList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CovariateList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CovariateList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CovariateList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CovariateList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Predictor_ in self.Predictor:
            Predictor_.export(outfile, level, namespace_, name_='Predictor', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='CovariateList', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Predictor_ in self.Predictor:
            Predictor_.to_etree(element, name_='Predictor', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='CovariateList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Predictor=[\n')
        level += 1
        for Predictor_ in self.Predictor:
            showIndent(outfile, level)
            outfile.write('model_.Predictor(\n')
            Predictor_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Predictor':
            obj_ = Predictor.factory()
            obj_.build(child_)
            self.Predictor.append(obj_)
            obj_.original_tagname_ = 'Predictor'
# end class CovariateList


class Predictor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, contrastMatrixType=None, Extension=None, Categories=None, Matrix=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.contrastMatrixType = _cast(None, contrastMatrixType)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Categories = Categories
        self.Matrix = Matrix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Predictor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Predictor.subclass:
            return Predictor.subclass(*args_, **kwargs_)
        else:
            return Predictor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Categories(self): return self.Categories
    def set_Categories(self, Categories): self.Categories = Categories
    def get_Matrix(self): return self.Matrix
    def set_Matrix(self, Matrix): self.Matrix = Matrix
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_contrastMatrixType(self): return self.contrastMatrixType
    def set_contrastMatrixType(self, contrastMatrixType): self.contrastMatrixType = contrastMatrixType
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Categories is not None or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Predictor', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Predictor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Predictor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Predictor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Predictor'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.contrastMatrixType is not None and 'contrastMatrixType' not in already_processed:
            already_processed.add('contrastMatrixType')
            outfile.write(' contrastMatrixType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.contrastMatrixType), input_name='contrastMatrixType')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Predictor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Categories is not None:
            self.Categories.export(outfile, level, namespace_, name_='Categories', pretty_print=pretty_print)
        if self.Matrix is not None:
            self.Matrix.export(outfile, level, namespace_, name_='Matrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Predictor', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.name)
        if self.contrastMatrixType is not None:
            element.set('contrastMatrixType', self.gds_format_string(self.contrastMatrixType))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Categories is not None:
            Categories_ = self.Categories
            Categories_.to_etree(element, name_='Categories', mapping_=mapping_)
        if self.Matrix is not None:
            Matrix_ = self.Matrix
            Matrix_.to_etree(element, name_='Matrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Predictor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.contrastMatrixType is not None and 'contrastMatrixType' not in already_processed:
            already_processed.add('contrastMatrixType')
            showIndent(outfile, level)
            outfile.write('contrastMatrixType="%s",\n' % (self.contrastMatrixType,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Categories is not None:
            showIndent(outfile, level)
            outfile.write('Categories=model_.Categories(\n')
            self.Categories.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Matrix is not None:
            showIndent(outfile, level)
            outfile.write('Matrix=model_.Matrix(\n')
            self.Matrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('contrastMatrixType', node)
        if value is not None and 'contrastMatrixType' not in already_processed:
            already_processed.add('contrastMatrixType')
            self.contrastMatrixType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Categories':
            obj_ = Categories.factory()
            obj_.build(child_)
            self.Categories = obj_
            obj_.original_tagname_ = 'Categories'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory()
            obj_.build(child_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class Predictor


class Categories(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Category=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Category is None:
            self.Category = []
        else:
            self.Category = Category
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Categories)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Categories.subclass:
            return Categories.subclass(*args_, **kwargs_)
        else:
            return Categories(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def add_Category(self, value): self.Category.append(value)
    def insert_Category_at(self, index, value): self.Category.insert(index, value)
    def replace_Category_at(self, index, value): self.Category[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.Category
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Categories', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Categories')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Categories')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Categories', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Categories'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Categories', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Category_ in self.Category:
            Category_.export(outfile, level, namespace_, name_='Category', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Categories', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Category_ in self.Category:
            Category_.to_etree(element, name_='Category', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Categories'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Category=[\n')
        level += 1
        for Category_ in self.Category:
            showIndent(outfile, level)
            outfile.write('model_.Category(\n')
            Category_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Category':
            obj_ = Category.factory()
            obj_.build(child_)
            self.Category.append(obj_)
            obj_.original_tagname_ = 'Category'
# end class Categories


class Category(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, Extension=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Category)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Category.subclass:
            return Category.subclass(*args_, **kwargs_)
        else:
            return Category(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Category', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Category')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Category')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Category', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Category'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Category', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Category', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Category'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Category


class PPMatrix(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, PPCell=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if PPCell is None:
            self.PPCell = []
        else:
            self.PPCell = PPCell
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PPMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PPMatrix.subclass:
            return PPMatrix.subclass(*args_, **kwargs_)
        else:
            return PPMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_PPCell(self): return self.PPCell
    def set_PPCell(self, PPCell): self.PPCell = PPCell
    def add_PPCell(self, value): self.PPCell.append(value)
    def insert_PPCell_at(self, index, value): self.PPCell.insert(index, value)
    def replace_PPCell_at(self, index, value): self.PPCell[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.PPCell
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PPMatrix', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PPMatrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PPMatrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PPMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PPMatrix'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PPMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for PPCell_ in self.PPCell:
            PPCell_.export(outfile, level, namespace_, name_='PPCell', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PPMatrix', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for PPCell_ in self.PPCell:
            PPCell_.to_etree(element, name_='PPCell', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PPMatrix'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PPCell=[\n')
        level += 1
        for PPCell_ in self.PPCell:
            showIndent(outfile, level)
            outfile.write('model_.PPCell(\n')
            PPCell_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'PPCell':
            obj_ = PPCell.factory()
            obj_.build(child_)
            self.PPCell.append(obj_)
            obj_.original_tagname_ = 'PPCell'
# end class PPMatrix


class PPCell(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, predictorName=None, parameterName=None, targetCategory=None, Extension=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.predictorName = _cast(None, predictorName)
        self.parameterName = _cast(None, parameterName)
        self.targetCategory = _cast(None, targetCategory)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PPCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PPCell.subclass:
            return PPCell.subclass(*args_, **kwargs_)
        else:
            return PPCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_predictorName(self): return self.predictorName
    def set_predictorName(self, predictorName): self.predictorName = predictorName
    def get_parameterName(self): return self.parameterName
    def set_parameterName(self, parameterName): self.parameterName = parameterName
    def get_targetCategory(self): return self.targetCategory
    def set_targetCategory(self, targetCategory): self.targetCategory = targetCategory
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PPCell', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PPCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PPCell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PPCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PPCell'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.predictorName is not None and 'predictorName' not in already_processed:
            already_processed.add('predictorName')
            outfile.write(' predictorName=%s' % (quote_attrib(self.predictorName), ))
        if self.parameterName is not None and 'parameterName' not in already_processed:
            already_processed.add('parameterName')
            outfile.write(' parameterName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parameterName), input_name='parameterName')), ))
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            outfile.write(' targetCategory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetCategory), input_name='targetCategory')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PPCell', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PPCell', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.predictorName is not None:
            element.set('predictorName', self.predictorName)
        if self.parameterName is not None:
            element.set('parameterName', self.gds_format_string(self.parameterName))
        if self.targetCategory is not None:
            element.set('targetCategory', self.gds_format_string(self.targetCategory))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PPCell'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.predictorName is not None and 'predictorName' not in already_processed:
            already_processed.add('predictorName')
            showIndent(outfile, level)
            outfile.write('predictorName="%s",\n' % (self.predictorName,))
        if self.parameterName is not None and 'parameterName' not in already_processed:
            already_processed.add('parameterName')
            showIndent(outfile, level)
            outfile.write('parameterName="%s",\n' % (self.parameterName,))
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            showIndent(outfile, level)
            outfile.write('targetCategory="%s",\n' % (self.targetCategory,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('predictorName', node)
        if value is not None and 'predictorName' not in already_processed:
            already_processed.add('predictorName')
            self.predictorName = value
            self.validate_FIELD_NAME(self.predictorName)    # validate type FIELD-NAME
        value = find_attr_value_('parameterName', node)
        if value is not None and 'parameterName' not in already_processed:
            already_processed.add('parameterName')
            self.parameterName = value
        value = find_attr_value_('targetCategory', node)
        if value is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            self.targetCategory = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class PPCell


class PCovMatrix(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, Extension=None, PCovCell=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if PCovCell is None:
            self.PCovCell = []
        else:
            self.PCovCell = PCovCell
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PCovMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PCovMatrix.subclass:
            return PCovMatrix.subclass(*args_, **kwargs_)
        else:
            return PCovMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_PCovCell(self): return self.PCovCell
    def set_PCovCell(self, PCovCell): self.PCovCell = PCovCell
    def add_PCovCell(self, value): self.PCovCell.append(value)
    def insert_PCovCell_at(self, index, value): self.PCovCell.insert(index, value)
    def replace_PCovCell_at(self, index, value): self.PCovCell[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.Extension or
            self.PCovCell
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PCovMatrix', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PCovMatrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PCovMatrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PCovMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PCovMatrix'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PCovMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for PCovCell_ in self.PCovCell:
            PCovCell_.export(outfile, level, namespace_, name_='PCovCell', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PCovMatrix', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for PCovCell_ in self.PCovCell:
            PCovCell_.to_etree(element, name_='PCovCell', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PCovMatrix'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PCovCell=[\n')
        level += 1
        for PCovCell_ in self.PCovCell:
            showIndent(outfile, level)
            outfile.write('model_.PCovCell(\n')
            PCovCell_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'PCovCell':
            obj_ = PCovCell.factory()
            obj_.build(child_)
            self.PCovCell.append(obj_)
            obj_.original_tagname_ = 'PCovCell'
# end class PCovMatrix


class PCovCell(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pRow=None, pCol=None, tRow=None, tCol=None, value=None, targetCategory=None, Extension=None):
        self.original_tagname_ = None
        self.pRow = _cast(None, pRow)
        self.pCol = _cast(None, pCol)
        self.tRow = _cast(None, tRow)
        self.tCol = _cast(None, tCol)
        self.value = _cast(None, value)
        self.targetCategory = _cast(None, targetCategory)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PCovCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PCovCell.subclass:
            return PCovCell.subclass(*args_, **kwargs_)
        else:
            return PCovCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_pRow(self): return self.pRow
    def set_pRow(self, pRow): self.pRow = pRow
    def get_pCol(self): return self.pCol
    def set_pCol(self, pCol): self.pCol = pCol
    def get_tRow(self): return self.tRow
    def set_tRow(self, tRow): self.tRow = tRow
    def get_tCol(self): return self.tCol
    def set_tCol(self, tCol): self.tCol = tCol
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_targetCategory(self): return self.targetCategory
    def set_targetCategory(self, targetCategory): self.targetCategory = targetCategory
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PCovCell', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PCovCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PCovCell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PCovCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PCovCell'):
        if self.pRow is not None and 'pRow' not in already_processed:
            already_processed.add('pRow')
            outfile.write(' pRow=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pRow), input_name='pRow')), ))
        if self.pCol is not None and 'pCol' not in already_processed:
            already_processed.add('pCol')
            outfile.write(' pCol=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pCol), input_name='pCol')), ))
        if self.tRow is not None and 'tRow' not in already_processed:
            already_processed.add('tRow')
            outfile.write(' tRow=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tRow), input_name='tRow')), ))
        if self.tCol is not None and 'tCol' not in already_processed:
            already_processed.add('tCol')
            outfile.write(' tCol=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tCol), input_name='tCol')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            outfile.write(' targetCategory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetCategory), input_name='targetCategory')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PCovCell', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PCovCell', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.pRow is not None:
            element.set('pRow', self.gds_format_string(self.pRow))
        if self.pCol is not None:
            element.set('pCol', self.gds_format_string(self.pCol))
        if self.tRow is not None:
            element.set('tRow', self.gds_format_string(self.tRow))
        if self.tCol is not None:
            element.set('tCol', self.gds_format_string(self.tCol))
        if self.value is not None:
            element.set('value', self.value)
        if self.targetCategory is not None:
            element.set('targetCategory', self.gds_format_string(self.targetCategory))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PCovCell'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.pRow is not None and 'pRow' not in already_processed:
            already_processed.add('pRow')
            showIndent(outfile, level)
            outfile.write('pRow="%s",\n' % (self.pRow,))
        if self.pCol is not None and 'pCol' not in already_processed:
            already_processed.add('pCol')
            showIndent(outfile, level)
            outfile.write('pCol="%s",\n' % (self.pCol,))
        if self.tRow is not None and 'tRow' not in already_processed:
            already_processed.add('tRow')
            showIndent(outfile, level)
            outfile.write('tRow="%s",\n' % (self.tRow,))
        if self.tCol is not None and 'tCol' not in already_processed:
            already_processed.add('tCol')
            showIndent(outfile, level)
            outfile.write('tCol="%s",\n' % (self.tCol,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value=%e,\n' % (self.value,))
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            showIndent(outfile, level)
            outfile.write('targetCategory="%s",\n' % (self.targetCategory,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pRow', node)
        if value is not None and 'pRow' not in already_processed:
            already_processed.add('pRow')
            self.pRow = value
        value = find_attr_value_('pCol', node)
        if value is not None and 'pCol' not in already_processed:
            already_processed.add('pCol')
            self.pCol = value
        value = find_attr_value_('tRow', node)
        if value is not None and 'tRow' not in already_processed:
            already_processed.add('tRow')
            self.tRow = value
        value = find_attr_value_('tCol', node)
        if value is not None and 'tCol' not in already_processed:
            already_processed.add('tCol')
            self.tCol = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
            self.validate_REAL_NUMBER(self.value)    # validate type REAL-NUMBER
        value = find_attr_value_('targetCategory', node)
        if value is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            self.targetCategory = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class PCovCell


class ParamMatrix(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, PCell=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if PCell is None:
            self.PCell = []
        else:
            self.PCell = PCell
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParamMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParamMatrix.subclass:
            return ParamMatrix.subclass(*args_, **kwargs_)
        else:
            return ParamMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_PCell(self): return self.PCell
    def set_PCell(self, PCell): self.PCell = PCell
    def add_PCell(self, value): self.PCell.append(value)
    def insert_PCell_at(self, index, value): self.PCell.insert(index, value)
    def replace_PCell_at(self, index, value): self.PCell[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.PCell
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ParamMatrix', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParamMatrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParamMatrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ParamMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParamMatrix'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ParamMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for PCell_ in self.PCell:
            PCell_.export(outfile, level, namespace_, name_='PCell', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ParamMatrix', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for PCell_ in self.PCell:
            PCell_.to_etree(element, name_='PCell', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ParamMatrix'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PCell=[\n')
        level += 1
        for PCell_ in self.PCell:
            showIndent(outfile, level)
            outfile.write('model_.PCell(\n')
            PCell_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'PCell':
            obj_ = PCell.factory()
            obj_.build(child_)
            self.PCell.append(obj_)
            obj_.original_tagname_ = 'PCell'
# end class ParamMatrix


class PCell(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, targetCategory=None, parameterName=None, beta=None, df=None, Extension=None):
        self.original_tagname_ = None
        self.targetCategory = _cast(None, targetCategory)
        self.parameterName = _cast(None, parameterName)
        self.beta = _cast(None, beta)
        self.df = _cast(None, df)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PCell.subclass:
            return PCell.subclass(*args_, **kwargs_)
        else:
            return PCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_targetCategory(self): return self.targetCategory
    def set_targetCategory(self, targetCategory): self.targetCategory = targetCategory
    def get_parameterName(self): return self.parameterName
    def set_parameterName(self, parameterName): self.parameterName = parameterName
    def get_beta(self): return self.beta
    def set_beta(self, beta): self.beta = beta
    def get_df(self): return self.df
    def set_df(self, df): self.df = df
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PCell', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PCell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PCell'):
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            outfile.write(' targetCategory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetCategory), input_name='targetCategory')), ))
        if self.parameterName is not None and 'parameterName' not in already_processed:
            already_processed.add('parameterName')
            outfile.write(' parameterName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parameterName), input_name='parameterName')), ))
        if self.beta is not None and 'beta' not in already_processed:
            already_processed.add('beta')
            outfile.write(' beta=%s' % (quote_attrib(self.beta), ))
        if self.df is not None and 'df' not in already_processed:
            already_processed.add('df')
            outfile.write(' df=%s' % (quote_attrib(self.df), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PCell', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PCell', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.targetCategory is not None:
            element.set('targetCategory', self.gds_format_string(self.targetCategory))
        if self.parameterName is not None:
            element.set('parameterName', self.gds_format_string(self.parameterName))
        if self.beta is not None:
            element.set('beta', self.beta)
        if self.df is not None:
            element.set('df', self.df)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PCell'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            showIndent(outfile, level)
            outfile.write('targetCategory="%s",\n' % (self.targetCategory,))
        if self.parameterName is not None and 'parameterName' not in already_processed:
            already_processed.add('parameterName')
            showIndent(outfile, level)
            outfile.write('parameterName="%s",\n' % (self.parameterName,))
        if self.beta is not None and 'beta' not in already_processed:
            already_processed.add('beta')
            showIndent(outfile, level)
            outfile.write('beta=%e,\n' % (self.beta,))
        if self.df is not None and 'df' not in already_processed:
            already_processed.add('df')
            showIndent(outfile, level)
            outfile.write('df=%d,\n' % (self.df,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('targetCategory', node)
        if value is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            self.targetCategory = value
        value = find_attr_value_('parameterName', node)
        if value is not None and 'parameterName' not in already_processed:
            already_processed.add('parameterName')
            self.parameterName = value
        value = find_attr_value_('beta', node)
        if value is not None and 'beta' not in already_processed:
            already_processed.add('beta')
            try:
                self.beta = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (beta): %s' % exp)
            self.validate_REAL_NUMBER(self.beta)    # validate type REAL-NUMBER
        value = find_attr_value_('df', node)
        if value is not None and 'df' not in already_processed:
            already_processed.add('df')
            try:
                self.df = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.df)    # validate type INT-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class PCell


class BaseCumHazardTables(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, maxTime=None, Extension=None, BaselineStratum=None, BaselineCell=None):
        self.original_tagname_ = None
        self.maxTime = _cast(None, maxTime)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if BaselineStratum is None:
            self.BaselineStratum = []
        else:
            self.BaselineStratum = BaselineStratum
        if BaselineCell is None:
            self.BaselineCell = []
        else:
            self.BaselineCell = BaselineCell
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseCumHazardTables)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseCumHazardTables.subclass:
            return BaseCumHazardTables.subclass(*args_, **kwargs_)
        else:
            return BaseCumHazardTables(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_BaselineStratum(self): return self.BaselineStratum
    def set_BaselineStratum(self, BaselineStratum): self.BaselineStratum = BaselineStratum
    def add_BaselineStratum(self, value): self.BaselineStratum.append(value)
    def insert_BaselineStratum_at(self, index, value): self.BaselineStratum.insert(index, value)
    def replace_BaselineStratum_at(self, index, value): self.BaselineStratum[index] = value
    def get_BaselineCell(self): return self.BaselineCell
    def set_BaselineCell(self, BaselineCell): self.BaselineCell = BaselineCell
    def add_BaselineCell(self, value): self.BaselineCell.append(value)
    def insert_BaselineCell_at(self, index, value): self.BaselineCell.insert(index, value)
    def replace_BaselineCell_at(self, index, value): self.BaselineCell[index] = value
    def get_maxTime(self): return self.maxTime
    def set_maxTime(self, maxTime): self.maxTime = maxTime
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.BaselineStratum or
            self.BaselineCell
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BaseCumHazardTables', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseCumHazardTables')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BaseCumHazardTables')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BaseCumHazardTables', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BaseCumHazardTables'):
        if self.maxTime is not None and 'maxTime' not in already_processed:
            already_processed.add('maxTime')
            outfile.write(' maxTime=%s' % (quote_attrib(self.maxTime), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BaseCumHazardTables', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for BaselineStratum_ in self.BaselineStratum:
            BaselineStratum_.export(outfile, level, namespace_, name_='BaselineStratum', pretty_print=pretty_print)
        for BaselineCell_ in self.BaselineCell:
            BaselineCell_.export(outfile, level, namespace_, name_='BaselineCell', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BaseCumHazardTables', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.maxTime is not None:
            element.set('maxTime', self.maxTime)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for BaselineStratum_ in self.BaselineStratum:
            BaselineStratum_.to_etree(element, name_='BaselineStratum', mapping_=mapping_)
        for BaselineCell_ in self.BaselineCell:
            BaselineCell_.to_etree(element, name_='BaselineCell', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BaseCumHazardTables'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.maxTime is not None and 'maxTime' not in already_processed:
            already_processed.add('maxTime')
            showIndent(outfile, level)
            outfile.write('maxTime=%e,\n' % (self.maxTime,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BaselineStratum=[\n')
        level += 1
        for BaselineStratum_ in self.BaselineStratum:
            showIndent(outfile, level)
            outfile.write('model_.BaselineStratum(\n')
            BaselineStratum_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BaselineCell=[\n')
        level += 1
        for BaselineCell_ in self.BaselineCell:
            showIndent(outfile, level)
            outfile.write('model_.BaselineCell(\n')
            BaselineCell_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('maxTime', node)
        if value is not None and 'maxTime' not in already_processed:
            already_processed.add('maxTime')
            try:
                self.maxTime = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (maxTime): %s' % exp)
            self.validate_REAL_NUMBER(self.maxTime)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'BaselineStratum':
            obj_ = BaselineStratum.factory()
            obj_.build(child_)
            self.BaselineStratum.append(obj_)
            obj_.original_tagname_ = 'BaselineStratum'
        elif nodeName_ == 'BaselineCell':
            obj_ = BaselineCell.factory()
            obj_.build(child_)
            self.BaselineCell.append(obj_)
            obj_.original_tagname_ = 'BaselineCell'
# end class BaseCumHazardTables


class BaselineStratum(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, label=None, maxTime=None, Extension=None, BaselineCell=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.label = _cast(None, label)
        self.maxTime = _cast(None, maxTime)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if BaselineCell is None:
            self.BaselineCell = []
        else:
            self.BaselineCell = BaselineCell
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaselineStratum)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaselineStratum.subclass:
            return BaselineStratum.subclass(*args_, **kwargs_)
        else:
            return BaselineStratum(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_BaselineCell(self): return self.BaselineCell
    def set_BaselineCell(self, BaselineCell): self.BaselineCell = BaselineCell
    def add_BaselineCell(self, value): self.BaselineCell.append(value)
    def insert_BaselineCell_at(self, index, value): self.BaselineCell.insert(index, value)
    def replace_BaselineCell_at(self, index, value): self.BaselineCell[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_maxTime(self): return self.maxTime
    def set_maxTime(self, maxTime): self.maxTime = maxTime
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.BaselineCell
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BaselineStratum', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaselineStratum')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BaselineStratum')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BaselineStratum', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BaselineStratum'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.maxTime is not None and 'maxTime' not in already_processed:
            already_processed.add('maxTime')
            outfile.write(' maxTime=%s' % (quote_attrib(self.maxTime), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BaselineStratum', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for BaselineCell_ in self.BaselineCell:
            BaselineCell_.export(outfile, level, namespace_, name_='BaselineCell', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BaselineStratum', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.label is not None:
            element.set('label', self.gds_format_string(self.label))
        if self.maxTime is not None:
            element.set('maxTime', self.maxTime)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for BaselineCell_ in self.BaselineCell:
            BaselineCell_.to_etree(element, name_='BaselineCell', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BaselineStratum'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            showIndent(outfile, level)
            outfile.write('label="%s",\n' % (self.label,))
        if self.maxTime is not None and 'maxTime' not in already_processed:
            already_processed.add('maxTime')
            showIndent(outfile, level)
            outfile.write('maxTime=%e,\n' % (self.maxTime,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BaselineCell=[\n')
        level += 1
        for BaselineCell_ in self.BaselineCell:
            showIndent(outfile, level)
            outfile.write('model_.BaselineCell(\n')
            BaselineCell_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('maxTime', node)
        if value is not None and 'maxTime' not in already_processed:
            already_processed.add('maxTime')
            try:
                self.maxTime = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (maxTime): %s' % exp)
            self.validate_REAL_NUMBER(self.maxTime)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'BaselineCell':
            obj_ = BaselineCell.factory()
            obj_.build(child_)
            self.BaselineCell.append(obj_)
            obj_.original_tagname_ = 'BaselineCell'
# end class BaselineStratum


class BaselineCell(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, time=None, cumHazard=None, Extension=None):
        self.original_tagname_ = None
        self.time = _cast(None, time)
        self.cumHazard = _cast(None, cumHazard)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaselineCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaselineCell.subclass:
            return BaselineCell.subclass(*args_, **kwargs_)
        else:
            return BaselineCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_cumHazard(self): return self.cumHazard
    def set_cumHazard(self, cumHazard): self.cumHazard = cumHazard
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BaselineCell', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaselineCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BaselineCell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BaselineCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BaselineCell'):
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            outfile.write(' time=%s' % (quote_attrib(self.time), ))
        if self.cumHazard is not None and 'cumHazard' not in already_processed:
            already_processed.add('cumHazard')
            outfile.write(' cumHazard=%s' % (quote_attrib(self.cumHazard), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BaselineCell', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BaselineCell', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.time is not None:
            element.set('time', self.time)
        if self.cumHazard is not None:
            element.set('cumHazard', self.cumHazard)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BaselineCell'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            showIndent(outfile, level)
            outfile.write('time=%e,\n' % (self.time,))
        if self.cumHazard is not None and 'cumHazard' not in already_processed:
            already_processed.add('cumHazard')
            showIndent(outfile, level)
            outfile.write('cumHazard=%e,\n' % (self.cumHazard,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.add('time')
            try:
                self.time = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (time): %s' % exp)
            self.validate_REAL_NUMBER(self.time)    # validate type REAL-NUMBER
        value = find_attr_value_('cumHazard', node)
        if value is not None and 'cumHazard' not in already_processed:
            already_processed.add('cumHazard')
            try:
                self.cumHazard = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (cumHazard): %s' % exp)
            self.validate_REAL_NUMBER(self.cumHazard)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class BaselineCell


class EventValues(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Value=None, Interval=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if Interval is None:
            self.Interval = []
        else:
            self.Interval = Interval
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventValues)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventValues.subclass:
            return EventValues.subclass(*args_, **kwargs_)
        else:
            return EventValues(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value_at(self, index, value): self.Value.insert(index, value)
    def replace_Value_at(self, index, value): self.Value[index] = value
    def get_Interval(self): return self.Interval
    def set_Interval(self, Interval): self.Interval = Interval
    def add_Interval(self, value): self.Interval.append(value)
    def insert_Interval_at(self, index, value): self.Interval.insert(index, value)
    def replace_Interval_at(self, index, value): self.Interval[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.Value or
            self.Interval
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EventValues', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EventValues')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventValues')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EventValues', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EventValues'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EventValues', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Value_ in self.Value:
            Value_.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
        for Interval_ in self.Interval:
            Interval_.export(outfile, level, namespace_, name_='Interval', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='EventValues', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Value_ in self.Value:
            Value_.to_etree(element, name_='Value', mapping_=mapping_)
        for Interval_ in self.Interval:
            Interval_.to_etree(element, name_='Interval', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='EventValues'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('model_.Value(\n')
            Value_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Interval=[\n')
        level += 1
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('model_.Interval(\n')
            Interval_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Value':
            obj_ = Value.factory()
            obj_.build(child_)
            self.Value.append(obj_)
            obj_.original_tagname_ = 'Value'
        elif nodeName_ == 'Interval':
            obj_ = Interval.factory()
            obj_.build(child_)
            self.Interval.append(obj_)
            obj_.original_tagname_ = 'Interval'
# end class EventValues


class NearestNeighborModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, numberOfNeighbors=None, continuousScoringMethod='average', categoricalScoringMethod='majorityVote', instanceIdVariable=None, threshold='0.001', isScorable=True, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, TrainingInstances=None, ComparisonMeasure=None, KNNInputs=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.numberOfNeighbors = _cast(int, numberOfNeighbors)
        self.continuousScoringMethod = _cast(None, continuousScoringMethod)
        self.categoricalScoringMethod = _cast(None, categoricalScoringMethod)
        self.instanceIdVariable = _cast(None, instanceIdVariable)
        self.threshold = _cast(None, threshold)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.ModelExplanation = ModelExplanation
        self.Targets = Targets
        self.LocalTransformations = LocalTransformations
        self.TrainingInstances = TrainingInstances
        self.ComparisonMeasure = ComparisonMeasure
        self.KNNInputs = KNNInputs
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NearestNeighborModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NearestNeighborModel.subclass:
            return NearestNeighborModel.subclass(*args_, **kwargs_)
        else:
            return NearestNeighborModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_ModelExplanation(self): return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation): self.ModelExplanation = ModelExplanation
    def get_Targets(self): return self.Targets
    def set_Targets(self, Targets): self.Targets = Targets
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_TrainingInstances(self): return self.TrainingInstances
    def set_TrainingInstances(self, TrainingInstances): self.TrainingInstances = TrainingInstances
    def get_ComparisonMeasure(self): return self.ComparisonMeasure
    def set_ComparisonMeasure(self, ComparisonMeasure): self.ComparisonMeasure = ComparisonMeasure
    def get_KNNInputs(self): return self.KNNInputs
    def set_KNNInputs(self, KNNInputs): self.KNNInputs = KNNInputs
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_numberOfNeighbors(self): return self.numberOfNeighbors
    def set_numberOfNeighbors(self, numberOfNeighbors): self.numberOfNeighbors = numberOfNeighbors
    def get_continuousScoringMethod(self): return self.continuousScoringMethod
    def set_continuousScoringMethod(self, continuousScoringMethod): self.continuousScoringMethod = continuousScoringMethod
    def get_categoricalScoringMethod(self): return self.categoricalScoringMethod
    def set_categoricalScoringMethod(self, categoricalScoringMethod): self.categoricalScoringMethod = categoricalScoringMethod
    def get_instanceIdVariable(self): return self.instanceIdVariable
    def set_instanceIdVariable(self, instanceIdVariable): self.instanceIdVariable = instanceIdVariable
    def get_threshold(self): return self.threshold
    def set_threshold(self, threshold): self.threshold = threshold
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_CONT_SCORING_METHOD(self, value):
        # Validate type CONT-SCORING-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['median', 'average', 'weightedAverage']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CONT-SCORING-METHOD' % {"value" : value.encode("utf-8")} )
    def validate_CAT_SCORING_METHOD(self, value):
        # Validate type CAT-SCORING-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['majorityVote', 'weightedMajorityVote']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CAT-SCORING-METHOD' % {"value" : value.encode("utf-8")} )
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.TrainingInstances is not None or
            self.ComparisonMeasure is not None or
            self.KNNInputs is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NearestNeighborModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NearestNeighborModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NearestNeighborModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NearestNeighborModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NearestNeighborModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.numberOfNeighbors is not None and 'numberOfNeighbors' not in already_processed:
            already_processed.add('numberOfNeighbors')
            outfile.write(' numberOfNeighbors="%s"' % self.gds_format_integer(self.numberOfNeighbors, input_name='numberOfNeighbors'))
        if self.continuousScoringMethod != "average" and 'continuousScoringMethod' not in already_processed:
            already_processed.add('continuousScoringMethod')
            outfile.write(' continuousScoringMethod=%s' % (quote_attrib(self.continuousScoringMethod), ))
        if self.categoricalScoringMethod != "majorityVote" and 'categoricalScoringMethod' not in already_processed:
            already_processed.add('categoricalScoringMethod')
            outfile.write(' categoricalScoringMethod=%s' % (quote_attrib(self.categoricalScoringMethod), ))
        if self.instanceIdVariable is not None and 'instanceIdVariable' not in already_processed:
            already_processed.add('instanceIdVariable')
            outfile.write(' instanceIdVariable=%s' % (quote_attrib(self.instanceIdVariable), ))
        if self.threshold != 0.001 and 'threshold' not in already_processed:
            already_processed.add('threshold')
            outfile.write(' threshold=%s' % (quote_attrib(self.threshold), ))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='NearestNeighborModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            self.ModelExplanation.export(outfile, level, namespace_, name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            self.Targets.export(outfile, level, namespace_, name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        if self.TrainingInstances is not None:
            self.TrainingInstances.export(outfile, level, namespace_, name_='TrainingInstances', pretty_print=pretty_print)
        if self.ComparisonMeasure is not None:
            self.ComparisonMeasure.export(outfile, level, namespace_, name_='ComparisonMeasure', pretty_print=pretty_print)
        if self.KNNInputs is not None:
            self.KNNInputs.export(outfile, level, namespace_, name_='KNNInputs', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NearestNeighborModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.numberOfNeighbors is not None:
            element.set('numberOfNeighbors', self.gds_format_integer(self.numberOfNeighbors))
        if self.continuousScoringMethod is not None:
            element.set('continuousScoringMethod', self.continuousScoringMethod)
        if self.categoricalScoringMethod is not None:
            element.set('categoricalScoringMethod', self.categoricalScoringMethod)
        if self.instanceIdVariable is not None:
            element.set('instanceIdVariable', self.instanceIdVariable)
        if self.threshold is not None:
            element.set('threshold', self.threshold)
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.ModelExplanation is not None:
            ModelExplanation_ = self.ModelExplanation
            ModelExplanation_.to_etree(element, name_='ModelExplanation', mapping_=mapping_)
        if self.Targets is not None:
            Targets_ = self.Targets
            Targets_.to_etree(element, name_='Targets', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        if self.TrainingInstances is not None:
            TrainingInstances_ = self.TrainingInstances
            TrainingInstances_.to_etree(element, name_='TrainingInstances', mapping_=mapping_)
        if self.ComparisonMeasure is not None:
            ComparisonMeasure_ = self.ComparisonMeasure
            ComparisonMeasure_.to_etree(element, name_='ComparisonMeasure', mapping_=mapping_)
        if self.KNNInputs is not None:
            KNNInputs_ = self.KNNInputs
            KNNInputs_.to_etree(element, name_='KNNInputs', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NearestNeighborModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.numberOfNeighbors is not None and 'numberOfNeighbors' not in already_processed:
            already_processed.add('numberOfNeighbors')
            showIndent(outfile, level)
            outfile.write('numberOfNeighbors=%d,\n' % (self.numberOfNeighbors,))
        if self.continuousScoringMethod is not None and 'continuousScoringMethod' not in already_processed:
            already_processed.add('continuousScoringMethod')
            showIndent(outfile, level)
            outfile.write('continuousScoringMethod="%s",\n' % (self.continuousScoringMethod,))
        if self.categoricalScoringMethod is not None and 'categoricalScoringMethod' not in already_processed:
            already_processed.add('categoricalScoringMethod')
            showIndent(outfile, level)
            outfile.write('categoricalScoringMethod="%s",\n' % (self.categoricalScoringMethod,))
        if self.instanceIdVariable is not None and 'instanceIdVariable' not in already_processed:
            already_processed.add('instanceIdVariable')
            showIndent(outfile, level)
            outfile.write('instanceIdVariable="%s",\n' % (self.instanceIdVariable,))
        if self.threshold is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            showIndent(outfile, level)
            outfile.write('threshold=%e,\n' % (self.threshold,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelExplanation is not None:
            showIndent(outfile, level)
            outfile.write('ModelExplanation=model_.ModelExplanation(\n')
            self.ModelExplanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targets is not None:
            showIndent(outfile, level)
            outfile.write('Targets=model_.Targets(\n')
            self.Targets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TrainingInstances is not None:
            showIndent(outfile, level)
            outfile.write('TrainingInstances=model_.TrainingInstances(\n')
            self.TrainingInstances.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ComparisonMeasure is not None:
            showIndent(outfile, level)
            outfile.write('ComparisonMeasure=model_.ComparisonMeasure(\n')
            self.ComparisonMeasure.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.KNNInputs is not None:
            showIndent(outfile, level)
            outfile.write('KNNInputs=model_.KNNInputs(\n')
            self.KNNInputs.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('numberOfNeighbors', node)
        if value is not None and 'numberOfNeighbors' not in already_processed:
            already_processed.add('numberOfNeighbors')
            try:
                self.numberOfNeighbors = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfNeighbors < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('continuousScoringMethod', node)
        if value is not None and 'continuousScoringMethod' not in already_processed:
            already_processed.add('continuousScoringMethod')
            self.continuousScoringMethod = value
            self.validate_CONT_SCORING_METHOD(self.continuousScoringMethod)    # validate type CONT-SCORING-METHOD
        value = find_attr_value_('categoricalScoringMethod', node)
        if value is not None and 'categoricalScoringMethod' not in already_processed:
            already_processed.add('categoricalScoringMethod')
            self.categoricalScoringMethod = value
            self.validate_CAT_SCORING_METHOD(self.categoricalScoringMethod)    # validate type CAT-SCORING-METHOD
        value = find_attr_value_('instanceIdVariable', node)
        if value is not None and 'instanceIdVariable' not in already_processed:
            already_processed.add('instanceIdVariable')
            self.instanceIdVariable = value
            self.validate_FIELD_NAME(self.instanceIdVariable)    # validate type FIELD-NAME
        value = find_attr_value_('threshold', node)
        if value is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            try:
                self.threshold = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (threshold): %s' % exp)
            self.validate_REAL_NUMBER(self.threshold)    # validate type REAL-NUMBER
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory()
            obj_.build(child_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory()
            obj_.build(child_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'TrainingInstances':
            obj_ = TrainingInstances.factory()
            obj_.build(child_)
            self.TrainingInstances = obj_
            obj_.original_tagname_ = 'TrainingInstances'
        elif nodeName_ == 'ComparisonMeasure':
            obj_ = ComparisonMeasure.factory()
            obj_.build(child_)
            self.ComparisonMeasure = obj_
            obj_.original_tagname_ = 'ComparisonMeasure'
        elif nodeName_ == 'KNNInputs':
            obj_ = KNNInputs.factory()
            obj_.build(child_)
            self.KNNInputs = obj_
            obj_.original_tagname_ = 'KNNInputs'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class NearestNeighborModel


class TrainingInstances(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, isTransformed=False, recordCount=None, fieldCount=None, Extension=None, InstanceFields=None, TableLocator=None, InlineTable=None):
        self.original_tagname_ = None
        self.isTransformed = _cast(bool, isTransformed)
        self.recordCount = _cast(None, recordCount)
        self.fieldCount = _cast(None, fieldCount)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.InstanceFields = InstanceFields
        self.TableLocator = TableLocator
        self.InlineTable = InlineTable
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrainingInstances)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrainingInstances.subclass:
            return TrainingInstances.subclass(*args_, **kwargs_)
        else:
            return TrainingInstances(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_InstanceFields(self): return self.InstanceFields
    def set_InstanceFields(self, InstanceFields): self.InstanceFields = InstanceFields
    def get_TableLocator(self): return self.TableLocator
    def set_TableLocator(self, TableLocator): self.TableLocator = TableLocator
    def get_InlineTable(self): return self.InlineTable
    def set_InlineTable(self, InlineTable): self.InlineTable = InlineTable
    def get_isTransformed(self): return self.isTransformed
    def set_isTransformed(self, isTransformed): self.isTransformed = isTransformed
    def get_recordCount(self): return self.recordCount
    def set_recordCount(self, recordCount): self.recordCount = recordCount
    def get_fieldCount(self): return self.fieldCount
    def set_fieldCount(self, fieldCount): self.fieldCount = fieldCount
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.InstanceFields is not None or
            self.TableLocator is not None or
            self.InlineTable is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TrainingInstances', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrainingInstances')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrainingInstances')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TrainingInstances', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TrainingInstances'):
        if self.isTransformed and 'isTransformed' not in already_processed:
            already_processed.add('isTransformed')
            outfile.write(' isTransformed="%s"' % self.gds_format_boolean(self.isTransformed, input_name='isTransformed'))
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            outfile.write(' recordCount=%s' % (quote_attrib(self.recordCount), ))
        if self.fieldCount is not None and 'fieldCount' not in already_processed:
            already_processed.add('fieldCount')
            outfile.write(' fieldCount=%s' % (quote_attrib(self.fieldCount), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TrainingInstances', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.InstanceFields is not None:
            self.InstanceFields.export(outfile, level, namespace_, name_='InstanceFields', pretty_print=pretty_print)
        if self.TableLocator is not None:
            self.TableLocator.export(outfile, level, namespace_, name_='TableLocator', pretty_print=pretty_print)
        if self.InlineTable is not None:
            self.InlineTable.export(outfile, level, namespace_, name_='InlineTable', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TrainingInstances', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.isTransformed is not None:
            element.set('isTransformed', self.gds_format_boolean(self.isTransformed))
        if self.recordCount is not None:
            element.set('recordCount', self.recordCount)
        if self.fieldCount is not None:
            element.set('fieldCount', self.fieldCount)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.InstanceFields is not None:
            InstanceFields_ = self.InstanceFields
            InstanceFields_.to_etree(element, name_='InstanceFields', mapping_=mapping_)
        if self.TableLocator is not None:
            TableLocator_ = self.TableLocator
            TableLocator_.to_etree(element, name_='TableLocator', mapping_=mapping_)
        if self.InlineTable is not None:
            InlineTable_ = self.InlineTable
            InlineTable_.to_etree(element, name_='InlineTable', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TrainingInstances'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isTransformed is not None and 'isTransformed' not in already_processed:
            already_processed.add('isTransformed')
            showIndent(outfile, level)
            outfile.write('isTransformed=%s,\n' % (self.isTransformed,))
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            showIndent(outfile, level)
            outfile.write('recordCount=%d,\n' % (self.recordCount,))
        if self.fieldCount is not None and 'fieldCount' not in already_processed:
            already_processed.add('fieldCount')
            showIndent(outfile, level)
            outfile.write('fieldCount=%d,\n' % (self.fieldCount,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.InstanceFields is not None:
            showIndent(outfile, level)
            outfile.write('InstanceFields=model_.InstanceFields(\n')
            self.InstanceFields.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TableLocator is not None:
            showIndent(outfile, level)
            outfile.write('TableLocator=model_.TableLocator(\n')
            self.TableLocator.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InlineTable is not None:
            showIndent(outfile, level)
            outfile.write('InlineTable=model_.InlineTable(\n')
            self.InlineTable.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isTransformed', node)
        if value is not None and 'isTransformed' not in already_processed:
            already_processed.add('isTransformed')
            if value in ('true', '1'):
                self.isTransformed = True
            elif value in ('false', '0'):
                self.isTransformed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('recordCount', node)
        if value is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            try:
                self.recordCount = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.recordCount)    # validate type INT-NUMBER
        value = find_attr_value_('fieldCount', node)
        if value is not None and 'fieldCount' not in already_processed:
            already_processed.add('fieldCount')
            try:
                self.fieldCount = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.fieldCount)    # validate type INT-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'InstanceFields':
            obj_ = InstanceFields.factory()
            obj_.build(child_)
            self.InstanceFields = obj_
            obj_.original_tagname_ = 'InstanceFields'
        elif nodeName_ == 'TableLocator':
            obj_ = TableLocator.factory()
            obj_.build(child_)
            self.TableLocator = obj_
            obj_.original_tagname_ = 'TableLocator'
        elif nodeName_ == 'InlineTable':
            obj_ = InlineTable.factory()
            obj_.build(child_)
            self.InlineTable = obj_
            obj_.original_tagname_ = 'InlineTable'
# end class TrainingInstances


class InstanceFields(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, InstanceField=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if InstanceField is None:
            self.InstanceField = []
        else:
            self.InstanceField = InstanceField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceFields)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceFields.subclass:
            return InstanceFields.subclass(*args_, **kwargs_)
        else:
            return InstanceFields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_InstanceField(self): return self.InstanceField
    def set_InstanceField(self, InstanceField): self.InstanceField = InstanceField
    def add_InstanceField(self, value): self.InstanceField.append(value)
    def insert_InstanceField_at(self, index, value): self.InstanceField.insert(index, value)
    def replace_InstanceField_at(self, index, value): self.InstanceField[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.InstanceField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstanceFields', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InstanceFields')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstanceFields')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstanceFields', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstanceFields'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InstanceFields', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for InstanceField_ in self.InstanceField:
            InstanceField_.export(outfile, level, namespace_, name_='InstanceField', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InstanceFields', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for InstanceField_ in self.InstanceField:
            InstanceField_.to_etree(element, name_='InstanceField', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='InstanceFields'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InstanceField=[\n')
        level += 1
        for InstanceField_ in self.InstanceField:
            showIndent(outfile, level)
            outfile.write('model_.InstanceField(\n')
            InstanceField_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'InstanceField':
            obj_ = InstanceField.factory()
            obj_.build(child_)
            self.InstanceField.append(obj_)
            obj_.original_tagname_ = 'InstanceField'
# end class InstanceFields


class InstanceField(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, column=None, Extension=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.column = _cast(None, column)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceField.subclass:
            return InstanceField.subclass(*args_, **kwargs_)
        else:
            return InstanceField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstanceField', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InstanceField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstanceField')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstanceField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstanceField'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.column is not None and 'column' not in already_processed:
            already_processed.add('column')
            outfile.write(' column=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.column), input_name='column')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InstanceField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InstanceField', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.column is not None:
            element.set('column', self.gds_format_string(self.column))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='InstanceField'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.column is not None and 'column' not in already_processed:
            already_processed.add('column')
            showIndent(outfile, level)
            outfile.write('column="%s",\n' % (self.column,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('column', node)
        if value is not None and 'column' not in already_processed:
            already_processed.add('column')
            self.column = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class InstanceField


class KNNInputs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, KNNInput=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if KNNInput is None:
            self.KNNInput = []
        else:
            self.KNNInput = KNNInput
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KNNInputs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KNNInputs.subclass:
            return KNNInputs.subclass(*args_, **kwargs_)
        else:
            return KNNInputs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_KNNInput(self): return self.KNNInput
    def set_KNNInput(self, KNNInput): self.KNNInput = KNNInput
    def add_KNNInput(self, value): self.KNNInput.append(value)
    def insert_KNNInput_at(self, index, value): self.KNNInput.insert(index, value)
    def replace_KNNInput_at(self, index, value): self.KNNInput[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.KNNInput
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KNNInputs', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KNNInputs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KNNInputs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KNNInputs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KNNInputs'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KNNInputs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for KNNInput_ in self.KNNInput:
            KNNInput_.export(outfile, level, namespace_, name_='KNNInput', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='KNNInputs', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for KNNInput_ in self.KNNInput:
            KNNInput_.to_etree(element, name_='KNNInput', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='KNNInputs'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('KNNInput=[\n')
        level += 1
        for KNNInput_ in self.KNNInput:
            showIndent(outfile, level)
            outfile.write('model_.KNNInput(\n')
            KNNInput_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'KNNInput':
            obj_ = KNNInput.factory()
            obj_.build(child_)
            self.KNNInput.append(obj_)
            obj_.original_tagname_ = 'KNNInput'
# end class KNNInputs


class KNNInput(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, fieldWeight='1', compareFunction=None, Extension=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.fieldWeight = _cast(None, fieldWeight)
        self.compareFunction = _cast(None, compareFunction)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KNNInput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KNNInput.subclass:
            return KNNInput.subclass(*args_, **kwargs_)
        else:
            return KNNInput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_fieldWeight(self): return self.fieldWeight
    def set_fieldWeight(self, fieldWeight): self.fieldWeight = fieldWeight
    def get_compareFunction(self): return self.compareFunction
    def set_compareFunction(self, compareFunction): self.compareFunction = compareFunction
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_COMPARE_FUNCTION(self, value):
        # Validate type COMPARE-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['absDiff', 'gaussSim', 'delta', 'equal', 'table']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on COMPARE-FUNCTION' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KNNInput', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KNNInput')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KNNInput')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KNNInput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KNNInput'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.fieldWeight != 1 and 'fieldWeight' not in already_processed:
            already_processed.add('fieldWeight')
            outfile.write(' fieldWeight=%s' % (quote_attrib(self.fieldWeight), ))
        if self.compareFunction is not None and 'compareFunction' not in already_processed:
            already_processed.add('compareFunction')
            outfile.write(' compareFunction=%s' % (quote_attrib(self.compareFunction), ))
    def exportChildren(self, outfile, level, namespace_='', name_='KNNInput', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='KNNInput', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.fieldWeight is not None:
            element.set('fieldWeight', self.fieldWeight)
        if self.compareFunction is not None:
            element.set('compareFunction', self.compareFunction)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='KNNInput'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.fieldWeight is not None and 'fieldWeight' not in already_processed:
            already_processed.add('fieldWeight')
            showIndent(outfile, level)
            outfile.write('fieldWeight=%e,\n' % (self.fieldWeight,))
        if self.compareFunction is not None and 'compareFunction' not in already_processed:
            already_processed.add('compareFunction')
            showIndent(outfile, level)
            outfile.write('compareFunction="%s",\n' % (self.compareFunction,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('fieldWeight', node)
        if value is not None and 'fieldWeight' not in already_processed:
            already_processed.add('fieldWeight')
            try:
                self.fieldWeight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (fieldWeight): %s' % exp)
            self.validate_REAL_NUMBER(self.fieldWeight)    # validate type REAL-NUMBER
        value = find_attr_value_('compareFunction', node)
        if value is not None and 'compareFunction' not in already_processed:
            already_processed.add('compareFunction')
            self.compareFunction = value
            self.validate_COMPARE_FUNCTION(self.compareFunction)    # validate type COMPARE-FUNCTION
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class KNNInput


class TransformationDictionary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, DefineFunction=None, DerivedField=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if DefineFunction is None:
            self.DefineFunction = []
        else:
            self.DefineFunction = DefineFunction
        if DerivedField is None:
            self.DerivedField = []
        else:
            self.DerivedField = DerivedField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformationDictionary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformationDictionary.subclass:
            return TransformationDictionary.subclass(*args_, **kwargs_)
        else:
            return TransformationDictionary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_DefineFunction(self): return self.DefineFunction
    def set_DefineFunction(self, DefineFunction): self.DefineFunction = DefineFunction
    def add_DefineFunction(self, value): self.DefineFunction.append(value)
    def insert_DefineFunction_at(self, index, value): self.DefineFunction.insert(index, value)
    def replace_DefineFunction_at(self, index, value): self.DefineFunction[index] = value
    def get_DerivedField(self): return self.DerivedField
    def set_DerivedField(self, DerivedField): self.DerivedField = DerivedField
    def add_DerivedField(self, value): self.DerivedField.append(value)
    def insert_DerivedField_at(self, index, value): self.DerivedField.insert(index, value)
    def replace_DerivedField_at(self, index, value): self.DerivedField[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.DefineFunction or
            self.DerivedField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TransformationDictionary', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformationDictionary')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransformationDictionary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TransformationDictionary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransformationDictionary'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TransformationDictionary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for DefineFunction_ in self.DefineFunction:
            DefineFunction_.export(outfile, level, namespace_, name_='DefineFunction', pretty_print=pretty_print)
        for DerivedField_ in self.DerivedField:
            DerivedField_.export(outfile, level, namespace_, name_='DerivedField', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TransformationDictionary', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for DefineFunction_ in self.DefineFunction:
            DefineFunction_.to_etree(element, name_='DefineFunction', mapping_=mapping_)
        for DerivedField_ in self.DerivedField:
            DerivedField_.to_etree(element, name_='DerivedField', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TransformationDictionary'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DefineFunction=[\n')
        level += 1
        for DefineFunction_ in self.DefineFunction:
            showIndent(outfile, level)
            outfile.write('model_.DefineFunction(\n')
            DefineFunction_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DerivedField=[\n')
        level += 1
        for DerivedField_ in self.DerivedField:
            showIndent(outfile, level)
            outfile.write('model_.DerivedField(\n')
            DerivedField_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'DefineFunction':
            obj_ = DefineFunction.factory()
            obj_.build(child_)
            self.DefineFunction.append(obj_)
            obj_.original_tagname_ = 'DefineFunction'
        elif nodeName_ == 'DerivedField':
            obj_ = DerivedField.factory()
            obj_.build(child_)
            self.DerivedField.append(obj_)
            obj_.original_tagname_ = 'DerivedField'
# end class TransformationDictionary


class LocalTransformations(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, DerivedField=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if DerivedField is None:
            self.DerivedField = []
        else:
            self.DerivedField = DerivedField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocalTransformations)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalTransformations.subclass:
            return LocalTransformations.subclass(*args_, **kwargs_)
        else:
            return LocalTransformations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_DerivedField(self): return self.DerivedField
    def set_DerivedField(self, DerivedField): self.DerivedField = DerivedField
    def add_DerivedField(self, value): self.DerivedField.append(value)
    def insert_DerivedField_at(self, index, value): self.DerivedField.insert(index, value)
    def replace_DerivedField_at(self, index, value): self.DerivedField[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.DerivedField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LocalTransformations', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocalTransformations')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocalTransformations')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LocalTransformations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocalTransformations'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocalTransformations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for DerivedField_ in self.DerivedField:
            DerivedField_.export(outfile, level, namespace_, name_='DerivedField', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='LocalTransformations', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for DerivedField_ in self.DerivedField:
            DerivedField_.to_etree(element, name_='DerivedField', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='LocalTransformations'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DerivedField=[\n')
        level += 1
        for DerivedField_ in self.DerivedField:
            showIndent(outfile, level)
            outfile.write('model_.DerivedField(\n')
            DerivedField_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'DerivedField':
            obj_ = DerivedField.factory()
            obj_.build(child_)
            self.DerivedField.append(obj_)
            obj_.original_tagname_ = 'DerivedField'
# end class LocalTransformations


class DerivedField(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, optype=None, dataType=None, Extension=None, FieldRef=None, Apply=None, Constant=None, NormContinuous=None, NormDiscrete=None, Discretize=None, MapValues=None, TextIndex=None, Aggregate=None, Lag=None, Value=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.displayName = _cast(None, displayName)
        self.optype = _cast(None, optype)
        self.dataType = _cast(None, dataType)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.FieldRef = FieldRef
        self.Apply = Apply
        self.Constant = Constant
        self.NormContinuous = NormContinuous
        self.NormDiscrete = NormDiscrete
        self.Discretize = Discretize
        self.MapValues = MapValues
        self.TextIndex = TextIndex
        self.Aggregate = Aggregate
        self.Lag = Lag
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DerivedField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DerivedField.subclass:
            return DerivedField.subclass(*args_, **kwargs_)
        else:
            return DerivedField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_FieldRef(self): return self.FieldRef
    def set_FieldRef(self, FieldRef): self.FieldRef = FieldRef
    def get_Apply(self): return self.Apply
    def set_Apply(self, Apply): self.Apply = Apply
    def get_Constant(self): return self.Constant
    def set_Constant(self, Constant): self.Constant = Constant
    def get_NormContinuous(self): return self.NormContinuous
    def set_NormContinuous(self, NormContinuous): self.NormContinuous = NormContinuous
    def get_NormDiscrete(self): return self.NormDiscrete
    def set_NormDiscrete(self, NormDiscrete): self.NormDiscrete = NormDiscrete
    def get_Discretize(self): return self.Discretize
    def set_Discretize(self, Discretize): self.Discretize = Discretize
    def get_MapValues(self): return self.MapValues
    def set_MapValues(self, MapValues): self.MapValues = MapValues
    def get_TextIndex(self): return self.TextIndex
    def set_TextIndex(self, TextIndex): self.TextIndex = TextIndex
    def get_Aggregate(self): return self.Aggregate
    def set_Aggregate(self, Aggregate): self.Aggregate = Aggregate
    def get_Lag(self): return self.Lag
    def set_Lag(self, Lag): self.Lag = Lag
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value_at(self, index, value): self.Value.insert(index, value)
    def replace_Value_at(self, index, value): self.Value[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_optype(self): return self.optype
    def set_optype(self, optype): self.optype = optype
    def get_dataType(self): return self.dataType
    def set_dataType(self, dataType): self.dataType = dataType
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_OPTYPE(self, value):
        # Validate type OPTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['categorical', 'ordinal', 'continuous']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OPTYPE' % {"value" : value.encode("utf-8")} )
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DATATYPE' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Extension or
            self.FieldRef is not None or
            self.Apply is not None or
            self.Constant is not None or
            self.NormContinuous is not None or
            self.NormDiscrete is not None or
            self.Discretize is not None or
            self.MapValues is not None or
            self.TextIndex is not None or
            self.Aggregate is not None or
            self.Lag is not None or
            self.Value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DerivedField', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DerivedField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DerivedField')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DerivedField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DerivedField'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            outfile.write(' optype=%s' % (quote_attrib(self.optype), ))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (quote_attrib(self.dataType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DerivedField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.FieldRef is not None:
            self.FieldRef.export(outfile, level, namespace_, name_='FieldRef', pretty_print=pretty_print)
        if self.Apply is not None:
            self.Apply.export(outfile, level, namespace_, name_='Apply', pretty_print=pretty_print)
        if self.Constant is not None:
            self.Constant.export(outfile, level, namespace_, name_='Constant', pretty_print=pretty_print)
        if self.NormContinuous is not None:
            self.NormContinuous.export(outfile, level, namespace_, name_='NormContinuous', pretty_print=pretty_print)
        if self.NormDiscrete is not None:
            self.NormDiscrete.export(outfile, level, namespace_, name_='NormDiscrete', pretty_print=pretty_print)
        if self.Discretize is not None:
            self.Discretize.export(outfile, level, namespace_, name_='Discretize', pretty_print=pretty_print)
        if self.MapValues is not None:
            self.MapValues.export(outfile, level, namespace_, name_='MapValues', pretty_print=pretty_print)
        if self.TextIndex is not None:
            self.TextIndex.export(outfile, level, namespace_, name_='TextIndex', pretty_print=pretty_print)
        if self.Aggregate is not None:
            self.Aggregate.export(outfile, level, namespace_, name_='Aggregate', pretty_print=pretty_print)
        if self.Lag is not None:
            self.Lag.export(outfile, level, namespace_, name_='Lag', pretty_print=pretty_print)
        for Value_ in self.Value:
            Value_.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DerivedField', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.name)
        if self.displayName is not None:
            element.set('displayName', self.gds_format_string(self.displayName))
        if self.optype is not None:
            element.set('optype', self.optype)
        if self.dataType is not None:
            element.set('dataType', self.dataType)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.FieldRef is not None:
            FieldRef_ = self.FieldRef
            FieldRef_.to_etree(element, name_='FieldRef', mapping_=mapping_)
        if self.Apply is not None:
            Apply_ = self.Apply
            Apply_.to_etree(element, name_='Apply', mapping_=mapping_)
        if self.Constant is not None:
            Constant_ = self.Constant
            Constant_.to_etree(element, name_='Constant', mapping_=mapping_)
        if self.NormContinuous is not None:
            NormContinuous_ = self.NormContinuous
            NormContinuous_.to_etree(element, name_='NormContinuous', mapping_=mapping_)
        if self.NormDiscrete is not None:
            NormDiscrete_ = self.NormDiscrete
            NormDiscrete_.to_etree(element, name_='NormDiscrete', mapping_=mapping_)
        if self.Discretize is not None:
            Discretize_ = self.Discretize
            Discretize_.to_etree(element, name_='Discretize', mapping_=mapping_)
        if self.MapValues is not None:
            MapValues_ = self.MapValues
            MapValues_.to_etree(element, name_='MapValues', mapping_=mapping_)
        if self.TextIndex is not None:
            TextIndex_ = self.TextIndex
            TextIndex_.to_etree(element, name_='TextIndex', mapping_=mapping_)
        if self.Aggregate is not None:
            Aggregate_ = self.Aggregate
            Aggregate_.to_etree(element, name_='Aggregate', mapping_=mapping_)
        if self.Lag is not None:
            Lag_ = self.Lag
            Lag_.to_etree(element, name_='Lag', mapping_=mapping_)
        for Value_ in self.Value:
            Value_.to_etree(element, name_='Value', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DerivedField'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            showIndent(outfile, level)
            outfile.write('displayName="%s",\n' % (self.displayName,))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            showIndent(outfile, level)
            outfile.write('optype="%s",\n' % (self.optype,))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            showIndent(outfile, level)
            outfile.write('dataType="%s",\n' % (self.dataType,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.FieldRef is not None:
            showIndent(outfile, level)
            outfile.write('FieldRef=model_.FieldRef(\n')
            self.FieldRef.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Apply is not None:
            showIndent(outfile, level)
            outfile.write('Apply=model_.Apply(\n')
            self.Apply.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Constant is not None:
            showIndent(outfile, level)
            outfile.write('Constant=model_.Constant(\n')
            self.Constant.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormContinuous is not None:
            showIndent(outfile, level)
            outfile.write('NormContinuous=model_.NormContinuous(\n')
            self.NormContinuous.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormDiscrete is not None:
            showIndent(outfile, level)
            outfile.write('NormDiscrete=model_.NormDiscrete(\n')
            self.NormDiscrete.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Discretize is not None:
            showIndent(outfile, level)
            outfile.write('Discretize=model_.Discretize(\n')
            self.Discretize.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MapValues is not None:
            showIndent(outfile, level)
            outfile.write('MapValues=model_.MapValues(\n')
            self.MapValues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextIndex is not None:
            showIndent(outfile, level)
            outfile.write('TextIndex=model_.TextIndex(\n')
            self.TextIndex.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Aggregate is not None:
            showIndent(outfile, level)
            outfile.write('Aggregate=model_.Aggregate(\n')
            self.Aggregate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Lag is not None:
            showIndent(outfile, level)
            outfile.write('Lag=model_.Lag(\n')
            self.Lag.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('model_.Value(\n')
            Value_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
        value = find_attr_value_('optype', node)
        if value is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            self.optype = value
            self.validate_OPTYPE(self.optype)    # validate type OPTYPE
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory()
            obj_.build(child_)
            self.FieldRef = obj_
            obj_.original_tagname_ = 'FieldRef'
        elif nodeName_ == 'Apply':
            obj_ = Apply.factory()
            obj_.build(child_)
            self.Apply = obj_
            obj_.original_tagname_ = 'Apply'
        elif nodeName_ == 'Constant':
            obj_ = Constant.factory()
            obj_.build(child_)
            self.Constant = obj_
            obj_.original_tagname_ = 'Constant'
        elif nodeName_ == 'NormContinuous':
            obj_ = NormContinuous.factory()
            obj_.build(child_)
            self.NormContinuous = obj_
            obj_.original_tagname_ = 'NormContinuous'
        elif nodeName_ == 'NormDiscrete':
            obj_ = NormDiscrete.factory()
            obj_.build(child_)
            self.NormDiscrete = obj_
            obj_.original_tagname_ = 'NormDiscrete'
        elif nodeName_ == 'Discretize':
            obj_ = Discretize.factory()
            obj_.build(child_)
            self.Discretize = obj_
            obj_.original_tagname_ = 'Discretize'
        elif nodeName_ == 'MapValues':
            obj_ = MapValues.factory()
            obj_.build(child_)
            self.MapValues = obj_
            obj_.original_tagname_ = 'MapValues'
        elif nodeName_ == 'TextIndex':
            obj_ = TextIndex.factory()
            obj_.build(child_)
            self.TextIndex = obj_
            obj_.original_tagname_ = 'TextIndex'
        elif nodeName_ == 'Aggregate':
            obj_ = Aggregate.factory()
            obj_.build(child_)
            self.Aggregate = obj_
            obj_.original_tagname_ = 'Aggregate'
        elif nodeName_ == 'Lag':
            obj_ = Lag.factory()
            obj_.build(child_)
            self.Lag = obj_
            obj_.original_tagname_ = 'Lag'
        elif nodeName_ == 'Value':
            obj_ = Value.factory()
            obj_.build(child_)
            self.Value.append(obj_)
            obj_.original_tagname_ = 'Value'
# end class DerivedField


class Constant(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dataType=None, missing=False, valueOf_=None):
        self.original_tagname_ = None
        self.dataType = _cast(None, dataType)
        self.missing = _cast(bool, missing)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Constant)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Constant.subclass:
            return Constant.subclass(*args_, **kwargs_)
        else:
            return Constant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataType(self): return self.dataType
    def set_dataType(self, dataType): self.dataType = dataType
    def get_missing(self): return self.missing
    def set_missing(self, missing): self.missing = missing
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DATATYPE' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Constant', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Constant')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Constant')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Constant', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Constant'):
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (quote_attrib(self.dataType), ))
        if self.missing and 'missing' not in already_processed:
            already_processed.add('missing')
            outfile.write(' missing="%s"' % self.gds_format_boolean(self.missing, input_name='missing'))
    def exportChildren(self, outfile, level, namespace_='', name_='Constant', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='Constant', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.dataType is not None:
            element.set('dataType', self.dataType)
        if self.missing is not None:
            element.set('missing', self.gds_format_boolean(self.missing))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Constant'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            showIndent(outfile, level)
            outfile.write('dataType="%s",\n' % (self.dataType,))
        if self.missing is not None and 'missing' not in already_processed:
            already_processed.add('missing')
            showIndent(outfile, level)
            outfile.write('missing=%s,\n' % (self.missing,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
        value = find_attr_value_('missing', node)
        if value is not None and 'missing' not in already_processed:
            already_processed.add('missing')
            if value in ('true', '1'):
                self.missing = True
            elif value in ('false', '0'):
                self.missing = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Constant


class FieldRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, mapMissingTo=None, Extension=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.mapMissingTo = _cast(None, mapMissingTo)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FieldRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FieldRef.subclass:
            return FieldRef.subclass(*args_, **kwargs_)
        else:
            return FieldRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_mapMissingTo(self): return self.mapMissingTo
    def set_mapMissingTo(self, mapMissingTo): self.mapMissingTo = mapMissingTo
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FieldRef', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FieldRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FieldRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FieldRef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FieldRef'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.mapMissingTo is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            outfile.write(' mapMissingTo=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mapMissingTo), input_name='mapMissingTo')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FieldRef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='FieldRef', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.mapMissingTo is not None:
            element.set('mapMissingTo', self.gds_format_string(self.mapMissingTo))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FieldRef'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.mapMissingTo is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            showIndent(outfile, level)
            outfile.write('mapMissingTo="%s",\n' % (self.mapMissingTo,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('mapMissingTo', node)
        if value is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            self.mapMissingTo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class FieldRef


class NormContinuous(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mapMissingTo=None, field=None, outliers='asIs', Extension=None, LinearNorm=None):
        self.original_tagname_ = None
        self.mapMissingTo = _cast(None, mapMissingTo)
        self.field = _cast(None, field)
        self.outliers = _cast(None, outliers)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if LinearNorm is None:
            self.LinearNorm = []
        else:
            self.LinearNorm = LinearNorm
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NormContinuous)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NormContinuous.subclass:
            return NormContinuous.subclass(*args_, **kwargs_)
        else:
            return NormContinuous(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_LinearNorm(self): return self.LinearNorm
    def set_LinearNorm(self, LinearNorm): self.LinearNorm = LinearNorm
    def add_LinearNorm(self, value): self.LinearNorm.append(value)
    def insert_LinearNorm_at(self, index, value): self.LinearNorm.insert(index, value)
    def replace_LinearNorm_at(self, index, value): self.LinearNorm[index] = value
    def get_mapMissingTo(self): return self.mapMissingTo
    def set_mapMissingTo(self, mapMissingTo): self.mapMissingTo = mapMissingTo
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_outliers(self): return self.outliers
    def set_outliers(self, outliers): self.outliers = outliers
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_OUTLIER_TREATMENT_METHOD(self, value):
        # Validate type OUTLIER-TREATMENT-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['asIs', 'asMissingValues', 'asExtremeValues']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OUTLIER-TREATMENT-METHOD' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Extension or
            self.LinearNorm
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NormContinuous', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NormContinuous')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NormContinuous')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NormContinuous', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NormContinuous'):
        if self.mapMissingTo is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            outfile.write(' mapMissingTo=%s' % (quote_attrib(self.mapMissingTo), ))
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.outliers != "asIs" and 'outliers' not in already_processed:
            already_processed.add('outliers')
            outfile.write(' outliers=%s' % (quote_attrib(self.outliers), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NormContinuous', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for LinearNorm_ in self.LinearNorm:
            LinearNorm_.export(outfile, level, namespace_, name_='LinearNorm', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NormContinuous', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.mapMissingTo is not None:
            element.set('mapMissingTo', self.mapMissingTo)
        if self.field is not None:
            element.set('field', self.field)
        if self.outliers is not None:
            element.set('outliers', self.outliers)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for LinearNorm_ in self.LinearNorm:
            LinearNorm_.to_etree(element, name_='LinearNorm', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NormContinuous'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mapMissingTo is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            showIndent(outfile, level)
            outfile.write('mapMissingTo=%e,\n' % (self.mapMissingTo,))
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.outliers is not None and 'outliers' not in already_processed:
            already_processed.add('outliers')
            showIndent(outfile, level)
            outfile.write('outliers="%s",\n' % (self.outliers,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LinearNorm=[\n')
        level += 1
        for LinearNorm_ in self.LinearNorm:
            showIndent(outfile, level)
            outfile.write('model_.LinearNorm(\n')
            LinearNorm_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mapMissingTo', node)
        if value is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            try:
                self.mapMissingTo = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (mapMissingTo): %s' % exp)
            self.validate_NUMBER(self.mapMissingTo)    # validate type NUMBER
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('outliers', node)
        if value is not None and 'outliers' not in already_processed:
            already_processed.add('outliers')
            self.outliers = value
            self.validate_OUTLIER_TREATMENT_METHOD(self.outliers)    # validate type OUTLIER-TREATMENT-METHOD
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'LinearNorm':
            obj_ = LinearNorm.factory()
            obj_.build(child_)
            self.LinearNorm.append(obj_)
            obj_.original_tagname_ = 'LinearNorm'
# end class NormContinuous


class LinearNorm(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orig=None, norm=None, Extension=None):
        self.original_tagname_ = None
        self.orig = _cast(None, orig)
        self.norm = _cast(None, norm)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinearNorm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinearNorm.subclass:
            return LinearNorm.subclass(*args_, **kwargs_)
        else:
            return LinearNorm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_orig(self): return self.orig
    def set_orig(self, orig): self.orig = orig
    def get_norm(self): return self.norm
    def set_norm(self, norm): self.norm = norm
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinearNorm', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LinearNorm')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearNorm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinearNorm', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinearNorm'):
        if self.orig is not None and 'orig' not in already_processed:
            already_processed.add('orig')
            outfile.write(' orig=%s' % (quote_attrib(self.orig), ))
        if self.norm is not None and 'norm' not in already_processed:
            already_processed.add('norm')
            outfile.write(' norm=%s' % (quote_attrib(self.norm), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LinearNorm', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='LinearNorm', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.orig is not None:
            element.set('orig', self.orig)
        if self.norm is not None:
            element.set('norm', self.norm)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='LinearNorm'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.orig is not None and 'orig' not in already_processed:
            already_processed.add('orig')
            showIndent(outfile, level)
            outfile.write('orig=%e,\n' % (self.orig,))
        if self.norm is not None and 'norm' not in already_processed:
            already_processed.add('norm')
            showIndent(outfile, level)
            outfile.write('norm=%e,\n' % (self.norm,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('orig', node)
        if value is not None and 'orig' not in already_processed:
            already_processed.add('orig')
            try:
                self.orig = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (orig): %s' % exp)
            self.validate_NUMBER(self.orig)    # validate type NUMBER
        value = find_attr_value_('norm', node)
        if value is not None and 'norm' not in already_processed:
            already_processed.add('norm')
            try:
                self.norm = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (norm): %s' % exp)
            self.validate_NUMBER(self.norm)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class LinearNorm


class NormDiscrete(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, value=None, mapMissingTo=None, Extension=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.value = _cast(None, value)
        self.mapMissingTo = _cast(None, mapMissingTo)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NormDiscrete)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NormDiscrete.subclass:
            return NormDiscrete.subclass(*args_, **kwargs_)
        else:
            return NormDiscrete(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_mapMissingTo(self): return self.mapMissingTo
    def set_mapMissingTo(self, mapMissingTo): self.mapMissingTo = mapMissingTo
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NormDiscrete', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NormDiscrete')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NormDiscrete')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NormDiscrete', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NormDiscrete'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.mapMissingTo is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            outfile.write(' mapMissingTo=%s' % (quote_attrib(self.mapMissingTo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NormDiscrete', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NormDiscrete', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.mapMissingTo is not None:
            element.set('mapMissingTo', self.mapMissingTo)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NormDiscrete'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.mapMissingTo is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            showIndent(outfile, level)
            outfile.write('mapMissingTo=%e,\n' % (self.mapMissingTo,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('mapMissingTo', node)
        if value is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            try:
                self.mapMissingTo = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (mapMissingTo): %s' % exp)
            self.validate_NUMBER(self.mapMissingTo)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class NormDiscrete


class Discretize(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, mapMissingTo=None, defaultValue=None, dataType=None, Extension=None, DiscretizeBin=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.mapMissingTo = _cast(None, mapMissingTo)
        self.defaultValue = _cast(None, defaultValue)
        self.dataType = _cast(None, dataType)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if DiscretizeBin is None:
            self.DiscretizeBin = []
        else:
            self.DiscretizeBin = DiscretizeBin
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Discretize)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Discretize.subclass:
            return Discretize.subclass(*args_, **kwargs_)
        else:
            return Discretize(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_DiscretizeBin(self): return self.DiscretizeBin
    def set_DiscretizeBin(self, DiscretizeBin): self.DiscretizeBin = DiscretizeBin
    def add_DiscretizeBin(self, value): self.DiscretizeBin.append(value)
    def insert_DiscretizeBin_at(self, index, value): self.DiscretizeBin.insert(index, value)
    def replace_DiscretizeBin_at(self, index, value): self.DiscretizeBin[index] = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_mapMissingTo(self): return self.mapMissingTo
    def set_mapMissingTo(self, mapMissingTo): self.mapMissingTo = mapMissingTo
    def get_defaultValue(self): return self.defaultValue
    def set_defaultValue(self, defaultValue): self.defaultValue = defaultValue
    def get_dataType(self): return self.dataType
    def set_dataType(self, dataType): self.dataType = dataType
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DATATYPE' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Extension or
            self.DiscretizeBin
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Discretize', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Discretize')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Discretize')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Discretize', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Discretize'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.mapMissingTo is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            outfile.write(' mapMissingTo=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mapMissingTo), input_name='mapMissingTo')), ))
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            outfile.write(' defaultValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.defaultValue), input_name='defaultValue')), ))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (quote_attrib(self.dataType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Discretize', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for DiscretizeBin_ in self.DiscretizeBin:
            DiscretizeBin_.export(outfile, level, namespace_, name_='DiscretizeBin', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Discretize', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.mapMissingTo is not None:
            element.set('mapMissingTo', self.gds_format_string(self.mapMissingTo))
        if self.defaultValue is not None:
            element.set('defaultValue', self.gds_format_string(self.defaultValue))
        if self.dataType is not None:
            element.set('dataType', self.dataType)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for DiscretizeBin_ in self.DiscretizeBin:
            DiscretizeBin_.to_etree(element, name_='DiscretizeBin', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Discretize'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.mapMissingTo is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            showIndent(outfile, level)
            outfile.write('mapMissingTo="%s",\n' % (self.mapMissingTo,))
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            showIndent(outfile, level)
            outfile.write('defaultValue="%s",\n' % (self.defaultValue,))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            showIndent(outfile, level)
            outfile.write('dataType="%s",\n' % (self.dataType,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DiscretizeBin=[\n')
        level += 1
        for DiscretizeBin_ in self.DiscretizeBin:
            showIndent(outfile, level)
            outfile.write('model_.DiscretizeBin(\n')
            DiscretizeBin_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('mapMissingTo', node)
        if value is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            self.mapMissingTo = value
        value = find_attr_value_('defaultValue', node)
        if value is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            self.defaultValue = value
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'DiscretizeBin':
            obj_ = DiscretizeBin.factory()
            obj_.build(child_)
            self.DiscretizeBin.append(obj_)
            obj_.original_tagname_ = 'DiscretizeBin'
# end class Discretize


class DiscretizeBin(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, binValue=None, Extension=None, Interval=None):
        self.original_tagname_ = None
        self.binValue = _cast(None, binValue)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Interval = Interval
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiscretizeBin)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiscretizeBin.subclass:
            return DiscretizeBin.subclass(*args_, **kwargs_)
        else:
            return DiscretizeBin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Interval(self): return self.Interval
    def set_Interval(self, Interval): self.Interval = Interval
    def get_binValue(self): return self.binValue
    def set_binValue(self, binValue): self.binValue = binValue
    def hasContent_(self):
        if (
            self.Extension or
            self.Interval is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiscretizeBin', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DiscretizeBin')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiscretizeBin')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DiscretizeBin', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiscretizeBin'):
        if self.binValue is not None and 'binValue' not in already_processed:
            already_processed.add('binValue')
            outfile.write(' binValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.binValue), input_name='binValue')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DiscretizeBin', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Interval is not None:
            self.Interval.export(outfile, level, namespace_, name_='Interval', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DiscretizeBin', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.binValue is not None:
            element.set('binValue', self.gds_format_string(self.binValue))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Interval is not None:
            Interval_ = self.Interval
            Interval_.to_etree(element, name_='Interval', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DiscretizeBin'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.binValue is not None and 'binValue' not in already_processed:
            already_processed.add('binValue')
            showIndent(outfile, level)
            outfile.write('binValue="%s",\n' % (self.binValue,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Interval is not None:
            showIndent(outfile, level)
            outfile.write('Interval=model_.Interval(\n')
            self.Interval.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('binValue', node)
        if value is not None and 'binValue' not in already_processed:
            already_processed.add('binValue')
            self.binValue = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Interval':
            obj_ = Interval.factory()
            obj_.build(child_)
            self.Interval = obj_
            obj_.original_tagname_ = 'Interval'
# end class DiscretizeBin


class MapValues(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mapMissingTo=None, defaultValue=None, outputColumn=None, dataType=None, Extension=None, FieldColumnPair=None, TableLocator=None, InlineTable=None):
        self.original_tagname_ = None
        self.mapMissingTo = _cast(None, mapMissingTo)
        self.defaultValue = _cast(None, defaultValue)
        self.outputColumn = _cast(None, outputColumn)
        self.dataType = _cast(None, dataType)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if FieldColumnPair is None:
            self.FieldColumnPair = []
        else:
            self.FieldColumnPair = FieldColumnPair
        self.TableLocator = TableLocator
        self.InlineTable = InlineTable
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MapValues)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MapValues.subclass:
            return MapValues.subclass(*args_, **kwargs_)
        else:
            return MapValues(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_FieldColumnPair(self): return self.FieldColumnPair
    def set_FieldColumnPair(self, FieldColumnPair): self.FieldColumnPair = FieldColumnPair
    def add_FieldColumnPair(self, value): self.FieldColumnPair.append(value)
    def insert_FieldColumnPair_at(self, index, value): self.FieldColumnPair.insert(index, value)
    def replace_FieldColumnPair_at(self, index, value): self.FieldColumnPair[index] = value
    def get_TableLocator(self): return self.TableLocator
    def set_TableLocator(self, TableLocator): self.TableLocator = TableLocator
    def get_InlineTable(self): return self.InlineTable
    def set_InlineTable(self, InlineTable): self.InlineTable = InlineTable
    def get_mapMissingTo(self): return self.mapMissingTo
    def set_mapMissingTo(self, mapMissingTo): self.mapMissingTo = mapMissingTo
    def get_defaultValue(self): return self.defaultValue
    def set_defaultValue(self, defaultValue): self.defaultValue = defaultValue
    def get_outputColumn(self): return self.outputColumn
    def set_outputColumn(self, outputColumn): self.outputColumn = outputColumn
    def get_dataType(self): return self.dataType
    def set_dataType(self, dataType): self.dataType = dataType
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DATATYPE' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Extension or
            self.FieldColumnPair or
            self.TableLocator is not None or
            self.InlineTable is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MapValues', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MapValues')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MapValues')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MapValues', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MapValues'):
        if self.mapMissingTo is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            outfile.write(' mapMissingTo=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mapMissingTo), input_name='mapMissingTo')), ))
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            outfile.write(' defaultValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.defaultValue), input_name='defaultValue')), ))
        if self.outputColumn is not None and 'outputColumn' not in already_processed:
            already_processed.add('outputColumn')
            outfile.write(' outputColumn=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.outputColumn), input_name='outputColumn')), ))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (quote_attrib(self.dataType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MapValues', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for FieldColumnPair_ in self.FieldColumnPair:
            FieldColumnPair_.export(outfile, level, namespace_, name_='FieldColumnPair', pretty_print=pretty_print)
        if self.TableLocator is not None:
            self.TableLocator.export(outfile, level, namespace_, name_='TableLocator', pretty_print=pretty_print)
        if self.InlineTable is not None:
            self.InlineTable.export(outfile, level, namespace_, name_='InlineTable', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MapValues', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.mapMissingTo is not None:
            element.set('mapMissingTo', self.gds_format_string(self.mapMissingTo))
        if self.defaultValue is not None:
            element.set('defaultValue', self.gds_format_string(self.defaultValue))
        if self.outputColumn is not None:
            element.set('outputColumn', self.gds_format_string(self.outputColumn))
        if self.dataType is not None:
            element.set('dataType', self.dataType)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for FieldColumnPair_ in self.FieldColumnPair:
            FieldColumnPair_.to_etree(element, name_='FieldColumnPair', mapping_=mapping_)
        if self.TableLocator is not None:
            TableLocator_ = self.TableLocator
            TableLocator_.to_etree(element, name_='TableLocator', mapping_=mapping_)
        if self.InlineTable is not None:
            InlineTable_ = self.InlineTable
            InlineTable_.to_etree(element, name_='InlineTable', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MapValues'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mapMissingTo is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            showIndent(outfile, level)
            outfile.write('mapMissingTo="%s",\n' % (self.mapMissingTo,))
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            showIndent(outfile, level)
            outfile.write('defaultValue="%s",\n' % (self.defaultValue,))
        if self.outputColumn is not None and 'outputColumn' not in already_processed:
            already_processed.add('outputColumn')
            showIndent(outfile, level)
            outfile.write('outputColumn="%s",\n' % (self.outputColumn,))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            showIndent(outfile, level)
            outfile.write('dataType="%s",\n' % (self.dataType,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FieldColumnPair=[\n')
        level += 1
        for FieldColumnPair_ in self.FieldColumnPair:
            showIndent(outfile, level)
            outfile.write('model_.FieldColumnPair(\n')
            FieldColumnPair_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.TableLocator is not None:
            showIndent(outfile, level)
            outfile.write('TableLocator=model_.TableLocator(\n')
            self.TableLocator.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InlineTable is not None:
            showIndent(outfile, level)
            outfile.write('InlineTable=model_.InlineTable(\n')
            self.InlineTable.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mapMissingTo', node)
        if value is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            self.mapMissingTo = value
        value = find_attr_value_('defaultValue', node)
        if value is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            self.defaultValue = value
        value = find_attr_value_('outputColumn', node)
        if value is not None and 'outputColumn' not in already_processed:
            already_processed.add('outputColumn')
            self.outputColumn = value
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'FieldColumnPair':
            obj_ = FieldColumnPair.factory()
            obj_.build(child_)
            self.FieldColumnPair.append(obj_)
            obj_.original_tagname_ = 'FieldColumnPair'
        elif nodeName_ == 'TableLocator':
            obj_ = TableLocator.factory()
            obj_.build(child_)
            self.TableLocator = obj_
            obj_.original_tagname_ = 'TableLocator'
        elif nodeName_ == 'InlineTable':
            obj_ = InlineTable.factory()
            obj_.build(child_)
            self.InlineTable = obj_
            obj_.original_tagname_ = 'InlineTable'
# end class MapValues


class FieldColumnPair(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, column=None, Extension=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.column = _cast(None, column)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FieldColumnPair)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FieldColumnPair.subclass:
            return FieldColumnPair.subclass(*args_, **kwargs_)
        else:
            return FieldColumnPair(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FieldColumnPair', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FieldColumnPair')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FieldColumnPair')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FieldColumnPair', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FieldColumnPair'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.column is not None and 'column' not in already_processed:
            already_processed.add('column')
            outfile.write(' column=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.column), input_name='column')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FieldColumnPair', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='FieldColumnPair', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.column is not None:
            element.set('column', self.gds_format_string(self.column))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FieldColumnPair'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.column is not None and 'column' not in already_processed:
            already_processed.add('column')
            showIndent(outfile, level)
            outfile.write('column="%s",\n' % (self.column,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('column', node)
        if value is not None and 'column' not in already_processed:
            already_processed.add('column')
            self.column = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class FieldColumnPair


class TextIndex(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, textField=None, localTermWeights='termFrequency', isCaseSensitive=False, maxLevenshteinDistance=0, countHits='allHits', wordSeparatorCharacterRE='\\s+', tokenize=True, Extension=None, TextIndexNormalization=None, FieldRef=None, Apply=None, Constant=None, NormContinuous=None, NormDiscrete=None, Discretize=None, MapValues=None, TextIndex_member=None, Aggregate=None, Lag=None):
        self.original_tagname_ = None
        self.textField = _cast(None, textField)
        self.localTermWeights = _cast(None, localTermWeights)
        self.isCaseSensitive = _cast(bool, isCaseSensitive)
        self.maxLevenshteinDistance = _cast(int, maxLevenshteinDistance)
        self.countHits = _cast(None, countHits)
        self.wordSeparatorCharacterRE = _cast(None, wordSeparatorCharacterRE)
        self.tokenize = _cast(bool, tokenize)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if TextIndexNormalization is None:
            self.TextIndexNormalization = []
        else:
            self.TextIndexNormalization = TextIndexNormalization
        self.FieldRef = FieldRef
        self.Apply = Apply
        self.Constant = Constant
        self.NormContinuous = NormContinuous
        self.NormDiscrete = NormDiscrete
        self.Discretize = Discretize
        self.MapValues = MapValues
        self.TextIndex = TextIndex_member
        self.Aggregate = Aggregate
        self.Lag = Lag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextIndex)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextIndex.subclass:
            return TextIndex.subclass(*args_, **kwargs_)
        else:
            return TextIndex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_TextIndexNormalization(self): return self.TextIndexNormalization
    def set_TextIndexNormalization(self, TextIndexNormalization): self.TextIndexNormalization = TextIndexNormalization
    def add_TextIndexNormalization(self, value): self.TextIndexNormalization.append(value)
    def insert_TextIndexNormalization_at(self, index, value): self.TextIndexNormalization.insert(index, value)
    def replace_TextIndexNormalization_at(self, index, value): self.TextIndexNormalization[index] = value
    def get_FieldRef(self): return self.FieldRef
    def set_FieldRef(self, FieldRef): self.FieldRef = FieldRef
    def get_Apply(self): return self.Apply
    def set_Apply(self, Apply): self.Apply = Apply
    def get_Constant(self): return self.Constant
    def set_Constant(self, Constant): self.Constant = Constant
    def get_NormContinuous(self): return self.NormContinuous
    def set_NormContinuous(self, NormContinuous): self.NormContinuous = NormContinuous
    def get_NormDiscrete(self): return self.NormDiscrete
    def set_NormDiscrete(self, NormDiscrete): self.NormDiscrete = NormDiscrete
    def get_Discretize(self): return self.Discretize
    def set_Discretize(self, Discretize): self.Discretize = Discretize
    def get_MapValues(self): return self.MapValues
    def set_MapValues(self, MapValues): self.MapValues = MapValues
    def get_TextIndex(self): return self.TextIndex
    def set_TextIndex(self, TextIndex): self.TextIndex = TextIndex
    def get_Aggregate(self): return self.Aggregate
    def set_Aggregate(self, Aggregate): self.Aggregate = Aggregate
    def get_Lag(self): return self.Lag
    def set_Lag(self, Lag): self.Lag = Lag
    def get_textField(self): return self.textField
    def set_textField(self, textField): self.textField = textField
    def get_localTermWeights(self): return self.localTermWeights
    def set_localTermWeights(self, localTermWeights): self.localTermWeights = localTermWeights
    def get_isCaseSensitive(self): return self.isCaseSensitive
    def set_isCaseSensitive(self, isCaseSensitive): self.isCaseSensitive = isCaseSensitive
    def get_maxLevenshteinDistance(self): return self.maxLevenshteinDistance
    def set_maxLevenshteinDistance(self, maxLevenshteinDistance): self.maxLevenshteinDistance = maxLevenshteinDistance
    def get_countHits(self): return self.countHits
    def set_countHits(self, countHits): self.countHits = countHits
    def get_wordSeparatorCharacterRE(self): return self.wordSeparatorCharacterRE
    def set_wordSeparatorCharacterRE(self, wordSeparatorCharacterRE): self.wordSeparatorCharacterRE = wordSeparatorCharacterRE
    def get_tokenize(self): return self.tokenize
    def set_tokenize(self, tokenize): self.tokenize = tokenize
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.TextIndexNormalization or
            self.FieldRef is not None or
            self.Apply is not None or
            self.Constant is not None or
            self.NormContinuous is not None or
            self.NormDiscrete is not None or
            self.Discretize is not None or
            self.MapValues is not None or
            self.TextIndex is not None or
            self.Aggregate is not None or
            self.Lag is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TextIndex', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextIndex')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextIndex')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TextIndex', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextIndex'):
        if self.textField is not None and 'textField' not in already_processed:
            already_processed.add('textField')
            outfile.write(' textField=%s' % (quote_attrib(self.textField), ))
        if self.localTermWeights != "termFrequency" and 'localTermWeights' not in already_processed:
            already_processed.add('localTermWeights')
            outfile.write(' localTermWeights=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.localTermWeights), input_name='localTermWeights')), ))
        if self.isCaseSensitive and 'isCaseSensitive' not in already_processed:
            already_processed.add('isCaseSensitive')
            outfile.write(' isCaseSensitive="%s"' % self.gds_format_boolean(self.isCaseSensitive, input_name='isCaseSensitive'))
        if self.maxLevenshteinDistance != 0 and 'maxLevenshteinDistance' not in already_processed:
            already_processed.add('maxLevenshteinDistance')
            outfile.write(' maxLevenshteinDistance="%s"' % self.gds_format_integer(self.maxLevenshteinDistance, input_name='maxLevenshteinDistance'))
        if self.countHits != "allHits" and 'countHits' not in already_processed:
            already_processed.add('countHits')
            outfile.write(' countHits=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.countHits), input_name='countHits')), ))
        if self.wordSeparatorCharacterRE != "\s+" and 'wordSeparatorCharacterRE' not in already_processed:
            already_processed.add('wordSeparatorCharacterRE')
            outfile.write(' wordSeparatorCharacterRE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.wordSeparatorCharacterRE), input_name='wordSeparatorCharacterRE')), ))
        if not self.tokenize and 'tokenize' not in already_processed:
            already_processed.add('tokenize')
            outfile.write(' tokenize="%s"' % self.gds_format_boolean(self.tokenize, input_name='tokenize'))
    def exportChildren(self, outfile, level, namespace_='', name_='TextIndex', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for TextIndexNormalization_ in self.TextIndexNormalization:
            TextIndexNormalization_.export(outfile, level, namespace_, name_='TextIndexNormalization', pretty_print=pretty_print)
        if self.FieldRef is not None:
            self.FieldRef.export(outfile, level, namespace_, name_='FieldRef', pretty_print=pretty_print)
        if self.Apply is not None:
            self.Apply.export(outfile, level, namespace_, name_='Apply', pretty_print=pretty_print)
        if self.Constant is not None:
            self.Constant.export(outfile, level, namespace_, name_='Constant', pretty_print=pretty_print)
        if self.NormContinuous is not None:
            self.NormContinuous.export(outfile, level, namespace_, name_='NormContinuous', pretty_print=pretty_print)
        if self.NormDiscrete is not None:
            self.NormDiscrete.export(outfile, level, namespace_, name_='NormDiscrete', pretty_print=pretty_print)
        if self.Discretize is not None:
            self.Discretize.export(outfile, level, namespace_, name_='Discretize', pretty_print=pretty_print)
        if self.MapValues is not None:
            self.MapValues.export(outfile, level, namespace_, name_='MapValues', pretty_print=pretty_print)
        if self.TextIndex is not None:
            self.TextIndex.export(outfile, level, namespace_, name_='TextIndex', pretty_print=pretty_print)
        if self.Aggregate is not None:
            self.Aggregate.export(outfile, level, namespace_, name_='Aggregate', pretty_print=pretty_print)
        if self.Lag is not None:
            self.Lag.export(outfile, level, namespace_, name_='Lag', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TextIndex', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.textField is not None:
            element.set('textField', self.textField)
        if self.localTermWeights is not None:
            element.set('localTermWeights', self.gds_format_string(self.localTermWeights))
        if self.isCaseSensitive is not None:
            element.set('isCaseSensitive', self.gds_format_boolean(self.isCaseSensitive))
        if self.maxLevenshteinDistance is not None:
            element.set('maxLevenshteinDistance', self.gds_format_integer(self.maxLevenshteinDistance))
        if self.countHits is not None:
            element.set('countHits', self.gds_format_string(self.countHits))
        if self.wordSeparatorCharacterRE is not None:
            element.set('wordSeparatorCharacterRE', self.gds_format_string(self.wordSeparatorCharacterRE))
        if self.tokenize is not None:
            element.set('tokenize', self.gds_format_boolean(self.tokenize))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for TextIndexNormalization_ in self.TextIndexNormalization:
            TextIndexNormalization_.to_etree(element, name_='TextIndexNormalization', mapping_=mapping_)
        if self.FieldRef is not None:
            FieldRef_ = self.FieldRef
            FieldRef_.to_etree(element, name_='FieldRef', mapping_=mapping_)
        if self.Apply is not None:
            Apply_ = self.Apply
            Apply_.to_etree(element, name_='Apply', mapping_=mapping_)
        if self.Constant is not None:
            Constant_ = self.Constant
            Constant_.to_etree(element, name_='Constant', mapping_=mapping_)
        if self.NormContinuous is not None:
            NormContinuous_ = self.NormContinuous
            NormContinuous_.to_etree(element, name_='NormContinuous', mapping_=mapping_)
        if self.NormDiscrete is not None:
            NormDiscrete_ = self.NormDiscrete
            NormDiscrete_.to_etree(element, name_='NormDiscrete', mapping_=mapping_)
        if self.Discretize is not None:
            Discretize_ = self.Discretize
            Discretize_.to_etree(element, name_='Discretize', mapping_=mapping_)
        if self.MapValues is not None:
            MapValues_ = self.MapValues
            MapValues_.to_etree(element, name_='MapValues', mapping_=mapping_)
        if self.TextIndex is not None:
            TextIndex_ = self.TextIndex
            TextIndex_.to_etree(element, name_='TextIndex', mapping_=mapping_)
        if self.Aggregate is not None:
            Aggregate_ = self.Aggregate
            Aggregate_.to_etree(element, name_='Aggregate', mapping_=mapping_)
        if self.Lag is not None:
            Lag_ = self.Lag
            Lag_.to_etree(element, name_='Lag', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TextIndex'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.textField is not None and 'textField' not in already_processed:
            already_processed.add('textField')
            showIndent(outfile, level)
            outfile.write('textField="%s",\n' % (self.textField,))
        if self.localTermWeights is not None and 'localTermWeights' not in already_processed:
            already_processed.add('localTermWeights')
            showIndent(outfile, level)
            outfile.write('localTermWeights="%s",\n' % (self.localTermWeights,))
        if self.isCaseSensitive is not None and 'isCaseSensitive' not in already_processed:
            already_processed.add('isCaseSensitive')
            showIndent(outfile, level)
            outfile.write('isCaseSensitive=%s,\n' % (self.isCaseSensitive,))
        if self.maxLevenshteinDistance is not None and 'maxLevenshteinDistance' not in already_processed:
            already_processed.add('maxLevenshteinDistance')
            showIndent(outfile, level)
            outfile.write('maxLevenshteinDistance=%d,\n' % (self.maxLevenshteinDistance,))
        if self.countHits is not None and 'countHits' not in already_processed:
            already_processed.add('countHits')
            showIndent(outfile, level)
            outfile.write('countHits="%s",\n' % (self.countHits,))
        if self.wordSeparatorCharacterRE is not None and 'wordSeparatorCharacterRE' not in already_processed:
            already_processed.add('wordSeparatorCharacterRE')
            showIndent(outfile, level)
            outfile.write('wordSeparatorCharacterRE="%s",\n' % (self.wordSeparatorCharacterRE,))
        if self.tokenize is not None and 'tokenize' not in already_processed:
            already_processed.add('tokenize')
            showIndent(outfile, level)
            outfile.write('tokenize=%s,\n' % (self.tokenize,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TextIndexNormalization=[\n')
        level += 1
        for TextIndexNormalization_ in self.TextIndexNormalization:
            showIndent(outfile, level)
            outfile.write('model_.TextIndexNormalization(\n')
            TextIndexNormalization_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.FieldRef is not None:
            showIndent(outfile, level)
            outfile.write('FieldRef=model_.FieldRef(\n')
            self.FieldRef.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Apply is not None:
            showIndent(outfile, level)
            outfile.write('Apply=model_.Apply(\n')
            self.Apply.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Constant is not None:
            showIndent(outfile, level)
            outfile.write('Constant=model_.Constant(\n')
            self.Constant.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormContinuous is not None:
            showIndent(outfile, level)
            outfile.write('NormContinuous=model_.NormContinuous(\n')
            self.NormContinuous.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormDiscrete is not None:
            showIndent(outfile, level)
            outfile.write('NormDiscrete=model_.NormDiscrete(\n')
            self.NormDiscrete.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Discretize is not None:
            showIndent(outfile, level)
            outfile.write('Discretize=model_.Discretize(\n')
            self.Discretize.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MapValues is not None:
            showIndent(outfile, level)
            outfile.write('MapValues=model_.MapValues(\n')
            self.MapValues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextIndex is not None:
            showIndent(outfile, level)
            outfile.write('TextIndex=model_.TextIndex(\n')
            self.TextIndex.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Aggregate is not None:
            showIndent(outfile, level)
            outfile.write('Aggregate=model_.Aggregate(\n')
            self.Aggregate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Lag is not None:
            showIndent(outfile, level)
            outfile.write('Lag=model_.Lag(\n')
            self.Lag.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('textField', node)
        if value is not None and 'textField' not in already_processed:
            already_processed.add('textField')
            self.textField = value
            self.validate_FIELD_NAME(self.textField)    # validate type FIELD-NAME
        value = find_attr_value_('localTermWeights', node)
        if value is not None and 'localTermWeights' not in already_processed:
            already_processed.add('localTermWeights')
            self.localTermWeights = value
        value = find_attr_value_('isCaseSensitive', node)
        if value is not None and 'isCaseSensitive' not in already_processed:
            already_processed.add('isCaseSensitive')
            if value in ('true', '1'):
                self.isCaseSensitive = True
            elif value in ('false', '0'):
                self.isCaseSensitive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('maxLevenshteinDistance', node)
        if value is not None and 'maxLevenshteinDistance' not in already_processed:
            already_processed.add('maxLevenshteinDistance')
            try:
                self.maxLevenshteinDistance = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('countHits', node)
        if value is not None and 'countHits' not in already_processed:
            already_processed.add('countHits')
            self.countHits = value
        value = find_attr_value_('wordSeparatorCharacterRE', node)
        if value is not None and 'wordSeparatorCharacterRE' not in already_processed:
            already_processed.add('wordSeparatorCharacterRE')
            self.wordSeparatorCharacterRE = value
        value = find_attr_value_('tokenize', node)
        if value is not None and 'tokenize' not in already_processed:
            already_processed.add('tokenize')
            if value in ('true', '1'):
                self.tokenize = True
            elif value in ('false', '0'):
                self.tokenize = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TextIndexNormalization':
            obj_ = TextIndexNormalization.factory()
            obj_.build(child_)
            self.TextIndexNormalization.append(obj_)
            obj_.original_tagname_ = 'TextIndexNormalization'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory()
            obj_.build(child_)
            self.FieldRef = obj_
            obj_.original_tagname_ = 'FieldRef'
        elif nodeName_ == 'Apply':
            obj_ = Apply.factory()
            obj_.build(child_)
            self.Apply = obj_
            obj_.original_tagname_ = 'Apply'
        elif nodeName_ == 'Constant':
            obj_ = Constant.factory()
            obj_.build(child_)
            self.Constant = obj_
            obj_.original_tagname_ = 'Constant'
        elif nodeName_ == 'NormContinuous':
            obj_ = NormContinuous.factory()
            obj_.build(child_)
            self.NormContinuous = obj_
            obj_.original_tagname_ = 'NormContinuous'
        elif nodeName_ == 'NormDiscrete':
            obj_ = NormDiscrete.factory()
            obj_.build(child_)
            self.NormDiscrete = obj_
            obj_.original_tagname_ = 'NormDiscrete'
        elif nodeName_ == 'Discretize':
            obj_ = Discretize.factory()
            obj_.build(child_)
            self.Discretize = obj_
            obj_.original_tagname_ = 'Discretize'
        elif nodeName_ == 'MapValues':
            obj_ = MapValues.factory()
            obj_.build(child_)
            self.MapValues = obj_
            obj_.original_tagname_ = 'MapValues'
        elif nodeName_ == 'TextIndex':
            obj_ = TextIndex.factory()
            obj_.build(child_)
            self.TextIndex = obj_
            obj_.original_tagname_ = 'TextIndex'
        elif nodeName_ == 'Aggregate':
            obj_ = Aggregate.factory()
            obj_.build(child_)
            self.Aggregate = obj_
            obj_.original_tagname_ = 'Aggregate'
        elif nodeName_ == 'Lag':
            obj_ = Lag.factory()
            obj_.build(child_)
            self.Lag = obj_
            obj_.original_tagname_ = 'Lag'
# end class TextIndex


class TextIndexNormalization(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, inField='string', outField='stem', regexField='regex', recursive=False, isCaseSensitive=None, maxLevenshteinDistance=None, wordSeparatorCharacterRE=None, tokenize=None, Extension=None, TableLocator=None, InlineTable=None):
        self.original_tagname_ = None
        self.inField = _cast(None, inField)
        self.outField = _cast(None, outField)
        self.regexField = _cast(None, regexField)
        self.recursive = _cast(bool, recursive)
        self.isCaseSensitive = _cast(bool, isCaseSensitive)
        self.maxLevenshteinDistance = _cast(int, maxLevenshteinDistance)
        self.wordSeparatorCharacterRE = _cast(None, wordSeparatorCharacterRE)
        self.tokenize = _cast(bool, tokenize)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.TableLocator = TableLocator
        self.InlineTable = InlineTable
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextIndexNormalization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextIndexNormalization.subclass:
            return TextIndexNormalization.subclass(*args_, **kwargs_)
        else:
            return TextIndexNormalization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_TableLocator(self): return self.TableLocator
    def set_TableLocator(self, TableLocator): self.TableLocator = TableLocator
    def get_InlineTable(self): return self.InlineTable
    def set_InlineTable(self, InlineTable): self.InlineTable = InlineTable
    def get_inField(self): return self.inField
    def set_inField(self, inField): self.inField = inField
    def get_outField(self): return self.outField
    def set_outField(self, outField): self.outField = outField
    def get_regexField(self): return self.regexField
    def set_regexField(self, regexField): self.regexField = regexField
    def get_recursive(self): return self.recursive
    def set_recursive(self, recursive): self.recursive = recursive
    def get_isCaseSensitive(self): return self.isCaseSensitive
    def set_isCaseSensitive(self, isCaseSensitive): self.isCaseSensitive = isCaseSensitive
    def get_maxLevenshteinDistance(self): return self.maxLevenshteinDistance
    def set_maxLevenshteinDistance(self, maxLevenshteinDistance): self.maxLevenshteinDistance = maxLevenshteinDistance
    def get_wordSeparatorCharacterRE(self): return self.wordSeparatorCharacterRE
    def set_wordSeparatorCharacterRE(self, wordSeparatorCharacterRE): self.wordSeparatorCharacterRE = wordSeparatorCharacterRE
    def get_tokenize(self): return self.tokenize
    def set_tokenize(self, tokenize): self.tokenize = tokenize
    def hasContent_(self):
        if (
            self.Extension or
            self.TableLocator is not None or
            self.InlineTable is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TextIndexNormalization', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextIndexNormalization')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextIndexNormalization')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TextIndexNormalization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextIndexNormalization'):
        if self.inField != "string" and 'inField' not in already_processed:
            already_processed.add('inField')
            outfile.write(' inField=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.inField), input_name='inField')), ))
        if self.outField != "stem" and 'outField' not in already_processed:
            already_processed.add('outField')
            outfile.write(' outField=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.outField), input_name='outField')), ))
        if self.regexField != "regex" and 'regexField' not in already_processed:
            already_processed.add('regexField')
            outfile.write(' regexField=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.regexField), input_name='regexField')), ))
        if self.recursive and 'recursive' not in already_processed:
            already_processed.add('recursive')
            outfile.write(' recursive="%s"' % self.gds_format_boolean(self.recursive, input_name='recursive'))
        if self.isCaseSensitive is not None and 'isCaseSensitive' not in already_processed:
            already_processed.add('isCaseSensitive')
            outfile.write(' isCaseSensitive="%s"' % self.gds_format_boolean(self.isCaseSensitive, input_name='isCaseSensitive'))
        if self.maxLevenshteinDistance is not None and 'maxLevenshteinDistance' not in already_processed:
            already_processed.add('maxLevenshteinDistance')
            outfile.write(' maxLevenshteinDistance="%s"' % self.gds_format_integer(self.maxLevenshteinDistance, input_name='maxLevenshteinDistance'))
        if self.wordSeparatorCharacterRE is not None and 'wordSeparatorCharacterRE' not in already_processed:
            already_processed.add('wordSeparatorCharacterRE')
            outfile.write(' wordSeparatorCharacterRE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.wordSeparatorCharacterRE), input_name='wordSeparatorCharacterRE')), ))
        if self.tokenize is not None and 'tokenize' not in already_processed:
            already_processed.add('tokenize')
            outfile.write(' tokenize="%s"' % self.gds_format_boolean(self.tokenize, input_name='tokenize'))
    def exportChildren(self, outfile, level, namespace_='', name_='TextIndexNormalization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.TableLocator is not None:
            self.TableLocator.export(outfile, level, namespace_, name_='TableLocator', pretty_print=pretty_print)
        if self.InlineTable is not None:
            self.InlineTable.export(outfile, level, namespace_, name_='InlineTable', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TextIndexNormalization', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.inField is not None:
            element.set('inField', self.gds_format_string(self.inField))
        if self.outField is not None:
            element.set('outField', self.gds_format_string(self.outField))
        if self.regexField is not None:
            element.set('regexField', self.gds_format_string(self.regexField))
        if self.recursive is not None:
            element.set('recursive', self.gds_format_boolean(self.recursive))
        if self.isCaseSensitive is not None:
            element.set('isCaseSensitive', self.gds_format_boolean(self.isCaseSensitive))
        if self.maxLevenshteinDistance is not None:
            element.set('maxLevenshteinDistance', self.gds_format_integer(self.maxLevenshteinDistance))
        if self.wordSeparatorCharacterRE is not None:
            element.set('wordSeparatorCharacterRE', self.gds_format_string(self.wordSeparatorCharacterRE))
        if self.tokenize is not None:
            element.set('tokenize', self.gds_format_boolean(self.tokenize))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.TableLocator is not None:
            TableLocator_ = self.TableLocator
            TableLocator_.to_etree(element, name_='TableLocator', mapping_=mapping_)
        if self.InlineTable is not None:
            InlineTable_ = self.InlineTable
            InlineTable_.to_etree(element, name_='InlineTable', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TextIndexNormalization'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.inField is not None and 'inField' not in already_processed:
            already_processed.add('inField')
            showIndent(outfile, level)
            outfile.write('inField="%s",\n' % (self.inField,))
        if self.outField is not None and 'outField' not in already_processed:
            already_processed.add('outField')
            showIndent(outfile, level)
            outfile.write('outField="%s",\n' % (self.outField,))
        if self.regexField is not None and 'regexField' not in already_processed:
            already_processed.add('regexField')
            showIndent(outfile, level)
            outfile.write('regexField="%s",\n' % (self.regexField,))
        if self.recursive is not None and 'recursive' not in already_processed:
            already_processed.add('recursive')
            showIndent(outfile, level)
            outfile.write('recursive=%s,\n' % (self.recursive,))
        if self.isCaseSensitive is not None and 'isCaseSensitive' not in already_processed:
            already_processed.add('isCaseSensitive')
            showIndent(outfile, level)
            outfile.write('isCaseSensitive=%s,\n' % (self.isCaseSensitive,))
        if self.maxLevenshteinDistance is not None and 'maxLevenshteinDistance' not in already_processed:
            already_processed.add('maxLevenshteinDistance')
            showIndent(outfile, level)
            outfile.write('maxLevenshteinDistance=%d,\n' % (self.maxLevenshteinDistance,))
        if self.wordSeparatorCharacterRE is not None and 'wordSeparatorCharacterRE' not in already_processed:
            already_processed.add('wordSeparatorCharacterRE')
            showIndent(outfile, level)
            outfile.write('wordSeparatorCharacterRE="%s",\n' % (self.wordSeparatorCharacterRE,))
        if self.tokenize is not None and 'tokenize' not in already_processed:
            already_processed.add('tokenize')
            showIndent(outfile, level)
            outfile.write('tokenize=%s,\n' % (self.tokenize,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.TableLocator is not None:
            showIndent(outfile, level)
            outfile.write('TableLocator=model_.TableLocator(\n')
            self.TableLocator.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InlineTable is not None:
            showIndent(outfile, level)
            outfile.write('InlineTable=model_.InlineTable(\n')
            self.InlineTable.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inField', node)
        if value is not None and 'inField' not in already_processed:
            already_processed.add('inField')
            self.inField = value
        value = find_attr_value_('outField', node)
        if value is not None and 'outField' not in already_processed:
            already_processed.add('outField')
            self.outField = value
        value = find_attr_value_('regexField', node)
        if value is not None and 'regexField' not in already_processed:
            already_processed.add('regexField')
            self.regexField = value
        value = find_attr_value_('recursive', node)
        if value is not None and 'recursive' not in already_processed:
            already_processed.add('recursive')
            if value in ('true', '1'):
                self.recursive = True
            elif value in ('false', '0'):
                self.recursive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isCaseSensitive', node)
        if value is not None and 'isCaseSensitive' not in already_processed:
            already_processed.add('isCaseSensitive')
            if value in ('true', '1'):
                self.isCaseSensitive = True
            elif value in ('false', '0'):
                self.isCaseSensitive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('maxLevenshteinDistance', node)
        if value is not None and 'maxLevenshteinDistance' not in already_processed:
            already_processed.add('maxLevenshteinDistance')
            try:
                self.maxLevenshteinDistance = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('wordSeparatorCharacterRE', node)
        if value is not None and 'wordSeparatorCharacterRE' not in already_processed:
            already_processed.add('wordSeparatorCharacterRE')
            self.wordSeparatorCharacterRE = value
        value = find_attr_value_('tokenize', node)
        if value is not None and 'tokenize' not in already_processed:
            already_processed.add('tokenize')
            if value in ('true', '1'):
                self.tokenize = True
            elif value in ('false', '0'):
                self.tokenize = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TableLocator':
            obj_ = TableLocator.factory()
            obj_.build(child_)
            self.TableLocator = obj_
            obj_.original_tagname_ = 'TableLocator'
        elif nodeName_ == 'InlineTable':
            obj_ = InlineTable.factory()
            obj_.build(child_)
            self.InlineTable = obj_
            obj_.original_tagname_ = 'InlineTable'
# end class TextIndexNormalization


class Aggregate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, function=None, groupField=None, sqlWhere=None, Extension=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.function = _cast(None, function)
        self.groupField = _cast(None, groupField)
        self.sqlWhere = _cast(None, sqlWhere)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Aggregate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Aggregate.subclass:
            return Aggregate.subclass(*args_, **kwargs_)
        else:
            return Aggregate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_function(self): return self.function
    def set_function(self, function): self.function = function
    def get_groupField(self): return self.groupField
    def set_groupField(self, groupField): self.groupField = groupField
    def get_sqlWhere(self): return self.sqlWhere
    def set_sqlWhere(self, sqlWhere): self.sqlWhere = sqlWhere
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Aggregate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Aggregate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Aggregate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Aggregate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Aggregate'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.function is not None and 'function' not in already_processed:
            already_processed.add('function')
            outfile.write(' function=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.function), input_name='function')), ))
        if self.groupField is not None and 'groupField' not in already_processed:
            already_processed.add('groupField')
            outfile.write(' groupField=%s' % (quote_attrib(self.groupField), ))
        if self.sqlWhere is not None and 'sqlWhere' not in already_processed:
            already_processed.add('sqlWhere')
            outfile.write(' sqlWhere=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sqlWhere), input_name='sqlWhere')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Aggregate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Aggregate', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.function is not None:
            element.set('function', self.gds_format_string(self.function))
        if self.groupField is not None:
            element.set('groupField', self.groupField)
        if self.sqlWhere is not None:
            element.set('sqlWhere', self.gds_format_string(self.sqlWhere))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Aggregate'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.function is not None and 'function' not in already_processed:
            already_processed.add('function')
            showIndent(outfile, level)
            outfile.write('function="%s",\n' % (self.function,))
        if self.groupField is not None and 'groupField' not in already_processed:
            already_processed.add('groupField')
            showIndent(outfile, level)
            outfile.write('groupField="%s",\n' % (self.groupField,))
        if self.sqlWhere is not None and 'sqlWhere' not in already_processed:
            already_processed.add('sqlWhere')
            showIndent(outfile, level)
            outfile.write('sqlWhere="%s",\n' % (self.sqlWhere,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('function', node)
        if value is not None and 'function' not in already_processed:
            already_processed.add('function')
            self.function = value
        value = find_attr_value_('groupField', node)
        if value is not None and 'groupField' not in already_processed:
            already_processed.add('groupField')
            self.groupField = value
            self.validate_FIELD_NAME(self.groupField)    # validate type FIELD-NAME
        value = find_attr_value_('sqlWhere', node)
        if value is not None and 'sqlWhere' not in already_processed:
            already_processed.add('sqlWhere')
            self.sqlWhere = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Aggregate


class Lag(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, n=1, aggregate='none', Extension=None, BlockIndicator=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.n = _cast(int, n)
        self.aggregate = _cast(None, aggregate)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if BlockIndicator is None:
            self.BlockIndicator = []
        else:
            self.BlockIndicator = BlockIndicator
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Lag)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Lag.subclass:
            return Lag.subclass(*args_, **kwargs_)
        else:
            return Lag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_BlockIndicator(self): return self.BlockIndicator
    def set_BlockIndicator(self, BlockIndicator): self.BlockIndicator = BlockIndicator
    def add_BlockIndicator(self, value): self.BlockIndicator.append(value)
    def insert_BlockIndicator_at(self, index, value): self.BlockIndicator.insert(index, value)
    def replace_BlockIndicator_at(self, index, value): self.BlockIndicator[index] = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_n(self): return self.n
    def set_n(self, n): self.n = n
    def get_aggregate(self): return self.aggregate
    def set_aggregate(self, aggregate): self.aggregate = aggregate
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.BlockIndicator
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Lag', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Lag')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Lag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Lag', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Lag'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.n != 1 and 'n' not in already_processed:
            already_processed.add('n')
            outfile.write(' n="%s"' % self.gds_format_integer(self.n, input_name='n'))
        if self.aggregate != "none" and 'aggregate' not in already_processed:
            already_processed.add('aggregate')
            outfile.write(' aggregate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aggregate), input_name='aggregate')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Lag', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for BlockIndicator_ in self.BlockIndicator:
            BlockIndicator_.export(outfile, level, namespace_, name_='BlockIndicator', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Lag', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.n is not None:
            element.set('n', self.gds_format_integer(self.n))
        if self.aggregate is not None:
            element.set('aggregate', self.gds_format_string(self.aggregate))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for BlockIndicator_ in self.BlockIndicator:
            BlockIndicator_.to_etree(element, name_='BlockIndicator', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Lag'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.n is not None and 'n' not in already_processed:
            already_processed.add('n')
            showIndent(outfile, level)
            outfile.write('n=%d,\n' % (self.n,))
        if self.aggregate is not None and 'aggregate' not in already_processed:
            already_processed.add('aggregate')
            showIndent(outfile, level)
            outfile.write('aggregate="%s",\n' % (self.aggregate,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BlockIndicator=[\n')
        level += 1
        for BlockIndicator_ in self.BlockIndicator:
            showIndent(outfile, level)
            outfile.write('model_.BlockIndicator(\n')
            BlockIndicator_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('n', node)
        if value is not None and 'n' not in already_processed:
            already_processed.add('n')
            try:
                self.n = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.n <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('aggregate', node)
        if value is not None and 'aggregate' not in already_processed:
            already_processed.add('aggregate')
            self.aggregate = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'BlockIndicator':
            obj_ = BlockIndicator.factory()
            obj_.build(child_)
            self.BlockIndicator.append(obj_)
            obj_.original_tagname_ = 'BlockIndicator'
# end class Lag


class BlockIndicator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, Extension=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BlockIndicator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BlockIndicator.subclass:
            return BlockIndicator.subclass(*args_, **kwargs_)
        else:
            return BlockIndicator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BlockIndicator', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BlockIndicator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BlockIndicator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BlockIndicator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BlockIndicator'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BlockIndicator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BlockIndicator', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BlockIndicator'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class BlockIndicator


class TimeSeriesModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, bestFit=None, isScorable=True, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, LocalTransformations=None, TimeSeries=None, SpectralAnalysis=None, ARIMA=None, ExponentialSmoothing=None, SeasonalTrendDecomposition=None, StateSpaceModel=None, GARCH=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.bestFit = _cast(None, bestFit)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.ModelExplanation = ModelExplanation
        self.LocalTransformations = LocalTransformations
        if TimeSeries is None:
            self.TimeSeries = []
        else:
            self.TimeSeries = TimeSeries
        self.SpectralAnalysis = SpectralAnalysis
        self.ARIMA = ARIMA
        self.ExponentialSmoothing = ExponentialSmoothing
        self.SeasonalTrendDecomposition = SeasonalTrendDecomposition
        self.StateSpaceModel = StateSpaceModel
        self.GARCH = GARCH
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeSeriesModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeSeriesModel.subclass:
            return TimeSeriesModel.subclass(*args_, **kwargs_)
        else:
            return TimeSeriesModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_ModelExplanation(self): return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation): self.ModelExplanation = ModelExplanation
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_TimeSeries(self): return self.TimeSeries
    def set_TimeSeries(self, TimeSeries): self.TimeSeries = TimeSeries
    def add_TimeSeries(self, value): self.TimeSeries.append(value)
    def insert_TimeSeries_at(self, index, value): self.TimeSeries.insert(index, value)
    def replace_TimeSeries_at(self, index, value): self.TimeSeries[index] = value
    def get_SpectralAnalysis(self): return self.SpectralAnalysis
    def set_SpectralAnalysis(self, SpectralAnalysis): self.SpectralAnalysis = SpectralAnalysis
    def get_ARIMA(self): return self.ARIMA
    def set_ARIMA(self, ARIMA): self.ARIMA = ARIMA
    def get_ExponentialSmoothing(self): return self.ExponentialSmoothing
    def set_ExponentialSmoothing(self, ExponentialSmoothing): self.ExponentialSmoothing = ExponentialSmoothing
    def get_SeasonalTrendDecomposition(self): return self.SeasonalTrendDecomposition
    def set_SeasonalTrendDecomposition(self, SeasonalTrendDecomposition): self.SeasonalTrendDecomposition = SeasonalTrendDecomposition
    def get_StateSpaceModel(self): return self.StateSpaceModel
    def set_StateSpaceModel(self, StateSpaceModel): self.StateSpaceModel = StateSpaceModel
    def get_GARCH(self): return self.GARCH
    def set_GARCH(self, GARCH): self.GARCH = GARCH
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_bestFit(self): return self.bestFit
    def set_bestFit(self, bestFit): self.bestFit = bestFit
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_TIMESERIES_ALGORITHM(self, value):
        # Validate type TIMESERIES-ALGORITHM, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ARIMA', 'ExponentialSmoothing', 'SeasonalTrendDecomposition', 'SpectralAnalysis', 'StateSpaceModel', 'GARCH']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TIMESERIES-ALGORITHM' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.LocalTransformations is not None or
            self.TimeSeries or
            self.SpectralAnalysis is not None or
            self.ARIMA is not None or
            self.ExponentialSmoothing is not None or
            self.SeasonalTrendDecomposition is not None or
            self.StateSpaceModel is not None or
            self.GARCH is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeSeriesModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeSeriesModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeSeriesModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeSeriesModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeSeriesModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.bestFit is not None and 'bestFit' not in already_processed:
            already_processed.add('bestFit')
            outfile.write(' bestFit=%s' % (quote_attrib(self.bestFit), ))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeSeriesModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            self.ModelExplanation.export(outfile, level, namespace_, name_='ModelExplanation', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        for TimeSeries_ in self.TimeSeries:
            TimeSeries_.export(outfile, level, namespace_, name_='TimeSeries', pretty_print=pretty_print)
        if self.SpectralAnalysis is not None:
            self.SpectralAnalysis.export(outfile, level, namespace_, name_='SpectralAnalysis', pretty_print=pretty_print)
        if self.ARIMA is not None:
            self.ARIMA.export(outfile, level, namespace_, name_='ARIMA', pretty_print=pretty_print)
        if self.ExponentialSmoothing is not None:
            self.ExponentialSmoothing.export(outfile, level, namespace_, name_='ExponentialSmoothing', pretty_print=pretty_print)
        if self.SeasonalTrendDecomposition is not None:
            self.SeasonalTrendDecomposition.export(outfile, level, namespace_, name_='SeasonalTrendDecomposition', pretty_print=pretty_print)
        if self.StateSpaceModel is not None:
            self.StateSpaceModel.export(outfile, level, namespace_, name_='StateSpaceModel', pretty_print=pretty_print)
        if self.GARCH is not None:
            self.GARCH.export(outfile, level, namespace_, name_='GARCH', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TimeSeriesModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.bestFit is not None:
            element.set('bestFit', self.bestFit)
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.ModelExplanation is not None:
            ModelExplanation_ = self.ModelExplanation
            ModelExplanation_.to_etree(element, name_='ModelExplanation', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        for TimeSeries_ in self.TimeSeries:
            TimeSeries_.to_etree(element, name_='TimeSeries', mapping_=mapping_)
        if self.SpectralAnalysis is not None:
            SpectralAnalysis_ = self.SpectralAnalysis
            SpectralAnalysis_.to_etree(element, name_='SpectralAnalysis', mapping_=mapping_)
        if self.ARIMA is not None:
            ARIMA_ = self.ARIMA
            ARIMA_.to_etree(element, name_='ARIMA', mapping_=mapping_)
        if self.ExponentialSmoothing is not None:
            ExponentialSmoothing_ = self.ExponentialSmoothing
            ExponentialSmoothing_.to_etree(element, name_='ExponentialSmoothing', mapping_=mapping_)
        if self.SeasonalTrendDecomposition is not None:
            SeasonalTrendDecomposition_ = self.SeasonalTrendDecomposition
            SeasonalTrendDecomposition_.to_etree(element, name_='SeasonalTrendDecomposition', mapping_=mapping_)
        if self.StateSpaceModel is not None:
            StateSpaceModel_ = self.StateSpaceModel
            StateSpaceModel_.to_etree(element, name_='StateSpaceModel', mapping_=mapping_)
        if self.GARCH is not None:
            GARCH_ = self.GARCH
            GARCH_.to_etree(element, name_='GARCH', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TimeSeriesModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.bestFit is not None and 'bestFit' not in already_processed:
            already_processed.add('bestFit')
            showIndent(outfile, level)
            outfile.write('bestFit="%s",\n' % (self.bestFit,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelExplanation is not None:
            showIndent(outfile, level)
            outfile.write('ModelExplanation=model_.ModelExplanation(\n')
            self.ModelExplanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('TimeSeries=[\n')
        level += 1
        for TimeSeries_ in self.TimeSeries:
            showIndent(outfile, level)
            outfile.write('model_.TimeSeries(\n')
            TimeSeries_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SpectralAnalysis is not None:
            showIndent(outfile, level)
            outfile.write('SpectralAnalysis=model_.SpectralAnalysis(\n')
            self.SpectralAnalysis.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ARIMA is not None:
            showIndent(outfile, level)
            outfile.write('ARIMA=model_.ARIMA(\n')
            self.ARIMA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExponentialSmoothing is not None:
            showIndent(outfile, level)
            outfile.write('ExponentialSmoothing=model_.ExponentialSmoothing(\n')
            self.ExponentialSmoothing.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SeasonalTrendDecomposition is not None:
            showIndent(outfile, level)
            outfile.write('SeasonalTrendDecomposition=model_.SeasonalTrendDecomposition(\n')
            self.SeasonalTrendDecomposition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StateSpaceModel is not None:
            showIndent(outfile, level)
            outfile.write('StateSpaceModel=model_.StateSpaceModel(\n')
            self.StateSpaceModel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GARCH is not None:
            showIndent(outfile, level)
            outfile.write('GARCH=model_.GARCH(\n')
            self.GARCH.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('bestFit', node)
        if value is not None and 'bestFit' not in already_processed:
            already_processed.add('bestFit')
            self.bestFit = value
            self.validate_TIMESERIES_ALGORITHM(self.bestFit)    # validate type TIMESERIES-ALGORITHM
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory()
            obj_.build(child_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'TimeSeries':
            obj_ = TimeSeries.factory()
            obj_.build(child_)
            self.TimeSeries.append(obj_)
            obj_.original_tagname_ = 'TimeSeries'
        elif nodeName_ == 'SpectralAnalysis':
            obj_ = SpectralAnalysis.factory()
            obj_.build(child_)
            self.SpectralAnalysis = obj_
            obj_.original_tagname_ = 'SpectralAnalysis'
        elif nodeName_ == 'ARIMA':
            obj_ = ARIMA.factory()
            obj_.build(child_)
            self.ARIMA = obj_
            obj_.original_tagname_ = 'ARIMA'
        elif nodeName_ == 'ExponentialSmoothing':
            obj_ = ExponentialSmoothing.factory()
            obj_.build(child_)
            self.ExponentialSmoothing = obj_
            obj_.original_tagname_ = 'ExponentialSmoothing'
        elif nodeName_ == 'SeasonalTrendDecomposition':
            obj_ = SeasonalTrendDecomposition.factory()
            obj_.build(child_)
            self.SeasonalTrendDecomposition = obj_
            obj_.original_tagname_ = 'SeasonalTrendDecomposition'
        elif nodeName_ == 'StateSpaceModel':
            obj_ = StateSpaceModel.factory()
            obj_.build(child_)
            self.StateSpaceModel = obj_
            obj_.original_tagname_ = 'StateSpaceModel'
        elif nodeName_ == 'GARCH':
            obj_ = GARCH.factory()
            obj_.build(child_)
            self.GARCH = obj_
            obj_.original_tagname_ = 'GARCH'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class TimeSeriesModel


class TimeSeries(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, usage='original', startTime=None, endTime=None, interpolationMethod='none', field=None, TimeAnchor=None, TimeValue=None):
        self.original_tagname_ = None
        self.usage = _cast(None, usage)
        self.startTime = _cast(None, startTime)
        self.endTime = _cast(None, endTime)
        self.interpolationMethod = _cast(None, interpolationMethod)
        self.field = _cast(None, field)
        self.TimeAnchor = TimeAnchor
        if TimeValue is None:
            self.TimeValue = []
        else:
            self.TimeValue = TimeValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeSeries)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeSeries.subclass:
            return TimeSeries.subclass(*args_, **kwargs_)
        else:
            return TimeSeries(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeAnchor(self): return self.TimeAnchor
    def set_TimeAnchor(self, TimeAnchor): self.TimeAnchor = TimeAnchor
    def get_TimeValue(self): return self.TimeValue
    def set_TimeValue(self, TimeValue): self.TimeValue = TimeValue
    def add_TimeValue(self, value): self.TimeValue.append(value)
    def insert_TimeValue_at(self, index, value): self.TimeValue.insert(index, value)
    def replace_TimeValue_at(self, index, value): self.TimeValue[index] = value
    def get_usage(self): return self.usage
    def set_usage(self, usage): self.usage = usage
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def get_endTime(self): return self.endTime
    def set_endTime(self, endTime): self.endTime = endTime
    def get_interpolationMethod(self): return self.interpolationMethod
    def set_interpolationMethod(self, interpolationMethod): self.interpolationMethod = interpolationMethod
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def validate_TIMESERIES_USAGE(self, value):
        # Validate type TIMESERIES-USAGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['original', 'logical', 'prediction']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TIMESERIES-USAGE' % {"value" : value.encode("utf-8")} )
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_INTERPOLATION_METHOD(self, value):
        # Validate type INTERPOLATION-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'linear', 'exponentialSpline', 'cubicSpline']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on INTERPOLATION-METHOD' % {"value" : value.encode("utf-8")} )
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.TimeAnchor is not None or
            self.TimeValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeSeries', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeSeries')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeSeries')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeSeries', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeSeries'):
        if self.usage != "original" and 'usage' not in already_processed:
            already_processed.add('usage')
            outfile.write(' usage=%s' % (quote_attrib(self.usage), ))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            outfile.write(' startTime=%s' % (quote_attrib(self.startTime), ))
        if self.endTime is not None and 'endTime' not in already_processed:
            already_processed.add('endTime')
            outfile.write(' endTime=%s' % (quote_attrib(self.endTime), ))
        if self.interpolationMethod != "none" and 'interpolationMethod' not in already_processed:
            already_processed.add('interpolationMethod')
            outfile.write(' interpolationMethod=%s' % (quote_attrib(self.interpolationMethod), ))
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeSeries', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TimeAnchor is not None:
            self.TimeAnchor.export(outfile, level, namespace_, name_='TimeAnchor', pretty_print=pretty_print)
        for TimeValue_ in self.TimeValue:
            TimeValue_.export(outfile, level, namespace_, name_='TimeValue', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TimeSeries', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.usage is not None:
            element.set('usage', self.usage)
        if self.startTime is not None:
            element.set('startTime', self.startTime)
        if self.endTime is not None:
            element.set('endTime', self.endTime)
        if self.interpolationMethod is not None:
            element.set('interpolationMethod', self.interpolationMethod)
        if self.field is not None:
            element.set('field', self.field)
        if self.TimeAnchor is not None:
            TimeAnchor_ = self.TimeAnchor
            TimeAnchor_.to_etree(element, name_='TimeAnchor', mapping_=mapping_)
        for TimeValue_ in self.TimeValue:
            TimeValue_.to_etree(element, name_='TimeValue', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TimeSeries'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.usage is not None and 'usage' not in already_processed:
            already_processed.add('usage')
            showIndent(outfile, level)
            outfile.write('usage="%s",\n' % (self.usage,))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            showIndent(outfile, level)
            outfile.write('startTime=%e,\n' % (self.startTime,))
        if self.endTime is not None and 'endTime' not in already_processed:
            already_processed.add('endTime')
            showIndent(outfile, level)
            outfile.write('endTime=%e,\n' % (self.endTime,))
        if self.interpolationMethod is not None and 'interpolationMethod' not in already_processed:
            already_processed.add('interpolationMethod')
            showIndent(outfile, level)
            outfile.write('interpolationMethod="%s",\n' % (self.interpolationMethod,))
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TimeAnchor is not None:
            showIndent(outfile, level)
            outfile.write('TimeAnchor=model_.TimeAnchor(\n')
            self.TimeAnchor.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('TimeValue=[\n')
        level += 1
        for TimeValue_ in self.TimeValue:
            showIndent(outfile, level)
            outfile.write('model_.TimeValue(\n')
            TimeValue_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('usage', node)
        if value is not None and 'usage' not in already_processed:
            already_processed.add('usage')
            self.usage = value
            self.validate_TIMESERIES_USAGE(self.usage)    # validate type TIMESERIES-USAGE
        value = find_attr_value_('startTime', node)
        if value is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            try:
                self.startTime = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (startTime): %s' % exp)
            self.validate_REAL_NUMBER(self.startTime)    # validate type REAL-NUMBER
        value = find_attr_value_('endTime', node)
        if value is not None and 'endTime' not in already_processed:
            already_processed.add('endTime')
            try:
                self.endTime = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (endTime): %s' % exp)
            self.validate_REAL_NUMBER(self.endTime)    # validate type REAL-NUMBER
        value = find_attr_value_('interpolationMethod', node)
        if value is not None and 'interpolationMethod' not in already_processed:
            already_processed.add('interpolationMethod')
            self.interpolationMethod = value
            self.validate_INTERPOLATION_METHOD(self.interpolationMethod)    # validate type INTERPOLATION-METHOD
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeAnchor':
            obj_ = TimeAnchor.factory()
            obj_.build(child_)
            self.TimeAnchor = obj_
            obj_.original_tagname_ = 'TimeAnchor'
        elif nodeName_ == 'TimeValue':
            obj_ = TimeValue.factory()
            obj_.build(child_)
            self.TimeValue.append(obj_)
            obj_.original_tagname_ = 'TimeValue'
# end class TimeSeries


class TimeValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, index=None, time=None, value=None, standardError=None, Timestamp=None):
        self.original_tagname_ = None
        self.index = _cast(None, index)
        self.time = _cast(None, time)
        self.value = _cast(None, value)
        self.standardError = _cast(None, standardError)
        self.Timestamp = Timestamp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeValue.subclass:
            return TimeValue.subclass(*args_, **kwargs_)
        else:
            return TimeValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Timestamp(self): return self.Timestamp
    def set_Timestamp(self, Timestamp): self.Timestamp = Timestamp
    def get_index(self): return self.index
    def set_index(self, index): self.index = index
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_standardError(self): return self.standardError
    def set_standardError(self, standardError): self.standardError = standardError
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Timestamp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeValue', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeValue')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeValue'):
        if self.index is not None and 'index' not in already_processed:
            already_processed.add('index')
            outfile.write(' index=%s' % (quote_attrib(self.index), ))
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            outfile.write(' time=%s' % (quote_attrib(self.time), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.standardError is not None and 'standardError' not in already_processed:
            already_processed.add('standardError')
            outfile.write(' standardError=%s' % (quote_attrib(self.standardError), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Timestamp is not None:
            self.Timestamp.export(outfile, level, namespace_, name_='Timestamp', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TimeValue', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.index is not None:
            element.set('index', self.index)
        if self.time is not None:
            element.set('time', self.time)
        if self.value is not None:
            element.set('value', self.value)
        if self.standardError is not None:
            element.set('standardError', self.standardError)
        if self.Timestamp is not None:
            Timestamp_ = self.Timestamp
            Timestamp_.to_etree(element, name_='Timestamp', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TimeValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.index is not None and 'index' not in already_processed:
            already_processed.add('index')
            showIndent(outfile, level)
            outfile.write('index=%d,\n' % (self.index,))
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            showIndent(outfile, level)
            outfile.write('time=%e,\n' % (self.time,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value=%e,\n' % (self.value,))
        if self.standardError is not None and 'standardError' not in already_processed:
            already_processed.add('standardError')
            showIndent(outfile, level)
            outfile.write('standardError=%e,\n' % (self.standardError,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Timestamp is not None:
            showIndent(outfile, level)
            outfile.write('Timestamp=model_.Timestamp(\n')
            self.Timestamp.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('index', node)
        if value is not None and 'index' not in already_processed:
            already_processed.add('index')
            try:
                self.index = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.index)    # validate type INT-NUMBER
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.add('time')
            try:
                self.time = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (time): %s' % exp)
            self.validate_NUMBER(self.time)    # validate type NUMBER
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
            self.validate_REAL_NUMBER(self.value)    # validate type REAL-NUMBER
        value = find_attr_value_('standardError', node)
        if value is not None and 'standardError' not in already_processed:
            already_processed.add('standardError')
            try:
                self.standardError = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (standardError): %s' % exp)
            self.validate_REAL_NUMBER(self.standardError)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Timestamp':
            obj_ = Timestamp.factory()
            obj_.build(child_)
            self.Timestamp = obj_
            obj_.original_tagname_ = 'Timestamp'
# end class TimeValue


class TimeAnchor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, offset=None, stepsize=None, displayName=None, TimeCycle=None, TimeException=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.offset = _cast(None, offset)
        self.stepsize = _cast(None, stepsize)
        self.displayName = _cast(None, displayName)
        if TimeCycle is None:
            self.TimeCycle = []
        else:
            self.TimeCycle = TimeCycle
        if TimeException is None:
            self.TimeException = []
        else:
            self.TimeException = TimeException
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeAnchor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeAnchor.subclass:
            return TimeAnchor.subclass(*args_, **kwargs_)
        else:
            return TimeAnchor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeCycle(self): return self.TimeCycle
    def set_TimeCycle(self, TimeCycle): self.TimeCycle = TimeCycle
    def add_TimeCycle(self, value): self.TimeCycle.append(value)
    def insert_TimeCycle_at(self, index, value): self.TimeCycle.insert(index, value)
    def replace_TimeCycle_at(self, index, value): self.TimeCycle[index] = value
    def get_TimeException(self): return self.TimeException
    def set_TimeException(self, TimeException): self.TimeException = TimeException
    def add_TimeException(self, value): self.TimeException.append(value)
    def insert_TimeException_at(self, index, value): self.TimeException.insert(index, value)
    def replace_TimeException_at(self, index, value): self.TimeException[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def get_stepsize(self): return self.stepsize
    def set_stepsize(self, stepsize): self.stepsize = stepsize
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def validate_TIME_ANCHOR(self, value):
        # Validate type TIME-ANCHOR, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['dateTimeMillisecondsSince[0]', 'dateTimeMillisecondsSince[1960]', 'dateTimeMillisecondsSince[1970]', 'dateTimeMillisecondsSince[1980]', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'dateMonthsSince[0]', 'dateMonthsSince[1960]', 'dateMonthsSince[1970]', 'dateMonthsSince[1980]', 'dateYearsSince[0]']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TIME-ANCHOR' % {"value" : value.encode("utf-8")} )
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.TimeCycle or
            self.TimeException
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeAnchor', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeAnchor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeAnchor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeAnchor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeAnchor'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset=%s' % (quote_attrib(self.offset), ))
        if self.stepsize is not None and 'stepsize' not in already_processed:
            already_processed.add('stepsize')
            outfile.write(' stepsize=%s' % (quote_attrib(self.stepsize), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeAnchor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TimeCycle_ in self.TimeCycle:
            TimeCycle_.export(outfile, level, namespace_, name_='TimeCycle', pretty_print=pretty_print)
        for TimeException_ in self.TimeException:
            TimeException_.export(outfile, level, namespace_, name_='TimeException', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TimeAnchor', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.type_ is not None:
            element.set('type', self.type_)
        if self.offset is not None:
            element.set('offset', self.offset)
        if self.stepsize is not None:
            element.set('stepsize', self.stepsize)
        if self.displayName is not None:
            element.set('displayName', self.gds_format_string(self.displayName))
        for TimeCycle_ in self.TimeCycle:
            TimeCycle_.to_etree(element, name_='TimeCycle', mapping_=mapping_)
        for TimeException_ in self.TimeException:
            TimeException_.to_etree(element, name_='TimeException', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TimeAnchor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            showIndent(outfile, level)
            outfile.write('offset=%d,\n' % (self.offset,))
        if self.stepsize is not None and 'stepsize' not in already_processed:
            already_processed.add('stepsize')
            showIndent(outfile, level)
            outfile.write('stepsize=%d,\n' % (self.stepsize,))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            showIndent(outfile, level)
            outfile.write('displayName="%s",\n' % (self.displayName,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('TimeCycle=[\n')
        level += 1
        for TimeCycle_ in self.TimeCycle:
            showIndent(outfile, level)
            outfile.write('model_.TimeCycle(\n')
            TimeCycle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TimeException=[\n')
        level += 1
        for TimeException_ in self.TimeException:
            showIndent(outfile, level)
            outfile.write('model_.TimeException(\n')
            TimeException_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_TIME_ANCHOR(self.type_)    # validate type TIME-ANCHOR
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.offset)    # validate type INT-NUMBER
        value = find_attr_value_('stepsize', node)
        if value is not None and 'stepsize' not in already_processed:
            already_processed.add('stepsize')
            try:
                self.stepsize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.stepsize)    # validate type INT-NUMBER
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeCycle':
            obj_ = TimeCycle.factory()
            obj_.build(child_)
            self.TimeCycle.append(obj_)
            obj_.original_tagname_ = 'TimeCycle'
        elif nodeName_ == 'TimeException':
            obj_ = TimeException.factory()
            obj_.build(child_)
            self.TimeException.append(obj_)
            obj_.original_tagname_ = 'TimeException'
# end class TimeAnchor


class TimeCycle(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, length=None, type_=None, displayName=None, Array=None):
        self.original_tagname_ = None
        self.length = _cast(None, length)
        self.type_ = _cast(None, type_)
        self.displayName = _cast(None, displayName)
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeCycle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeCycle.subclass:
            return TimeCycle.subclass(*args_, **kwargs_)
        else:
            return TimeCycle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_VALID_TIME_SPEC(self, value):
        # Validate type VALID-TIME-SPEC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['includeAll', 'includeFromTo', 'excludeFromTo', 'includeSet', 'excludeSet']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VALID-TIME-SPEC' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeCycle', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeCycle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeCycle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeCycle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeCycle'):
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length=%s' % (quote_attrib(self.length), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeCycle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TimeCycle', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.length is not None:
            element.set('length', self.length)
        if self.type_ is not None:
            element.set('type', self.type_)
        if self.displayName is not None:
            element.set('displayName', self.gds_format_string(self.displayName))
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TimeCycle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            showIndent(outfile, level)
            outfile.write('length=%d,\n' % (self.length,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            showIndent(outfile, level)
            outfile.write('displayName="%s",\n' % (self.displayName,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            try:
                self.length = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.length)    # validate type INT-NUMBER
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_VALID_TIME_SPEC(self.type_)    # validate type VALID-TIME-SPEC
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class TimeCycle


class TimeException(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, count=None, Array=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.count = _cast(None, count)
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeException)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeException.subclass:
            return TimeException.subclass(*args_, **kwargs_)
        else:
            return TimeException(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def validate_TIME_EXCEPTION_TYPE(self, value):
        # Validate type TIME-EXCEPTION-TYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['exclude', 'include']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TIME-EXCEPTION-TYPE' % {"value" : value.encode("utf-8")} )
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeException', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeException')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeException')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeException', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeException'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count=%s' % (quote_attrib(self.count), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeException', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TimeException', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.type_ is not None:
            element.set('type', self.type_)
        if self.count is not None:
            element.set('count', self.count)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TimeException'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%d,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_TIME_EXCEPTION_TYPE(self.type_)    # validate type TIME-EXCEPTION-TYPE
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.count)    # validate type INT-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class TimeException


class ExponentialSmoothing(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RMSE=None, transformation='none', Level=None, Trend_ExpoSmooth=None, Seasonality_ExpoSmooth=None, TimeValue=None):
        self.original_tagname_ = None
        self.RMSE = _cast(None, RMSE)
        self.transformation = _cast(None, transformation)
        self.Level = Level
        self.Trend_ExpoSmooth = Trend_ExpoSmooth
        self.Seasonality_ExpoSmooth = Seasonality_ExpoSmooth
        if TimeValue is None:
            self.TimeValue = []
        else:
            self.TimeValue = TimeValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExponentialSmoothing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExponentialSmoothing.subclass:
            return ExponentialSmoothing.subclass(*args_, **kwargs_)
        else:
            return ExponentialSmoothing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Level(self): return self.Level
    def set_Level(self, Level): self.Level = Level
    def get_Trend_ExpoSmooth(self): return self.Trend_ExpoSmooth
    def set_Trend_ExpoSmooth(self, Trend_ExpoSmooth): self.Trend_ExpoSmooth = Trend_ExpoSmooth
    def get_Seasonality_ExpoSmooth(self): return self.Seasonality_ExpoSmooth
    def set_Seasonality_ExpoSmooth(self, Seasonality_ExpoSmooth): self.Seasonality_ExpoSmooth = Seasonality_ExpoSmooth
    def get_TimeValue(self): return self.TimeValue
    def set_TimeValue(self, TimeValue): self.TimeValue = TimeValue
    def add_TimeValue(self, value): self.TimeValue.append(value)
    def insert_TimeValue_at(self, index, value): self.TimeValue.insert(index, value)
    def replace_TimeValue_at(self, index, value): self.TimeValue[index] = value
    def get_RMSE(self): return self.RMSE
    def set_RMSE(self, RMSE): self.RMSE = RMSE
    def get_transformation(self): return self.transformation
    def set_transformation(self, transformation): self.transformation = transformation
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Level is not None or
            self.Trend_ExpoSmooth is not None or
            self.Seasonality_ExpoSmooth is not None or
            self.TimeValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExponentialSmoothing', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExponentialSmoothing')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExponentialSmoothing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExponentialSmoothing', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExponentialSmoothing'):
        if self.RMSE is not None and 'RMSE' not in already_processed:
            already_processed.add('RMSE')
            outfile.write(' RMSE=%s' % (quote_attrib(self.RMSE), ))
        if self.transformation != "none" and 'transformation' not in already_processed:
            already_processed.add('transformation')
            outfile.write(' transformation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transformation), input_name='transformation')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ExponentialSmoothing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Level is not None:
            self.Level.export(outfile, level, namespace_, name_='Level', pretty_print=pretty_print)
        if self.Trend_ExpoSmooth is not None:
            self.Trend_ExpoSmooth.export(outfile, level, namespace_, name_='Trend_ExpoSmooth', pretty_print=pretty_print)
        if self.Seasonality_ExpoSmooth is not None:
            self.Seasonality_ExpoSmooth.export(outfile, level, namespace_, name_='Seasonality_ExpoSmooth', pretty_print=pretty_print)
        for TimeValue_ in self.TimeValue:
            TimeValue_.export(outfile, level, namespace_, name_='TimeValue', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ExponentialSmoothing', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.RMSE is not None:
            element.set('RMSE', self.RMSE)
        if self.transformation is not None:
            element.set('transformation', self.gds_format_string(self.transformation))
        if self.Level is not None:
            Level_ = self.Level
            Level_.to_etree(element, name_='Level', mapping_=mapping_)
        if self.Trend_ExpoSmooth is not None:
            Trend_ExpoSmooth_ = self.Trend_ExpoSmooth
            Trend_ExpoSmooth_.to_etree(element, name_='Trend_ExpoSmooth', mapping_=mapping_)
        if self.Seasonality_ExpoSmooth is not None:
            Seasonality_ExpoSmooth_ = self.Seasonality_ExpoSmooth
            Seasonality_ExpoSmooth_.to_etree(element, name_='Seasonality_ExpoSmooth', mapping_=mapping_)
        for TimeValue_ in self.TimeValue:
            TimeValue_.to_etree(element, name_='TimeValue', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ExponentialSmoothing'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.RMSE is not None and 'RMSE' not in already_processed:
            already_processed.add('RMSE')
            showIndent(outfile, level)
            outfile.write('RMSE=%e,\n' % (self.RMSE,))
        if self.transformation is not None and 'transformation' not in already_processed:
            already_processed.add('transformation')
            showIndent(outfile, level)
            outfile.write('transformation="%s",\n' % (self.transformation,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Level is not None:
            showIndent(outfile, level)
            outfile.write('Level=model_.Level(\n')
            self.Level.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Trend_ExpoSmooth is not None:
            showIndent(outfile, level)
            outfile.write('Trend_ExpoSmooth=model_.Trend_ExpoSmooth(\n')
            self.Trend_ExpoSmooth.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Seasonality_ExpoSmooth is not None:
            showIndent(outfile, level)
            outfile.write('Seasonality_ExpoSmooth=model_.Seasonality_ExpoSmooth(\n')
            self.Seasonality_ExpoSmooth.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('TimeValue=[\n')
        level += 1
        for TimeValue_ in self.TimeValue:
            showIndent(outfile, level)
            outfile.write('model_.TimeValue(\n')
            TimeValue_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('RMSE', node)
        if value is not None and 'RMSE' not in already_processed:
            already_processed.add('RMSE')
            try:
                self.RMSE = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (RMSE): %s' % exp)
            self.validate_REAL_NUMBER(self.RMSE)    # validate type REAL-NUMBER
        value = find_attr_value_('transformation', node)
        if value is not None and 'transformation' not in already_processed:
            already_processed.add('transformation')
            self.transformation = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Level':
            obj_ = Level.factory()
            obj_.build(child_)
            self.Level = obj_
            obj_.original_tagname_ = 'Level'
        elif nodeName_ == 'Trend_ExpoSmooth':
            obj_ = Trend_ExpoSmooth.factory()
            obj_.build(child_)
            self.Trend_ExpoSmooth = obj_
            obj_.original_tagname_ = 'Trend_ExpoSmooth'
        elif nodeName_ == 'Seasonality_ExpoSmooth':
            obj_ = Seasonality_ExpoSmooth.factory()
            obj_.build(child_)
            self.Seasonality_ExpoSmooth = obj_
            obj_.original_tagname_ = 'Seasonality_ExpoSmooth'
        elif nodeName_ == 'TimeValue':
            obj_ = TimeValue.factory()
            obj_.build(child_)
            self.TimeValue.append(obj_)
            obj_.original_tagname_ = 'TimeValue'
# end class ExponentialSmoothing


class Level(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, alpha=None, smoothedValue=None):
        self.original_tagname_ = None
        self.alpha = _cast(None, alpha)
        self.smoothedValue = _cast(None, smoothedValue)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Level)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Level.subclass:
            return Level.subclass(*args_, **kwargs_)
        else:
            return Level(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_alpha(self): return self.alpha
    def set_alpha(self, alpha): self.alpha = alpha
    def get_smoothedValue(self): return self.smoothedValue
    def set_smoothedValue(self, smoothedValue): self.smoothedValue = smoothedValue
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Level', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Level')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Level')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Level', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Level'):
        if self.alpha is not None and 'alpha' not in already_processed:
            already_processed.add('alpha')
            outfile.write(' alpha=%s' % (quote_attrib(self.alpha), ))
        if self.smoothedValue is not None and 'smoothedValue' not in already_processed:
            already_processed.add('smoothedValue')
            outfile.write(' smoothedValue=%s' % (quote_attrib(self.smoothedValue), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Level', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='Level', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.alpha is not None:
            element.set('alpha', self.alpha)
        if self.smoothedValue is not None:
            element.set('smoothedValue', self.smoothedValue)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Level'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.alpha is not None and 'alpha' not in already_processed:
            already_processed.add('alpha')
            showIndent(outfile, level)
            outfile.write('alpha=%e,\n' % (self.alpha,))
        if self.smoothedValue is not None and 'smoothedValue' not in already_processed:
            already_processed.add('smoothedValue')
            showIndent(outfile, level)
            outfile.write('smoothedValue=%e,\n' % (self.smoothedValue,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alpha', node)
        if value is not None and 'alpha' not in already_processed:
            already_processed.add('alpha')
            try:
                self.alpha = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (alpha): %s' % exp)
            self.validate_REAL_NUMBER(self.alpha)    # validate type REAL-NUMBER
        value = find_attr_value_('smoothedValue', node)
        if value is not None and 'smoothedValue' not in already_processed:
            already_processed.add('smoothedValue')
            try:
                self.smoothedValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (smoothedValue): %s' % exp)
            self.validate_REAL_NUMBER(self.smoothedValue)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Level


class Trend_ExpoSmooth(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, trend='additive', gamma=None, phi='1', smoothedValue=None, Array=None):
        self.original_tagname_ = None
        self.trend = _cast(None, trend)
        self.gamma = _cast(None, gamma)
        self.phi = _cast(None, phi)
        self.smoothedValue = _cast(None, smoothedValue)
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Trend_ExpoSmooth)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Trend_ExpoSmooth.subclass:
            return Trend_ExpoSmooth.subclass(*args_, **kwargs_)
        else:
            return Trend_ExpoSmooth(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def get_trend(self): return self.trend
    def set_trend(self, trend): self.trend = trend
    def get_gamma(self): return self.gamma
    def set_gamma(self, gamma): self.gamma = gamma
    def get_phi(self): return self.phi
    def set_phi(self, phi): self.phi = phi
    def get_smoothedValue(self): return self.smoothedValue
    def set_smoothedValue(self, smoothedValue): self.smoothedValue = smoothedValue
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Trend_ExpoSmooth', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Trend_ExpoSmooth')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Trend_ExpoSmooth')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Trend_ExpoSmooth', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Trend_ExpoSmooth'):
        if self.trend != "additive" and 'trend' not in already_processed:
            already_processed.add('trend')
            outfile.write(' trend=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.trend), input_name='trend')), ))
        if self.gamma is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            outfile.write(' gamma=%s' % (quote_attrib(self.gamma), ))
        if self.phi != 1 and 'phi' not in already_processed:
            already_processed.add('phi')
            outfile.write(' phi=%s' % (quote_attrib(self.phi), ))
        if self.smoothedValue is not None and 'smoothedValue' not in already_processed:
            already_processed.add('smoothedValue')
            outfile.write(' smoothedValue=%s' % (quote_attrib(self.smoothedValue), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Trend_ExpoSmooth', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Trend_ExpoSmooth', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.trend is not None:
            element.set('trend', self.gds_format_string(self.trend))
        if self.gamma is not None:
            element.set('gamma', self.gamma)
        if self.phi is not None:
            element.set('phi', self.phi)
        if self.smoothedValue is not None:
            element.set('smoothedValue', self.smoothedValue)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Trend_ExpoSmooth'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.trend is not None and 'trend' not in already_processed:
            already_processed.add('trend')
            showIndent(outfile, level)
            outfile.write('trend="%s",\n' % (self.trend,))
        if self.gamma is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            showIndent(outfile, level)
            outfile.write('gamma=%e,\n' % (self.gamma,))
        if self.phi is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            showIndent(outfile, level)
            outfile.write('phi=%e,\n' % (self.phi,))
        if self.smoothedValue is not None and 'smoothedValue' not in already_processed:
            already_processed.add('smoothedValue')
            showIndent(outfile, level)
            outfile.write('smoothedValue=%e,\n' % (self.smoothedValue,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('trend', node)
        if value is not None and 'trend' not in already_processed:
            already_processed.add('trend')
            self.trend = value
        value = find_attr_value_('gamma', node)
        if value is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            try:
                self.gamma = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (gamma): %s' % exp)
            self.validate_REAL_NUMBER(self.gamma)    # validate type REAL-NUMBER
        value = find_attr_value_('phi', node)
        if value is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            try:
                self.phi = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (phi): %s' % exp)
            self.validate_REAL_NUMBER(self.phi)    # validate type REAL-NUMBER
        value = find_attr_value_('smoothedValue', node)
        if value is not None and 'smoothedValue' not in already_processed:
            already_processed.add('smoothedValue')
            try:
                self.smoothedValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (smoothedValue): %s' % exp)
            self.validate_REAL_NUMBER(self.smoothedValue)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class Trend_ExpoSmooth


class Seasonality_ExpoSmooth(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, period=None, unit=None, phase=None, delta=None, Array=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.period = _cast(None, period)
        self.unit = _cast(None, unit)
        self.phase = _cast(None, phase)
        self.delta = _cast(None, delta)
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Seasonality_ExpoSmooth)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Seasonality_ExpoSmooth.subclass:
            return Seasonality_ExpoSmooth.subclass(*args_, **kwargs_)
        else:
            return Seasonality_ExpoSmooth(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_phase(self): return self.phase
    def set_phase(self, phase): self.phase = phase
    def get_delta(self): return self.delta
    def set_delta(self, delta): self.delta = delta
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Seasonality_ExpoSmooth', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Seasonality_ExpoSmooth')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Seasonality_ExpoSmooth')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Seasonality_ExpoSmooth', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Seasonality_ExpoSmooth'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period=%s' % (quote_attrib(self.period), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.phase is not None and 'phase' not in already_processed:
            already_processed.add('phase')
            outfile.write(' phase=%s' % (quote_attrib(self.phase), ))
        if self.delta is not None and 'delta' not in already_processed:
            already_processed.add('delta')
            outfile.write(' delta=%s' % (quote_attrib(self.delta), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Seasonality_ExpoSmooth', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Seasonality_ExpoSmooth', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.period is not None:
            element.set('period', self.period)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.phase is not None:
            element.set('phase', self.phase)
        if self.delta is not None:
            element.set('delta', self.delta)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Seasonality_ExpoSmooth'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            showIndent(outfile, level)
            outfile.write('period=%d,\n' % (self.period,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.phase is not None and 'phase' not in already_processed:
            already_processed.add('phase')
            showIndent(outfile, level)
            outfile.write('phase=%d,\n' % (self.phase,))
        if self.delta is not None and 'delta' not in already_processed:
            already_processed.add('delta')
            showIndent(outfile, level)
            outfile.write('delta=%e,\n' % (self.delta,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            try:
                self.period = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.period)    # validate type INT-NUMBER
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('phase', node)
        if value is not None and 'phase' not in already_processed:
            already_processed.add('phase')
            try:
                self.phase = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.phase)    # validate type INT-NUMBER
        value = find_attr_value_('delta', node)
        if value is not None and 'delta' not in already_processed:
            already_processed.add('delta')
            try:
                self.delta = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (delta): %s' % exp)
            self.validate_REAL_NUMBER(self.delta)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class Seasonality_ExpoSmooth


class ARIMA(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RMSE=None, transformation='none', constantTerm='0', predictionMethod='conditionalLeastSquares', Extension=None, NonseasonalComponent=None, SeasonalComponent=None, DynamicRegressor=None, MaximumLikelihoodStat=None, OutlierEffect=None):
        self.original_tagname_ = None
        self.RMSE = _cast(None, RMSE)
        self.transformation = _cast(None, transformation)
        self.constantTerm = _cast(None, constantTerm)
        self.predictionMethod = _cast(None, predictionMethod)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.NonseasonalComponent = NonseasonalComponent
        self.SeasonalComponent = SeasonalComponent
        if DynamicRegressor is None:
            self.DynamicRegressor = []
        else:
            self.DynamicRegressor = DynamicRegressor
        self.MaximumLikelihoodStat = MaximumLikelihoodStat
        if OutlierEffect is None:
            self.OutlierEffect = []
        else:
            self.OutlierEffect = OutlierEffect
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ARIMA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ARIMA.subclass:
            return ARIMA.subclass(*args_, **kwargs_)
        else:
            return ARIMA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_NonseasonalComponent(self): return self.NonseasonalComponent
    def set_NonseasonalComponent(self, NonseasonalComponent): self.NonseasonalComponent = NonseasonalComponent
    def get_SeasonalComponent(self): return self.SeasonalComponent
    def set_SeasonalComponent(self, SeasonalComponent): self.SeasonalComponent = SeasonalComponent
    def get_DynamicRegressor(self): return self.DynamicRegressor
    def set_DynamicRegressor(self, DynamicRegressor): self.DynamicRegressor = DynamicRegressor
    def add_DynamicRegressor(self, value): self.DynamicRegressor.append(value)
    def insert_DynamicRegressor_at(self, index, value): self.DynamicRegressor.insert(index, value)
    def replace_DynamicRegressor_at(self, index, value): self.DynamicRegressor[index] = value
    def get_MaximumLikelihoodStat(self): return self.MaximumLikelihoodStat
    def set_MaximumLikelihoodStat(self, MaximumLikelihoodStat): self.MaximumLikelihoodStat = MaximumLikelihoodStat
    def get_OutlierEffect(self): return self.OutlierEffect
    def set_OutlierEffect(self, OutlierEffect): self.OutlierEffect = OutlierEffect
    def add_OutlierEffect(self, value): self.OutlierEffect.append(value)
    def insert_OutlierEffect_at(self, index, value): self.OutlierEffect.insert(index, value)
    def replace_OutlierEffect_at(self, index, value): self.OutlierEffect[index] = value
    def get_RMSE(self): return self.RMSE
    def set_RMSE(self, RMSE): self.RMSE = RMSE
    def get_transformation(self): return self.transformation
    def set_transformation(self, transformation): self.transformation = transformation
    def get_constantTerm(self): return self.constantTerm
    def set_constantTerm(self, constantTerm): self.constantTerm = constantTerm
    def get_predictionMethod(self): return self.predictionMethod
    def set_predictionMethod(self, predictionMethod): self.predictionMethod = predictionMethod
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.NonseasonalComponent is not None or
            self.SeasonalComponent is not None or
            self.DynamicRegressor or
            self.MaximumLikelihoodStat is not None or
            self.OutlierEffect
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ARIMA', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ARIMA')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ARIMA')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ARIMA', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ARIMA'):
        if self.RMSE is not None and 'RMSE' not in already_processed:
            already_processed.add('RMSE')
            outfile.write(' RMSE=%s' % (quote_attrib(self.RMSE), ))
        if self.transformation != "none" and 'transformation' not in already_processed:
            already_processed.add('transformation')
            outfile.write(' transformation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transformation), input_name='transformation')), ))
        if self.constantTerm != 0 and 'constantTerm' not in already_processed:
            already_processed.add('constantTerm')
            outfile.write(' constantTerm=%s' % (quote_attrib(self.constantTerm), ))
        if self.predictionMethod != "conditionalLeastSquares" and 'predictionMethod' not in already_processed:
            already_processed.add('predictionMethod')
            outfile.write(' predictionMethod=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.predictionMethod), input_name='predictionMethod')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ARIMA', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.NonseasonalComponent is not None:
            self.NonseasonalComponent.export(outfile, level, namespace_, name_='NonseasonalComponent', pretty_print=pretty_print)
        if self.SeasonalComponent is not None:
            self.SeasonalComponent.export(outfile, level, namespace_, name_='SeasonalComponent', pretty_print=pretty_print)
        for DynamicRegressor_ in self.DynamicRegressor:
            DynamicRegressor_.export(outfile, level, namespace_, name_='DynamicRegressor', pretty_print=pretty_print)
        if self.MaximumLikelihoodStat is not None:
            self.MaximumLikelihoodStat.export(outfile, level, namespace_, name_='MaximumLikelihoodStat', pretty_print=pretty_print)
        for OutlierEffect_ in self.OutlierEffect:
            OutlierEffect_.export(outfile, level, namespace_, name_='OutlierEffect', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ARIMA', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.RMSE is not None:
            element.set('RMSE', self.RMSE)
        if self.transformation is not None:
            element.set('transformation', self.gds_format_string(self.transformation))
        if self.constantTerm is not None:
            element.set('constantTerm', self.constantTerm)
        if self.predictionMethod is not None:
            element.set('predictionMethod', self.gds_format_string(self.predictionMethod))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.NonseasonalComponent is not None:
            NonseasonalComponent_ = self.NonseasonalComponent
            NonseasonalComponent_.to_etree(element, name_='NonseasonalComponent', mapping_=mapping_)
        if self.SeasonalComponent is not None:
            SeasonalComponent_ = self.SeasonalComponent
            SeasonalComponent_.to_etree(element, name_='SeasonalComponent', mapping_=mapping_)
        for DynamicRegressor_ in self.DynamicRegressor:
            DynamicRegressor_.to_etree(element, name_='DynamicRegressor', mapping_=mapping_)
        if self.MaximumLikelihoodStat is not None:
            MaximumLikelihoodStat_ = self.MaximumLikelihoodStat
            MaximumLikelihoodStat_.to_etree(element, name_='MaximumLikelihoodStat', mapping_=mapping_)
        for OutlierEffect_ in self.OutlierEffect:
            OutlierEffect_.to_etree(element, name_='OutlierEffect', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ARIMA'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.RMSE is not None and 'RMSE' not in already_processed:
            already_processed.add('RMSE')
            showIndent(outfile, level)
            outfile.write('RMSE=%e,\n' % (self.RMSE,))
        if self.transformation is not None and 'transformation' not in already_processed:
            already_processed.add('transformation')
            showIndent(outfile, level)
            outfile.write('transformation="%s",\n' % (self.transformation,))
        if self.constantTerm is not None and 'constantTerm' not in already_processed:
            already_processed.add('constantTerm')
            showIndent(outfile, level)
            outfile.write('constantTerm=%e,\n' % (self.constantTerm,))
        if self.predictionMethod is not None and 'predictionMethod' not in already_processed:
            already_processed.add('predictionMethod')
            showIndent(outfile, level)
            outfile.write('predictionMethod="%s",\n' % (self.predictionMethod,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.NonseasonalComponent is not None:
            showIndent(outfile, level)
            outfile.write('NonseasonalComponent=model_.NonseasonalComponent(\n')
            self.NonseasonalComponent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SeasonalComponent is not None:
            showIndent(outfile, level)
            outfile.write('SeasonalComponent=model_.SeasonalComponent(\n')
            self.SeasonalComponent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('DynamicRegressor=[\n')
        level += 1
        for DynamicRegressor_ in self.DynamicRegressor:
            showIndent(outfile, level)
            outfile.write('model_.DynamicRegressor(\n')
            DynamicRegressor_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.MaximumLikelihoodStat is not None:
            showIndent(outfile, level)
            outfile.write('MaximumLikelihoodStat=model_.MaximumLikelihoodStat(\n')
            self.MaximumLikelihoodStat.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('OutlierEffect=[\n')
        level += 1
        for OutlierEffect_ in self.OutlierEffect:
            showIndent(outfile, level)
            outfile.write('model_.OutlierEffect(\n')
            OutlierEffect_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('RMSE', node)
        if value is not None and 'RMSE' not in already_processed:
            already_processed.add('RMSE')
            try:
                self.RMSE = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (RMSE): %s' % exp)
            self.validate_REAL_NUMBER(self.RMSE)    # validate type REAL-NUMBER
        value = find_attr_value_('transformation', node)
        if value is not None and 'transformation' not in already_processed:
            already_processed.add('transformation')
            self.transformation = value
        value = find_attr_value_('constantTerm', node)
        if value is not None and 'constantTerm' not in already_processed:
            already_processed.add('constantTerm')
            try:
                self.constantTerm = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (constantTerm): %s' % exp)
            self.validate_REAL_NUMBER(self.constantTerm)    # validate type REAL-NUMBER
        value = find_attr_value_('predictionMethod', node)
        if value is not None and 'predictionMethod' not in already_processed:
            already_processed.add('predictionMethod')
            self.predictionMethod = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'NonseasonalComponent':
            obj_ = NonseasonalComponent.factory()
            obj_.build(child_)
            self.NonseasonalComponent = obj_
            obj_.original_tagname_ = 'NonseasonalComponent'
        elif nodeName_ == 'SeasonalComponent':
            obj_ = SeasonalComponent.factory()
            obj_.build(child_)
            self.SeasonalComponent = obj_
            obj_.original_tagname_ = 'SeasonalComponent'
        elif nodeName_ == 'DynamicRegressor':
            obj_ = DynamicRegressor.factory()
            obj_.build(child_)
            self.DynamicRegressor.append(obj_)
            obj_.original_tagname_ = 'DynamicRegressor'
        elif nodeName_ == 'MaximumLikelihoodStat':
            obj_ = MaximumLikelihoodStat.factory()
            obj_.build(child_)
            self.MaximumLikelihoodStat = obj_
            obj_.original_tagname_ = 'MaximumLikelihoodStat'
        elif nodeName_ == 'OutlierEffect':
            obj_ = OutlierEffect.factory()
            obj_.build(child_)
            self.OutlierEffect.append(obj_)
            obj_.original_tagname_ = 'OutlierEffect'
# end class ARIMA


class NonseasonalComponent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, p=0, d=0, q=0, Extension=None, AR=None, MA=None):
        self.original_tagname_ = None
        self.p = _cast(int, p)
        self.d = _cast(int, d)
        self.q = _cast(int, q)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.AR = AR
        self.MA = MA
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonseasonalComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonseasonalComponent.subclass:
            return NonseasonalComponent.subclass(*args_, **kwargs_)
        else:
            return NonseasonalComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_AR(self): return self.AR
    def set_AR(self, AR): self.AR = AR
    def get_MA(self): return self.MA
    def set_MA(self, MA): self.MA = MA
    def get_p(self): return self.p
    def set_p(self, p): self.p = p
    def get_d(self): return self.d
    def set_d(self, d): self.d = d
    def get_q(self): return self.q
    def set_q(self, q): self.q = q
    def hasContent_(self):
        if (
            self.Extension or
            self.AR is not None or
            self.MA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonseasonalComponent', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NonseasonalComponent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonseasonalComponent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonseasonalComponent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonseasonalComponent'):
        if self.p != 0 and 'p' not in already_processed:
            already_processed.add('p')
            outfile.write(' p="%s"' % self.gds_format_integer(self.p, input_name='p'))
        if self.d != 0 and 'd' not in already_processed:
            already_processed.add('d')
            outfile.write(' d="%s"' % self.gds_format_integer(self.d, input_name='d'))
        if self.q != 0 and 'q' not in already_processed:
            already_processed.add('q')
            outfile.write(' q="%s"' % self.gds_format_integer(self.q, input_name='q'))
    def exportChildren(self, outfile, level, namespace_='', name_='NonseasonalComponent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.AR is not None:
            self.AR.export(outfile, level, namespace_, name_='AR', pretty_print=pretty_print)
        if self.MA is not None:
            self.MA.export(outfile, level, namespace_, name_='MA', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NonseasonalComponent', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.p is not None:
            element.set('p', self.gds_format_integer(self.p))
        if self.d is not None:
            element.set('d', self.gds_format_integer(self.d))
        if self.q is not None:
            element.set('q', self.gds_format_integer(self.q))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.AR is not None:
            AR_ = self.AR
            AR_.to_etree(element, name_='AR', mapping_=mapping_)
        if self.MA is not None:
            MA_ = self.MA
            MA_.to_etree(element, name_='MA', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NonseasonalComponent'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.p is not None and 'p' not in already_processed:
            already_processed.add('p')
            showIndent(outfile, level)
            outfile.write('p=%d,\n' % (self.p,))
        if self.d is not None and 'd' not in already_processed:
            already_processed.add('d')
            showIndent(outfile, level)
            outfile.write('d=%d,\n' % (self.d,))
        if self.q is not None and 'q' not in already_processed:
            already_processed.add('q')
            showIndent(outfile, level)
            outfile.write('q=%d,\n' % (self.q,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.AR is not None:
            showIndent(outfile, level)
            outfile.write('AR=model_.AR(\n')
            self.AR.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MA is not None:
            showIndent(outfile, level)
            outfile.write('MA=model_.MA(\n')
            self.MA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('p', node)
        if value is not None and 'p' not in already_processed:
            already_processed.add('p')
            try:
                self.p = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.p < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('d', node)
        if value is not None and 'd' not in already_processed:
            already_processed.add('d')
            try:
                self.d = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.d < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('q', node)
        if value is not None and 'q' not in already_processed:
            already_processed.add('q')
            try:
                self.q = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.q < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'AR':
            obj_ = AR.factory()
            obj_.build(child_)
            self.AR = obj_
            obj_.original_tagname_ = 'AR'
        elif nodeName_ == 'MA':
            obj_ = MA.factory()
            obj_.build(child_)
            self.MA = obj_
            obj_.original_tagname_ = 'MA'
# end class NonseasonalComponent


class SeasonalComponent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, P=0, D=0, Q=0, period=None, Extension=None, AR=None, MA=None):
        self.original_tagname_ = None
        self.P = _cast(int, P)
        self.D = _cast(int, D)
        self.Q = _cast(int, Q)
        self.period = _cast(int, period)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.AR = AR
        self.MA = MA
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SeasonalComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SeasonalComponent.subclass:
            return SeasonalComponent.subclass(*args_, **kwargs_)
        else:
            return SeasonalComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_AR(self): return self.AR
    def set_AR(self, AR): self.AR = AR
    def get_MA(self): return self.MA
    def set_MA(self, MA): self.MA = MA
    def get_P(self): return self.P
    def set_P(self, P): self.P = P
    def get_D(self): return self.D
    def set_D(self, D): self.D = D
    def get_Q(self): return self.Q
    def set_Q(self, Q): self.Q = Q
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def hasContent_(self):
        if (
            self.Extension or
            self.AR is not None or
            self.MA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SeasonalComponent', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SeasonalComponent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SeasonalComponent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SeasonalComponent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SeasonalComponent'):
        if self.P != 0 and 'P' not in already_processed:
            already_processed.add('P')
            outfile.write(' P="%s"' % self.gds_format_integer(self.P, input_name='P'))
        if self.D != 0 and 'D' not in already_processed:
            already_processed.add('D')
            outfile.write(' D="%s"' % self.gds_format_integer(self.D, input_name='D'))
        if self.Q != 0 and 'Q' not in already_processed:
            already_processed.add('Q')
            outfile.write(' Q="%s"' % self.gds_format_integer(self.Q, input_name='Q'))
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period="%s"' % self.gds_format_integer(self.period, input_name='period'))
    def exportChildren(self, outfile, level, namespace_='', name_='SeasonalComponent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.AR is not None:
            self.AR.export(outfile, level, namespace_, name_='AR', pretty_print=pretty_print)
        if self.MA is not None:
            self.MA.export(outfile, level, namespace_, name_='MA', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SeasonalComponent', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.P is not None:
            element.set('P', self.gds_format_integer(self.P))
        if self.D is not None:
            element.set('D', self.gds_format_integer(self.D))
        if self.Q is not None:
            element.set('Q', self.gds_format_integer(self.Q))
        if self.period is not None:
            element.set('period', self.gds_format_integer(self.period))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.AR is not None:
            AR_ = self.AR
            AR_.to_etree(element, name_='AR', mapping_=mapping_)
        if self.MA is not None:
            MA_ = self.MA
            MA_.to_etree(element, name_='MA', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SeasonalComponent'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.P is not None and 'P' not in already_processed:
            already_processed.add('P')
            showIndent(outfile, level)
            outfile.write('P=%d,\n' % (self.P,))
        if self.D is not None and 'D' not in already_processed:
            already_processed.add('D')
            showIndent(outfile, level)
            outfile.write('D=%d,\n' % (self.D,))
        if self.Q is not None and 'Q' not in already_processed:
            already_processed.add('Q')
            showIndent(outfile, level)
            outfile.write('Q=%d,\n' % (self.Q,))
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            showIndent(outfile, level)
            outfile.write('period=%d,\n' % (self.period,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.AR is not None:
            showIndent(outfile, level)
            outfile.write('AR=model_.AR(\n')
            self.AR.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MA is not None:
            showIndent(outfile, level)
            outfile.write('MA=model_.MA(\n')
            self.MA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('P', node)
        if value is not None and 'P' not in already_processed:
            already_processed.add('P')
            try:
                self.P = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.P < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('D', node)
        if value is not None and 'D' not in already_processed:
            already_processed.add('D')
            try:
                self.D = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.D < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('Q', node)
        if value is not None and 'Q' not in already_processed:
            already_processed.add('Q')
            try:
                self.Q = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.Q < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            try:
                self.period = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.period < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'AR':
            obj_ = AR.factory()
            obj_.build(child_)
            self.AR = obj_
            obj_.original_tagname_ = 'AR'
        elif nodeName_ == 'MA':
            obj_ = MA.factory()
            obj_.build(child_)
            self.MA = obj_
            obj_.original_tagname_ = 'MA'
# end class SeasonalComponent


class AR(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AR.subclass:
            return AR.subclass(*args_, **kwargs_)
        else:
            return AR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AR', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AR', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AR'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AR', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AR', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='AR'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class AR


class MA(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, MACoefficients=None, Residuals=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.MACoefficients = MACoefficients
        self.Residuals = Residuals
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MA.subclass:
            return MA.subclass(*args_, **kwargs_)
        else:
            return MA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_MACoefficients(self): return self.MACoefficients
    def set_MACoefficients(self, MACoefficients): self.MACoefficients = MACoefficients
    def get_Residuals(self): return self.Residuals
    def set_Residuals(self, Residuals): self.Residuals = Residuals
    def hasContent_(self):
        if (
            self.Extension or
            self.MACoefficients is not None or
            self.Residuals is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MA', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MA')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MA')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MA', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MA'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MA', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.MACoefficients is not None:
            self.MACoefficients.export(outfile, level, namespace_, name_='MACoefficients', pretty_print=pretty_print)
        if self.Residuals is not None:
            self.Residuals.export(outfile, level, namespace_, name_='Residuals', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MA', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.MACoefficients is not None:
            MACoefficients_ = self.MACoefficients
            MACoefficients_.to_etree(element, name_='MACoefficients', mapping_=mapping_)
        if self.Residuals is not None:
            Residuals_ = self.Residuals
            Residuals_.to_etree(element, name_='Residuals', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MA'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.MACoefficients is not None:
            showIndent(outfile, level)
            outfile.write('MACoefficients=model_.MACoefficients(\n')
            self.MACoefficients.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Residuals is not None:
            showIndent(outfile, level)
            outfile.write('Residuals=model_.Residuals(\n')
            self.Residuals.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'MACoefficients':
            obj_ = MACoefficients.factory()
            obj_.build(child_)
            self.MACoefficients = obj_
            obj_.original_tagname_ = 'MACoefficients'
        elif nodeName_ == 'Residuals':
            obj_ = Residuals.factory()
            obj_.build(child_)
            self.Residuals = obj_
            obj_.original_tagname_ = 'Residuals'
# end class MA


class MACoefficients(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MACoefficients)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MACoefficients.subclass:
            return MACoefficients.subclass(*args_, **kwargs_)
        else:
            return MACoefficients(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MACoefficients', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MACoefficients')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MACoefficients')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MACoefficients', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MACoefficients'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MACoefficients', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MACoefficients', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MACoefficients'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class MACoefficients


class Residuals(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Residuals)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Residuals.subclass:
            return Residuals.subclass(*args_, **kwargs_)
        else:
            return Residuals(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Residuals', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Residuals')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Residuals')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Residuals', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Residuals'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Residuals', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Residuals', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Residuals'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class Residuals


class DynamicRegressor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, transformation='none', delay='0', futureValuesMethod='constant', targetField=None, Extension=None, Numerator=None, Denominator=None, RegressorValues=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.transformation = _cast(None, transformation)
        self.delay = _cast(None, delay)
        self.futureValuesMethod = _cast(None, futureValuesMethod)
        self.targetField = _cast(None, targetField)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Numerator = Numerator
        self.Denominator = Denominator
        self.RegressorValues = RegressorValues
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DynamicRegressor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DynamicRegressor.subclass:
            return DynamicRegressor.subclass(*args_, **kwargs_)
        else:
            return DynamicRegressor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Numerator(self): return self.Numerator
    def set_Numerator(self, Numerator): self.Numerator = Numerator
    def get_Denominator(self): return self.Denominator
    def set_Denominator(self, Denominator): self.Denominator = Denominator
    def get_RegressorValues(self): return self.RegressorValues
    def set_RegressorValues(self, RegressorValues): self.RegressorValues = RegressorValues
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_transformation(self): return self.transformation
    def set_transformation(self, transformation): self.transformation = transformation
    def get_delay(self): return self.delay
    def set_delay(self, delay): self.delay = delay
    def get_futureValuesMethod(self): return self.futureValuesMethod
    def set_futureValuesMethod(self, futureValuesMethod): self.futureValuesMethod = futureValuesMethod
    def get_targetField(self): return self.targetField
    def set_targetField(self, targetField): self.targetField = targetField
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Numerator is not None or
            self.Denominator is not None or
            self.RegressorValues is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DynamicRegressor', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DynamicRegressor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DynamicRegressor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DynamicRegressor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DynamicRegressor'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.transformation != "none" and 'transformation' not in already_processed:
            already_processed.add('transformation')
            outfile.write(' transformation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transformation), input_name='transformation')), ))
        if self.delay != 0 and 'delay' not in already_processed:
            already_processed.add('delay')
            outfile.write(' delay=%s' % (quote_attrib(self.delay), ))
        if self.futureValuesMethod != "constant" and 'futureValuesMethod' not in already_processed:
            already_processed.add('futureValuesMethod')
            outfile.write(' futureValuesMethod=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.futureValuesMethod), input_name='futureValuesMethod')), ))
        if self.targetField is not None and 'targetField' not in already_processed:
            already_processed.add('targetField')
            outfile.write(' targetField=%s' % (quote_attrib(self.targetField), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DynamicRegressor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Numerator is not None:
            self.Numerator.export(outfile, level, namespace_, name_='Numerator', pretty_print=pretty_print)
        if self.Denominator is not None:
            self.Denominator.export(outfile, level, namespace_, name_='Denominator', pretty_print=pretty_print)
        if self.RegressorValues is not None:
            self.RegressorValues.export(outfile, level, namespace_, name_='RegressorValues', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DynamicRegressor', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.transformation is not None:
            element.set('transformation', self.gds_format_string(self.transformation))
        if self.delay is not None:
            element.set('delay', self.delay)
        if self.futureValuesMethod is not None:
            element.set('futureValuesMethod', self.gds_format_string(self.futureValuesMethod))
        if self.targetField is not None:
            element.set('targetField', self.targetField)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Numerator is not None:
            Numerator_ = self.Numerator
            Numerator_.to_etree(element, name_='Numerator', mapping_=mapping_)
        if self.Denominator is not None:
            Denominator_ = self.Denominator
            Denominator_.to_etree(element, name_='Denominator', mapping_=mapping_)
        if self.RegressorValues is not None:
            RegressorValues_ = self.RegressorValues
            RegressorValues_.to_etree(element, name_='RegressorValues', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DynamicRegressor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.transformation is not None and 'transformation' not in already_processed:
            already_processed.add('transformation')
            showIndent(outfile, level)
            outfile.write('transformation="%s",\n' % (self.transformation,))
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            showIndent(outfile, level)
            outfile.write('delay=%d,\n' % (self.delay,))
        if self.futureValuesMethod is not None and 'futureValuesMethod' not in already_processed:
            already_processed.add('futureValuesMethod')
            showIndent(outfile, level)
            outfile.write('futureValuesMethod="%s",\n' % (self.futureValuesMethod,))
        if self.targetField is not None and 'targetField' not in already_processed:
            already_processed.add('targetField')
            showIndent(outfile, level)
            outfile.write('targetField="%s",\n' % (self.targetField,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Numerator is not None:
            showIndent(outfile, level)
            outfile.write('Numerator=model_.Numerator(\n')
            self.Numerator.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Denominator is not None:
            showIndent(outfile, level)
            outfile.write('Denominator=model_.Denominator(\n')
            self.Denominator.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RegressorValues is not None:
            showIndent(outfile, level)
            outfile.write('RegressorValues=model_.RegressorValues(\n')
            self.RegressorValues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('transformation', node)
        if value is not None and 'transformation' not in already_processed:
            already_processed.add('transformation')
            self.transformation = value
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.add('delay')
            try:
                self.delay = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.delay)    # validate type INT-NUMBER
        value = find_attr_value_('futureValuesMethod', node)
        if value is not None and 'futureValuesMethod' not in already_processed:
            already_processed.add('futureValuesMethod')
            self.futureValuesMethod = value
        value = find_attr_value_('targetField', node)
        if value is not None and 'targetField' not in already_processed:
            already_processed.add('targetField')
            self.targetField = value
            self.validate_FIELD_NAME(self.targetField)    # validate type FIELD-NAME
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Numerator':
            obj_ = Numerator.factory()
            obj_.build(child_)
            self.Numerator = obj_
            obj_.original_tagname_ = 'Numerator'
        elif nodeName_ == 'Denominator':
            obj_ = Denominator.factory()
            obj_.build(child_)
            self.Denominator = obj_
            obj_.original_tagname_ = 'Denominator'
        elif nodeName_ == 'RegressorValues':
            obj_ = RegressorValues.factory()
            obj_.build(child_)
            self.RegressorValues = obj_
            obj_.original_tagname_ = 'RegressorValues'
# end class DynamicRegressor


class Numerator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, NonseasonalFactor=None, SeasonalFactor=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.NonseasonalFactor = NonseasonalFactor
        self.SeasonalFactor = SeasonalFactor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Numerator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Numerator.subclass:
            return Numerator.subclass(*args_, **kwargs_)
        else:
            return Numerator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_NonseasonalFactor(self): return self.NonseasonalFactor
    def set_NonseasonalFactor(self, NonseasonalFactor): self.NonseasonalFactor = NonseasonalFactor
    def get_SeasonalFactor(self): return self.SeasonalFactor
    def set_SeasonalFactor(self, SeasonalFactor): self.SeasonalFactor = SeasonalFactor
    def hasContent_(self):
        if (
            self.Extension or
            self.NonseasonalFactor is not None or
            self.SeasonalFactor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Numerator', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Numerator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Numerator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Numerator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Numerator'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Numerator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.NonseasonalFactor is not None:
            self.NonseasonalFactor.export(outfile, level, namespace_, name_='NonseasonalFactor', pretty_print=pretty_print)
        if self.SeasonalFactor is not None:
            self.SeasonalFactor.export(outfile, level, namespace_, name_='SeasonalFactor', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Numerator', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.NonseasonalFactor is not None:
            NonseasonalFactor_ = self.NonseasonalFactor
            NonseasonalFactor_.to_etree(element, name_='NonseasonalFactor', mapping_=mapping_)
        if self.SeasonalFactor is not None:
            SeasonalFactor_ = self.SeasonalFactor
            SeasonalFactor_.to_etree(element, name_='SeasonalFactor', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Numerator'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.NonseasonalFactor is not None:
            showIndent(outfile, level)
            outfile.write('NonseasonalFactor=model_.NonseasonalFactor(\n')
            self.NonseasonalFactor.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SeasonalFactor is not None:
            showIndent(outfile, level)
            outfile.write('SeasonalFactor=model_.SeasonalFactor(\n')
            self.SeasonalFactor.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'NonseasonalFactor':
            obj_ = NonseasonalFactor.factory()
            obj_.build(child_)
            self.NonseasonalFactor = obj_
            obj_.original_tagname_ = 'NonseasonalFactor'
        elif nodeName_ == 'SeasonalFactor':
            obj_ = SeasonalFactor.factory()
            obj_.build(child_)
            self.SeasonalFactor = obj_
            obj_.original_tagname_ = 'SeasonalFactor'
# end class Numerator


class Denominator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, NonseasonalFactor=None, SeasonalFactor=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.NonseasonalFactor = NonseasonalFactor
        self.SeasonalFactor = SeasonalFactor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Denominator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Denominator.subclass:
            return Denominator.subclass(*args_, **kwargs_)
        else:
            return Denominator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_NonseasonalFactor(self): return self.NonseasonalFactor
    def set_NonseasonalFactor(self, NonseasonalFactor): self.NonseasonalFactor = NonseasonalFactor
    def get_SeasonalFactor(self): return self.SeasonalFactor
    def set_SeasonalFactor(self, SeasonalFactor): self.SeasonalFactor = SeasonalFactor
    def hasContent_(self):
        if (
            self.Extension or
            self.NonseasonalFactor is not None or
            self.SeasonalFactor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Denominator', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Denominator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Denominator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Denominator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Denominator'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Denominator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.NonseasonalFactor is not None:
            self.NonseasonalFactor.export(outfile, level, namespace_, name_='NonseasonalFactor', pretty_print=pretty_print)
        if self.SeasonalFactor is not None:
            self.SeasonalFactor.export(outfile, level, namespace_, name_='SeasonalFactor', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Denominator', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.NonseasonalFactor is not None:
            NonseasonalFactor_ = self.NonseasonalFactor
            NonseasonalFactor_.to_etree(element, name_='NonseasonalFactor', mapping_=mapping_)
        if self.SeasonalFactor is not None:
            SeasonalFactor_ = self.SeasonalFactor
            SeasonalFactor_.to_etree(element, name_='SeasonalFactor', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Denominator'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.NonseasonalFactor is not None:
            showIndent(outfile, level)
            outfile.write('NonseasonalFactor=model_.NonseasonalFactor(\n')
            self.NonseasonalFactor.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SeasonalFactor is not None:
            showIndent(outfile, level)
            outfile.write('SeasonalFactor=model_.SeasonalFactor(\n')
            self.SeasonalFactor.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'NonseasonalFactor':
            obj_ = NonseasonalFactor.factory()
            obj_.build(child_)
            self.NonseasonalFactor = obj_
            obj_.original_tagname_ = 'NonseasonalFactor'
        elif nodeName_ == 'SeasonalFactor':
            obj_ = SeasonalFactor.factory()
            obj_.build(child_)
            self.SeasonalFactor = obj_
            obj_.original_tagname_ = 'SeasonalFactor'
# end class Denominator


class SeasonalFactor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, difference='0', maximumOrder=None, Extension=None, Array=None):
        self.original_tagname_ = None
        self.difference = _cast(None, difference)
        self.maximumOrder = _cast(None, maximumOrder)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SeasonalFactor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SeasonalFactor.subclass:
            return SeasonalFactor.subclass(*args_, **kwargs_)
        else:
            return SeasonalFactor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def get_difference(self): return self.difference
    def set_difference(self, difference): self.difference = difference
    def get_maximumOrder(self): return self.maximumOrder
    def set_maximumOrder(self, maximumOrder): self.maximumOrder = maximumOrder
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SeasonalFactor', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SeasonalFactor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SeasonalFactor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SeasonalFactor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SeasonalFactor'):
        if self.difference != 0 and 'difference' not in already_processed:
            already_processed.add('difference')
            outfile.write(' difference=%s' % (quote_attrib(self.difference), ))
        if self.maximumOrder is not None and 'maximumOrder' not in already_processed:
            already_processed.add('maximumOrder')
            outfile.write(' maximumOrder=%s' % (quote_attrib(self.maximumOrder), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SeasonalFactor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SeasonalFactor', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.difference is not None:
            element.set('difference', self.difference)
        if self.maximumOrder is not None:
            element.set('maximumOrder', self.maximumOrder)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SeasonalFactor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.difference is not None and 'difference' not in already_processed:
            already_processed.add('difference')
            showIndent(outfile, level)
            outfile.write('difference=%d,\n' % (self.difference,))
        if self.maximumOrder is not None and 'maximumOrder' not in already_processed:
            already_processed.add('maximumOrder')
            showIndent(outfile, level)
            outfile.write('maximumOrder=%d,\n' % (self.maximumOrder,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('difference', node)
        if value is not None and 'difference' not in already_processed:
            already_processed.add('difference')
            try:
                self.difference = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.difference)    # validate type INT-NUMBER
        value = find_attr_value_('maximumOrder', node)
        if value is not None and 'maximumOrder' not in already_processed:
            already_processed.add('maximumOrder')
            try:
                self.maximumOrder = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.maximumOrder)    # validate type INT-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class SeasonalFactor


class NonseasonalFactor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, difference='0', maximumOrder=None, Extension=None, Array=None):
        self.original_tagname_ = None
        self.difference = _cast(None, difference)
        self.maximumOrder = _cast(None, maximumOrder)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonseasonalFactor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonseasonalFactor.subclass:
            return NonseasonalFactor.subclass(*args_, **kwargs_)
        else:
            return NonseasonalFactor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def get_difference(self): return self.difference
    def set_difference(self, difference): self.difference = difference
    def get_maximumOrder(self): return self.maximumOrder
    def set_maximumOrder(self, maximumOrder): self.maximumOrder = maximumOrder
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonseasonalFactor', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NonseasonalFactor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonseasonalFactor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonseasonalFactor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonseasonalFactor'):
        if self.difference != 0 and 'difference' not in already_processed:
            already_processed.add('difference')
            outfile.write(' difference=%s' % (quote_attrib(self.difference), ))
        if self.maximumOrder is not None and 'maximumOrder' not in already_processed:
            already_processed.add('maximumOrder')
            outfile.write(' maximumOrder=%s' % (quote_attrib(self.maximumOrder), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NonseasonalFactor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NonseasonalFactor', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.difference is not None:
            element.set('difference', self.difference)
        if self.maximumOrder is not None:
            element.set('maximumOrder', self.maximumOrder)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NonseasonalFactor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.difference is not None and 'difference' not in already_processed:
            already_processed.add('difference')
            showIndent(outfile, level)
            outfile.write('difference=%d,\n' % (self.difference,))
        if self.maximumOrder is not None and 'maximumOrder' not in already_processed:
            already_processed.add('maximumOrder')
            showIndent(outfile, level)
            outfile.write('maximumOrder=%d,\n' % (self.maximumOrder,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('difference', node)
        if value is not None and 'difference' not in already_processed:
            already_processed.add('difference')
            try:
                self.difference = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.difference)    # validate type INT-NUMBER
        value = find_attr_value_('maximumOrder', node)
        if value is not None and 'maximumOrder' not in already_processed:
            already_processed.add('maximumOrder')
            try:
                self.maximumOrder = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.maximumOrder)    # validate type INT-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class NonseasonalFactor


class RegressorValues(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, TimeSeries=None, TrendCoefficients=None, TransferFunctionValues=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.TimeSeries = TimeSeries
        self.TrendCoefficients = TrendCoefficients
        self.TransferFunctionValues = TransferFunctionValues
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegressorValues)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegressorValues.subclass:
            return RegressorValues.subclass(*args_, **kwargs_)
        else:
            return RegressorValues(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_TimeSeries(self): return self.TimeSeries
    def set_TimeSeries(self, TimeSeries): self.TimeSeries = TimeSeries
    def get_TrendCoefficients(self): return self.TrendCoefficients
    def set_TrendCoefficients(self, TrendCoefficients): self.TrendCoefficients = TrendCoefficients
    def get_TransferFunctionValues(self): return self.TransferFunctionValues
    def set_TransferFunctionValues(self, TransferFunctionValues): self.TransferFunctionValues = TransferFunctionValues
    def hasContent_(self):
        if (
            self.Extension or
            self.TimeSeries is not None or
            self.TrendCoefficients is not None or
            self.TransferFunctionValues is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RegressorValues', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RegressorValues')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegressorValues')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RegressorValues', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegressorValues'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RegressorValues', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.TimeSeries is not None:
            self.TimeSeries.export(outfile, level, namespace_, name_='TimeSeries', pretty_print=pretty_print)
        if self.TrendCoefficients is not None:
            self.TrendCoefficients.export(outfile, level, namespace_, name_='TrendCoefficients', pretty_print=pretty_print)
        if self.TransferFunctionValues is not None:
            self.TransferFunctionValues.export(outfile, level, namespace_, name_='TransferFunctionValues', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='RegressorValues', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.TimeSeries is not None:
            TimeSeries_ = self.TimeSeries
            TimeSeries_.to_etree(element, name_='TimeSeries', mapping_=mapping_)
        if self.TrendCoefficients is not None:
            TrendCoefficients_ = self.TrendCoefficients
            TrendCoefficients_.to_etree(element, name_='TrendCoefficients', mapping_=mapping_)
        if self.TransferFunctionValues is not None:
            TransferFunctionValues_ = self.TransferFunctionValues
            TransferFunctionValues_.to_etree(element, name_='TransferFunctionValues', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='RegressorValues'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.TimeSeries is not None:
            showIndent(outfile, level)
            outfile.write('TimeSeries=model_.TimeSeries(\n')
            self.TimeSeries.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TrendCoefficients is not None:
            showIndent(outfile, level)
            outfile.write('TrendCoefficients=model_.TrendCoefficients(\n')
            self.TrendCoefficients.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TransferFunctionValues is not None:
            showIndent(outfile, level)
            outfile.write('TransferFunctionValues=model_.TransferFunctionValues(\n')
            self.TransferFunctionValues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TimeSeries':
            obj_ = TimeSeries.factory()
            obj_.build(child_)
            self.TimeSeries = obj_
            obj_.original_tagname_ = 'TimeSeries'
        elif nodeName_ == 'TrendCoefficients':
            obj_ = TrendCoefficients.factory()
            obj_.build(child_)
            self.TrendCoefficients = obj_
            obj_.original_tagname_ = 'TrendCoefficients'
        elif nodeName_ == 'TransferFunctionValues':
            obj_ = TransferFunctionValues.factory()
            obj_.build(child_)
            self.TransferFunctionValues = obj_
            obj_.original_tagname_ = 'TransferFunctionValues'
# end class RegressorValues


class TrendCoefficients(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, REAL_SparseArray=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.REAL_SparseArray = REAL_SparseArray
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrendCoefficients)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrendCoefficients.subclass:
            return TrendCoefficients.subclass(*args_, **kwargs_)
        else:
            return TrendCoefficients(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_REAL_SparseArray(self): return self.REAL_SparseArray
    def set_REAL_SparseArray(self, REAL_SparseArray): self.REAL_SparseArray = REAL_SparseArray
    def hasContent_(self):
        if (
            self.Extension or
            self.REAL_SparseArray is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TrendCoefficients', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrendCoefficients')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrendCoefficients')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TrendCoefficients', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TrendCoefficients'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TrendCoefficients', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.REAL_SparseArray is not None:
            self.REAL_SparseArray.export(outfile, level, namespace_, name_='REAL-SparseArray', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TrendCoefficients', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.REAL_SparseArray is not None:
            REAL_SparseArray_ = self.REAL_SparseArray
            REAL_SparseArray_.to_etree(element, name_='REAL-SparseArray', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TrendCoefficients'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.REAL_SparseArray is not None:
            showIndent(outfile, level)
            outfile.write('REAL_SparseArray=model_.REAL_SparseArray(\n')
            self.REAL_SparseArray.exportLiteral(outfile, level, name_='REAL_SparseArray')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'REAL-SparseArray':
            obj_ = REAL_SparseArray.factory()
            obj_.build(child_)
            self.REAL_SparseArray = obj_
            obj_.original_tagname_ = 'REAL-SparseArray'
# end class TrendCoefficients


class TransferFunctionValues(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Array=None):
        self.original_tagname_ = None
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransferFunctionValues)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransferFunctionValues.subclass:
            return TransferFunctionValues.subclass(*args_, **kwargs_)
        else:
            return TransferFunctionValues(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TransferFunctionValues', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransferFunctionValues')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransferFunctionValues')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TransferFunctionValues', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransferFunctionValues'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TransferFunctionValues', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TransferFunctionValues', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TransferFunctionValues'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class TransferFunctionValues


class MaximumLikelihoodStat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, method=None, periodDeficit='0', KalmanState=None, ThetaRecursionState=None):
        self.original_tagname_ = None
        self.method = _cast(None, method)
        self.periodDeficit = _cast(None, periodDeficit)
        self.KalmanState = KalmanState
        self.ThetaRecursionState = ThetaRecursionState
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MaximumLikelihoodStat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MaximumLikelihoodStat.subclass:
            return MaximumLikelihoodStat.subclass(*args_, **kwargs_)
        else:
            return MaximumLikelihoodStat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KalmanState(self): return self.KalmanState
    def set_KalmanState(self, KalmanState): self.KalmanState = KalmanState
    def get_ThetaRecursionState(self): return self.ThetaRecursionState
    def set_ThetaRecursionState(self, ThetaRecursionState): self.ThetaRecursionState = ThetaRecursionState
    def get_method(self): return self.method
    def set_method(self, method): self.method = method
    def get_periodDeficit(self): return self.periodDeficit
    def set_periodDeficit(self, periodDeficit): self.periodDeficit = periodDeficit
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.KalmanState is not None or
            self.ThetaRecursionState is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MaximumLikelihoodStat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MaximumLikelihoodStat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MaximumLikelihoodStat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MaximumLikelihoodStat', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MaximumLikelihoodStat'):
        if self.method is not None and 'method' not in already_processed:
            already_processed.add('method')
            outfile.write(' method=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.method), input_name='method')), ))
        if self.periodDeficit != 0 and 'periodDeficit' not in already_processed:
            already_processed.add('periodDeficit')
            outfile.write(' periodDeficit=%s' % (quote_attrib(self.periodDeficit), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MaximumLikelihoodStat', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.KalmanState is not None:
            self.KalmanState.export(outfile, level, namespace_, name_='KalmanState', pretty_print=pretty_print)
        if self.ThetaRecursionState is not None:
            self.ThetaRecursionState.export(outfile, level, namespace_, name_='ThetaRecursionState', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MaximumLikelihoodStat', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.method is not None:
            element.set('method', self.gds_format_string(self.method))
        if self.periodDeficit is not None:
            element.set('periodDeficit', self.periodDeficit)
        if self.KalmanState is not None:
            KalmanState_ = self.KalmanState
            KalmanState_.to_etree(element, name_='KalmanState', mapping_=mapping_)
        if self.ThetaRecursionState is not None:
            ThetaRecursionState_ = self.ThetaRecursionState
            ThetaRecursionState_.to_etree(element, name_='ThetaRecursionState', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MaximumLikelihoodStat'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.method is not None and 'method' not in already_processed:
            already_processed.add('method')
            showIndent(outfile, level)
            outfile.write('method="%s",\n' % (self.method,))
        if self.periodDeficit is not None and 'periodDeficit' not in already_processed:
            already_processed.add('periodDeficit')
            showIndent(outfile, level)
            outfile.write('periodDeficit=%d,\n' % (self.periodDeficit,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.KalmanState is not None:
            showIndent(outfile, level)
            outfile.write('KalmanState=model_.KalmanState(\n')
            self.KalmanState.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ThetaRecursionState is not None:
            showIndent(outfile, level)
            outfile.write('ThetaRecursionState=model_.ThetaRecursionState(\n')
            self.ThetaRecursionState.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('method', node)
        if value is not None and 'method' not in already_processed:
            already_processed.add('method')
            self.method = value
        value = find_attr_value_('periodDeficit', node)
        if value is not None and 'periodDeficit' not in already_processed:
            already_processed.add('periodDeficit')
            try:
                self.periodDeficit = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.periodDeficit)    # validate type INT-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KalmanState':
            obj_ = KalmanState.factory()
            obj_.build(child_)
            self.KalmanState = obj_
            obj_.original_tagname_ = 'KalmanState'
        elif nodeName_ == 'ThetaRecursionState':
            obj_ = ThetaRecursionState.factory()
            obj_.build(child_)
            self.ThetaRecursionState = obj_
            obj_.original_tagname_ = 'ThetaRecursionState'
# end class MaximumLikelihoodStat


class KalmanState(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FinalOmega=None, FinalStateVector=None, HVector=None):
        self.original_tagname_ = None
        self.FinalOmega = FinalOmega
        self.FinalStateVector = FinalStateVector
        self.HVector = HVector
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KalmanState)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KalmanState.subclass:
            return KalmanState.subclass(*args_, **kwargs_)
        else:
            return KalmanState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FinalOmega(self): return self.FinalOmega
    def set_FinalOmega(self, FinalOmega): self.FinalOmega = FinalOmega
    def get_FinalStateVector(self): return self.FinalStateVector
    def set_FinalStateVector(self, FinalStateVector): self.FinalStateVector = FinalStateVector
    def get_HVector(self): return self.HVector
    def set_HVector(self, HVector): self.HVector = HVector
    def hasContent_(self):
        if (
            self.FinalOmega is not None or
            self.FinalStateVector is not None or
            self.HVector is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KalmanState', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KalmanState')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KalmanState')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KalmanState', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KalmanState'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KalmanState', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FinalOmega is not None:
            self.FinalOmega.export(outfile, level, namespace_, name_='FinalOmega', pretty_print=pretty_print)
        if self.FinalStateVector is not None:
            self.FinalStateVector.export(outfile, level, namespace_, name_='FinalStateVector', pretty_print=pretty_print)
        if self.HVector is not None:
            self.HVector.export(outfile, level, namespace_, name_='HVector', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='KalmanState', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.FinalOmega is not None:
            FinalOmega_ = self.FinalOmega
            FinalOmega_.to_etree(element, name_='FinalOmega', mapping_=mapping_)
        if self.FinalStateVector is not None:
            FinalStateVector_ = self.FinalStateVector
            FinalStateVector_.to_etree(element, name_='FinalStateVector', mapping_=mapping_)
        if self.HVector is not None:
            HVector_ = self.HVector
            HVector_.to_etree(element, name_='HVector', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='KalmanState'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FinalOmega is not None:
            showIndent(outfile, level)
            outfile.write('FinalOmega=model_.FinalOmega(\n')
            self.FinalOmega.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FinalStateVector is not None:
            showIndent(outfile, level)
            outfile.write('FinalStateVector=model_.FinalStateVector(\n')
            self.FinalStateVector.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HVector is not None:
            showIndent(outfile, level)
            outfile.write('HVector=model_.HVector(\n')
            self.HVector.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FinalOmega':
            obj_ = FinalOmega.factory()
            obj_.build(child_)
            self.FinalOmega = obj_
            obj_.original_tagname_ = 'FinalOmega'
        elif nodeName_ == 'FinalStateVector':
            obj_ = FinalStateVector.factory()
            obj_.build(child_)
            self.FinalStateVector = obj_
            obj_.original_tagname_ = 'FinalStateVector'
        elif nodeName_ == 'HVector':
            obj_ = HVector.factory()
            obj_.build(child_)
            self.HVector = obj_
            obj_.original_tagname_ = 'HVector'
# end class KalmanState


class FinalOmega(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Matrix=None):
        self.original_tagname_ = None
        self.Matrix = Matrix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FinalOmega)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FinalOmega.subclass:
            return FinalOmega.subclass(*args_, **kwargs_)
        else:
            return FinalOmega(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Matrix(self): return self.Matrix
    def set_Matrix(self, Matrix): self.Matrix = Matrix
    def hasContent_(self):
        if (
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FinalOmega', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FinalOmega')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinalOmega')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FinalOmega', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FinalOmega'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FinalOmega', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Matrix is not None:
            self.Matrix.export(outfile, level, namespace_, name_='Matrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='FinalOmega', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.Matrix is not None:
            Matrix_ = self.Matrix
            Matrix_.to_etree(element, name_='Matrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FinalOmega'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Matrix is not None:
            showIndent(outfile, level)
            outfile.write('Matrix=model_.Matrix(\n')
            self.Matrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Matrix':
            obj_ = Matrix.factory()
            obj_.build(child_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class FinalOmega


class FinalStateVector(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Array=None):
        self.original_tagname_ = None
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FinalStateVector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FinalStateVector.subclass:
            return FinalStateVector.subclass(*args_, **kwargs_)
        else:
            return FinalStateVector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FinalStateVector', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FinalStateVector')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinalStateVector')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FinalStateVector', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FinalStateVector'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FinalStateVector', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='FinalStateVector', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FinalStateVector'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class FinalStateVector


class HVector(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Array=None):
        self.original_tagname_ = None
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HVector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HVector.subclass:
            return HVector.subclass(*args_, **kwargs_)
        else:
            return HVector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HVector', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HVector')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HVector')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HVector', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HVector'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HVector', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='HVector', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='HVector'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class HVector


class ThetaRecursionState(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FinalNoise=None, FinalPredictedNoise=None, FinalTheta=None, FinalNu=None):
        self.original_tagname_ = None
        self.FinalNoise = FinalNoise
        self.FinalPredictedNoise = FinalPredictedNoise
        self.FinalTheta = FinalTheta
        self.FinalNu = FinalNu
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThetaRecursionState)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThetaRecursionState.subclass:
            return ThetaRecursionState.subclass(*args_, **kwargs_)
        else:
            return ThetaRecursionState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FinalNoise(self): return self.FinalNoise
    def set_FinalNoise(self, FinalNoise): self.FinalNoise = FinalNoise
    def get_FinalPredictedNoise(self): return self.FinalPredictedNoise
    def set_FinalPredictedNoise(self, FinalPredictedNoise): self.FinalPredictedNoise = FinalPredictedNoise
    def get_FinalTheta(self): return self.FinalTheta
    def set_FinalTheta(self, FinalTheta): self.FinalTheta = FinalTheta
    def get_FinalNu(self): return self.FinalNu
    def set_FinalNu(self, FinalNu): self.FinalNu = FinalNu
    def hasContent_(self):
        if (
            self.FinalNoise is not None or
            self.FinalPredictedNoise is not None or
            self.FinalTheta is not None or
            self.FinalNu is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ThetaRecursionState', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ThetaRecursionState')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThetaRecursionState')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ThetaRecursionState', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ThetaRecursionState'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ThetaRecursionState', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FinalNoise is not None:
            self.FinalNoise.export(outfile, level, namespace_, name_='FinalNoise', pretty_print=pretty_print)
        if self.FinalPredictedNoise is not None:
            self.FinalPredictedNoise.export(outfile, level, namespace_, name_='FinalPredictedNoise', pretty_print=pretty_print)
        if self.FinalTheta is not None:
            self.FinalTheta.export(outfile, level, namespace_, name_='FinalTheta', pretty_print=pretty_print)
        if self.FinalNu is not None:
            self.FinalNu.export(outfile, level, namespace_, name_='FinalNu', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ThetaRecursionState', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.FinalNoise is not None:
            FinalNoise_ = self.FinalNoise
            FinalNoise_.to_etree(element, name_='FinalNoise', mapping_=mapping_)
        if self.FinalPredictedNoise is not None:
            FinalPredictedNoise_ = self.FinalPredictedNoise
            FinalPredictedNoise_.to_etree(element, name_='FinalPredictedNoise', mapping_=mapping_)
        if self.FinalTheta is not None:
            FinalTheta_ = self.FinalTheta
            FinalTheta_.to_etree(element, name_='FinalTheta', mapping_=mapping_)
        if self.FinalNu is not None:
            FinalNu_ = self.FinalNu
            FinalNu_.to_etree(element, name_='FinalNu', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ThetaRecursionState'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FinalNoise is not None:
            showIndent(outfile, level)
            outfile.write('FinalNoise=model_.FinalNoise(\n')
            self.FinalNoise.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FinalPredictedNoise is not None:
            showIndent(outfile, level)
            outfile.write('FinalPredictedNoise=model_.FinalPredictedNoise(\n')
            self.FinalPredictedNoise.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FinalTheta is not None:
            showIndent(outfile, level)
            outfile.write('FinalTheta=model_.FinalTheta(\n')
            self.FinalTheta.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FinalNu is not None:
            showIndent(outfile, level)
            outfile.write('FinalNu=model_.FinalNu(\n')
            self.FinalNu.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FinalNoise':
            obj_ = FinalNoise.factory()
            obj_.build(child_)
            self.FinalNoise = obj_
            obj_.original_tagname_ = 'FinalNoise'
        elif nodeName_ == 'FinalPredictedNoise':
            obj_ = FinalPredictedNoise.factory()
            obj_.build(child_)
            self.FinalPredictedNoise = obj_
            obj_.original_tagname_ = 'FinalPredictedNoise'
        elif nodeName_ == 'FinalTheta':
            obj_ = FinalTheta.factory()
            obj_.build(child_)
            self.FinalTheta = obj_
            obj_.original_tagname_ = 'FinalTheta'
        elif nodeName_ == 'FinalNu':
            obj_ = FinalNu.factory()
            obj_.build(child_)
            self.FinalNu = obj_
            obj_.original_tagname_ = 'FinalNu'
# end class ThetaRecursionState


class FinalNoise(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Array=None):
        self.original_tagname_ = None
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FinalNoise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FinalNoise.subclass:
            return FinalNoise.subclass(*args_, **kwargs_)
        else:
            return FinalNoise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FinalNoise', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FinalNoise')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinalNoise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FinalNoise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FinalNoise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FinalNoise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='FinalNoise', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FinalNoise'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class FinalNoise


class FinalPredictedNoise(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Array=None):
        self.original_tagname_ = None
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FinalPredictedNoise)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FinalPredictedNoise.subclass:
            return FinalPredictedNoise.subclass(*args_, **kwargs_)
        else:
            return FinalPredictedNoise(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FinalPredictedNoise', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FinalPredictedNoise')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinalPredictedNoise')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FinalPredictedNoise', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FinalPredictedNoise'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FinalPredictedNoise', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='FinalPredictedNoise', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FinalPredictedNoise'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class FinalPredictedNoise


class FinalTheta(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Theta=None):
        self.original_tagname_ = None
        if Theta is None:
            self.Theta = []
        else:
            self.Theta = Theta
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FinalTheta)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FinalTheta.subclass:
            return FinalTheta.subclass(*args_, **kwargs_)
        else:
            return FinalTheta(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Theta(self): return self.Theta
    def set_Theta(self, Theta): self.Theta = Theta
    def add_Theta(self, value): self.Theta.append(value)
    def insert_Theta_at(self, index, value): self.Theta.insert(index, value)
    def replace_Theta_at(self, index, value): self.Theta[index] = value
    def hasContent_(self):
        if (
            self.Theta
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FinalTheta', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FinalTheta')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinalTheta')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FinalTheta', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FinalTheta'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FinalTheta', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Theta_ in self.Theta:
            Theta_.export(outfile, level, namespace_, name_='Theta', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='FinalTheta', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Theta_ in self.Theta:
            Theta_.to_etree(element, name_='Theta', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FinalTheta'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Theta=[\n')
        level += 1
        for Theta_ in self.Theta:
            showIndent(outfile, level)
            outfile.write('model_.Theta(\n')
            Theta_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Theta':
            obj_ = Theta.factory()
            obj_.build(child_)
            self.Theta.append(obj_)
            obj_.original_tagname_ = 'Theta'
# end class FinalTheta


class Theta(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, i=None, j=None, theta=None):
        self.original_tagname_ = None
        self.i = _cast(None, i)
        self.j = _cast(None, j)
        self.theta = _cast(float, theta)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Theta)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Theta.subclass:
            return Theta.subclass(*args_, **kwargs_)
        else:
            return Theta(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_i(self): return self.i
    def set_i(self, i): self.i = i
    def get_j(self): return self.j
    def set_j(self, j): self.j = j
    def get_theta(self): return self.theta
    def set_theta(self, theta): self.theta = theta
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Theta', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Theta')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Theta')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Theta', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Theta'):
        if self.i is not None and 'i' not in already_processed:
            already_processed.add('i')
            outfile.write(' i=%s' % (quote_attrib(self.i), ))
        if self.j is not None and 'j' not in already_processed:
            already_processed.add('j')
            outfile.write(' j=%s' % (quote_attrib(self.j), ))
        if self.theta is not None and 'theta' not in already_processed:
            already_processed.add('theta')
            outfile.write(' theta="%s"' % self.gds_format_double(self.theta, input_name='theta'))
    def exportChildren(self, outfile, level, namespace_='', name_='Theta', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='Theta', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.i is not None:
            element.set('i', self.i)
        if self.j is not None:
            element.set('j', self.j)
        if self.theta is not None:
            element.set('theta', self.gds_format_double(self.theta))
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Theta'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.i is not None and 'i' not in already_processed:
            already_processed.add('i')
            showIndent(outfile, level)
            outfile.write('i=%d,\n' % (self.i,))
        if self.j is not None and 'j' not in already_processed:
            already_processed.add('j')
            showIndent(outfile, level)
            outfile.write('j=%d,\n' % (self.j,))
        if self.theta is not None and 'theta' not in already_processed:
            already_processed.add('theta')
            showIndent(outfile, level)
            outfile.write('theta=%e,\n' % (self.theta,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('i', node)
        if value is not None and 'i' not in already_processed:
            already_processed.add('i')
            try:
                self.i = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.i)    # validate type INT-NUMBER
        value = find_attr_value_('j', node)
        if value is not None and 'j' not in already_processed:
            already_processed.add('j')
            try:
                self.j = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.j)    # validate type INT-NUMBER
        value = find_attr_value_('theta', node)
        if value is not None and 'theta' not in already_processed:
            already_processed.add('theta')
            try:
                self.theta = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (theta): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Theta


class FinalNu(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Array=None):
        self.original_tagname_ = None
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FinalNu)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FinalNu.subclass:
            return FinalNu.subclass(*args_, **kwargs_)
        else:
            return FinalNu(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FinalNu', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FinalNu')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FinalNu')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FinalNu', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FinalNu'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FinalNu', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='FinalNu', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FinalNu'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class FinalNu


class OutlierEffect(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, startTime=None, magnitude=None, dampingCoefficient=None, Extension=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.startTime = _cast(None, startTime)
        self.magnitude = _cast(None, magnitude)
        self.dampingCoefficient = _cast(None, dampingCoefficient)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutlierEffect)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutlierEffect.subclass:
            return OutlierEffect.subclass(*args_, **kwargs_)
        else:
            return OutlierEffect(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def get_magnitude(self): return self.magnitude
    def set_magnitude(self, magnitude): self.magnitude = magnitude
    def get_dampingCoefficient(self): return self.dampingCoefficient
    def set_dampingCoefficient(self, dampingCoefficient): self.dampingCoefficient = dampingCoefficient
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OutlierEffect', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OutlierEffect')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OutlierEffect')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OutlierEffect', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OutlierEffect'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            outfile.write(' startTime=%s' % (quote_attrib(self.startTime), ))
        if self.magnitude is not None and 'magnitude' not in already_processed:
            already_processed.add('magnitude')
            outfile.write(' magnitude=%s' % (quote_attrib(self.magnitude), ))
        if self.dampingCoefficient is not None and 'dampingCoefficient' not in already_processed:
            already_processed.add('dampingCoefficient')
            outfile.write(' dampingCoefficient=%s' % (quote_attrib(self.dampingCoefficient), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OutlierEffect', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='OutlierEffect', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.startTime is not None:
            element.set('startTime', self.startTime)
        if self.magnitude is not None:
            element.set('magnitude', self.magnitude)
        if self.dampingCoefficient is not None:
            element.set('dampingCoefficient', self.dampingCoefficient)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='OutlierEffect'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            showIndent(outfile, level)
            outfile.write('startTime=%e,\n' % (self.startTime,))
        if self.magnitude is not None and 'magnitude' not in already_processed:
            already_processed.add('magnitude')
            showIndent(outfile, level)
            outfile.write('magnitude=%e,\n' % (self.magnitude,))
        if self.dampingCoefficient is not None and 'dampingCoefficient' not in already_processed:
            already_processed.add('dampingCoefficient')
            showIndent(outfile, level)
            outfile.write('dampingCoefficient=%e,\n' % (self.dampingCoefficient,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('startTime', node)
        if value is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            try:
                self.startTime = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (startTime): %s' % exp)
            self.validate_REAL_NUMBER(self.startTime)    # validate type REAL-NUMBER
        value = find_attr_value_('magnitude', node)
        if value is not None and 'magnitude' not in already_processed:
            already_processed.add('magnitude')
            try:
                self.magnitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (magnitude): %s' % exp)
            self.validate_REAL_NUMBER(self.magnitude)    # validate type REAL-NUMBER
        value = find_attr_value_('dampingCoefficient', node)
        if value is not None and 'dampingCoefficient' not in already_processed:
            already_processed.add('dampingCoefficient')
            try:
                self.dampingCoefficient = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (dampingCoefficient): %s' % exp)
            self.validate_REAL_NUMBER(self.dampingCoefficient)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class OutlierEffect


class GARCH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, ARMAPart=None, GARCHPart=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.ARMAPart = ARMAPart
        self.GARCHPart = GARCHPart
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GARCH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GARCH.subclass:
            return GARCH.subclass(*args_, **kwargs_)
        else:
            return GARCH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_ARMAPart(self): return self.ARMAPart
    def set_ARMAPart(self, ARMAPart): self.ARMAPart = ARMAPart
    def get_GARCHPart(self): return self.GARCHPart
    def set_GARCHPart(self, GARCHPart): self.GARCHPart = GARCHPart
    def hasContent_(self):
        if (
            self.Extension or
            self.ARMAPart is not None or
            self.GARCHPart is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GARCH', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GARCH')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GARCH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GARCH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GARCH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GARCH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.ARMAPart is not None:
            self.ARMAPart.export(outfile, level, namespace_, name_='ARMAPart', pretty_print=pretty_print)
        if self.GARCHPart is not None:
            self.GARCHPart.export(outfile, level, namespace_, name_='GARCHPart', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GARCH', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.ARMAPart is not None:
            ARMAPart_ = self.ARMAPart
            ARMAPart_.to_etree(element, name_='ARMAPart', mapping_=mapping_)
        if self.GARCHPart is not None:
            GARCHPart_ = self.GARCHPart
            GARCHPart_.to_etree(element, name_='GARCHPart', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='GARCH'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ARMAPart is not None:
            showIndent(outfile, level)
            outfile.write('ARMAPart=model_.ARMAPart(\n')
            self.ARMAPart.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GARCHPart is not None:
            showIndent(outfile, level)
            outfile.write('GARCHPart=model_.GARCHPart(\n')
            self.GARCHPart.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ARMAPart':
            obj_ = ARMAPart.factory()
            obj_.build(child_)
            self.ARMAPart = obj_
            obj_.original_tagname_ = 'ARMAPart'
        elif nodeName_ == 'GARCHPart':
            obj_ = GARCHPart.factory()
            obj_.build(child_)
            self.GARCHPart = obj_
            obj_.original_tagname_ = 'GARCHPart'
# end class GARCH


class ARMAPart(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, constant='0', p=None, q=None, Extension=None, AR=None, MA=None):
        self.original_tagname_ = None
        self.constant = _cast(None, constant)
        self.p = _cast(None, p)
        self.q = _cast(None, q)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.AR = AR
        self.MA = MA
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ARMAPart)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ARMAPart.subclass:
            return ARMAPart.subclass(*args_, **kwargs_)
        else:
            return ARMAPart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_AR(self): return self.AR
    def set_AR(self, AR): self.AR = AR
    def get_MA(self): return self.MA
    def set_MA(self, MA): self.MA = MA
    def get_constant(self): return self.constant
    def set_constant(self, constant): self.constant = constant
    def get_p(self): return self.p
    def set_p(self, p): self.p = p
    def get_q(self): return self.q
    def set_q(self, q): self.q = q
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.AR is not None or
            self.MA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ARMAPart', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ARMAPart')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ARMAPart')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ARMAPart', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ARMAPart'):
        if self.constant != 0 and 'constant' not in already_processed:
            already_processed.add('constant')
            outfile.write(' constant=%s' % (quote_attrib(self.constant), ))
        if self.p is not None and 'p' not in already_processed:
            already_processed.add('p')
            outfile.write(' p=%s' % (quote_attrib(self.p), ))
        if self.q is not None and 'q' not in already_processed:
            already_processed.add('q')
            outfile.write(' q=%s' % (quote_attrib(self.q), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ARMAPart', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.AR is not None:
            self.AR.export(outfile, level, namespace_, name_='AR', pretty_print=pretty_print)
        if self.MA is not None:
            self.MA.export(outfile, level, namespace_, name_='MA', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ARMAPart', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.constant is not None:
            element.set('constant', self.constant)
        if self.p is not None:
            element.set('p', self.p)
        if self.q is not None:
            element.set('q', self.q)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.AR is not None:
            AR_ = self.AR
            AR_.to_etree(element, name_='AR', mapping_=mapping_)
        if self.MA is not None:
            MA_ = self.MA
            MA_.to_etree(element, name_='MA', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ARMAPart'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.constant is not None and 'constant' not in already_processed:
            already_processed.add('constant')
            showIndent(outfile, level)
            outfile.write('constant=%e,\n' % (self.constant,))
        if self.p is not None and 'p' not in already_processed:
            already_processed.add('p')
            showIndent(outfile, level)
            outfile.write('p=%d,\n' % (self.p,))
        if self.q is not None and 'q' not in already_processed:
            already_processed.add('q')
            showIndent(outfile, level)
            outfile.write('q=%d,\n' % (self.q,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.AR is not None:
            showIndent(outfile, level)
            outfile.write('AR=model_.AR(\n')
            self.AR.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MA is not None:
            showIndent(outfile, level)
            outfile.write('MA=model_.MA(\n')
            self.MA.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('constant', node)
        if value is not None and 'constant' not in already_processed:
            already_processed.add('constant')
            try:
                self.constant = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (constant): %s' % exp)
            self.validate_REAL_NUMBER(self.constant)    # validate type REAL-NUMBER
        value = find_attr_value_('p', node)
        if value is not None and 'p' not in already_processed:
            already_processed.add('p')
            try:
                self.p = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.p)    # validate type INT-NUMBER
        value = find_attr_value_('q', node)
        if value is not None and 'q' not in already_processed:
            already_processed.add('q')
            try:
                self.q = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.q)    # validate type INT-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'AR':
            obj_ = AR.factory()
            obj_.build(child_)
            self.AR = obj_
            obj_.original_tagname_ = 'AR'
        elif nodeName_ == 'MA':
            obj_ = MA.factory()
            obj_.build(child_)
            self.MA = obj_
            obj_.original_tagname_ = 'MA'
# end class ARMAPart


class GARCHPart(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, constant='0', gp=None, gq=None, Extension=None, ResidualSquareCoefficients=None, VarianceCoefficients=None):
        self.original_tagname_ = None
        self.constant = _cast(None, constant)
        self.gp = _cast(None, gp)
        self.gq = _cast(None, gq)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.ResidualSquareCoefficients = ResidualSquareCoefficients
        self.VarianceCoefficients = VarianceCoefficients
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GARCHPart)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GARCHPart.subclass:
            return GARCHPart.subclass(*args_, **kwargs_)
        else:
            return GARCHPart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_ResidualSquareCoefficients(self): return self.ResidualSquareCoefficients
    def set_ResidualSquareCoefficients(self, ResidualSquareCoefficients): self.ResidualSquareCoefficients = ResidualSquareCoefficients
    def get_VarianceCoefficients(self): return self.VarianceCoefficients
    def set_VarianceCoefficients(self, VarianceCoefficients): self.VarianceCoefficients = VarianceCoefficients
    def get_constant(self): return self.constant
    def set_constant(self, constant): self.constant = constant
    def get_gp(self): return self.gp
    def set_gp(self, gp): self.gp = gp
    def get_gq(self): return self.gq
    def set_gq(self, gq): self.gq = gq
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.ResidualSquareCoefficients is not None or
            self.VarianceCoefficients is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GARCHPart', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GARCHPart')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GARCHPart')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GARCHPart', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GARCHPart'):
        if self.constant != 0 and 'constant' not in already_processed:
            already_processed.add('constant')
            outfile.write(' constant=%s' % (quote_attrib(self.constant), ))
        if self.gp is not None and 'gp' not in already_processed:
            already_processed.add('gp')
            outfile.write(' gp=%s' % (quote_attrib(self.gp), ))
        if self.gq is not None and 'gq' not in already_processed:
            already_processed.add('gq')
            outfile.write(' gq=%s' % (quote_attrib(self.gq), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GARCHPart', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.ResidualSquareCoefficients is not None:
            self.ResidualSquareCoefficients.export(outfile, level, namespace_, name_='ResidualSquareCoefficients', pretty_print=pretty_print)
        if self.VarianceCoefficients is not None:
            self.VarianceCoefficients.export(outfile, level, namespace_, name_='VarianceCoefficients', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GARCHPart', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.constant is not None:
            element.set('constant', self.constant)
        if self.gp is not None:
            element.set('gp', self.gp)
        if self.gq is not None:
            element.set('gq', self.gq)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.ResidualSquareCoefficients is not None:
            ResidualSquareCoefficients_ = self.ResidualSquareCoefficients
            ResidualSquareCoefficients_.to_etree(element, name_='ResidualSquareCoefficients', mapping_=mapping_)
        if self.VarianceCoefficients is not None:
            VarianceCoefficients_ = self.VarianceCoefficients
            VarianceCoefficients_.to_etree(element, name_='VarianceCoefficients', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='GARCHPart'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.constant is not None and 'constant' not in already_processed:
            already_processed.add('constant')
            showIndent(outfile, level)
            outfile.write('constant=%e,\n' % (self.constant,))
        if self.gp is not None and 'gp' not in already_processed:
            already_processed.add('gp')
            showIndent(outfile, level)
            outfile.write('gp=%d,\n' % (self.gp,))
        if self.gq is not None and 'gq' not in already_processed:
            already_processed.add('gq')
            showIndent(outfile, level)
            outfile.write('gq=%d,\n' % (self.gq,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ResidualSquareCoefficients is not None:
            showIndent(outfile, level)
            outfile.write('ResidualSquareCoefficients=model_.ResidualSquareCoefficients(\n')
            self.ResidualSquareCoefficients.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VarianceCoefficients is not None:
            showIndent(outfile, level)
            outfile.write('VarianceCoefficients=model_.VarianceCoefficients(\n')
            self.VarianceCoefficients.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('constant', node)
        if value is not None and 'constant' not in already_processed:
            already_processed.add('constant')
            try:
                self.constant = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (constant): %s' % exp)
            self.validate_REAL_NUMBER(self.constant)    # validate type REAL-NUMBER
        value = find_attr_value_('gp', node)
        if value is not None and 'gp' not in already_processed:
            already_processed.add('gp')
            try:
                self.gp = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.gp)    # validate type INT-NUMBER
        value = find_attr_value_('gq', node)
        if value is not None and 'gq' not in already_processed:
            already_processed.add('gq')
            try:
                self.gq = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.gq)    # validate type INT-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ResidualSquareCoefficients':
            obj_ = ResidualSquareCoefficients.factory()
            obj_.build(child_)
            self.ResidualSquareCoefficients = obj_
            obj_.original_tagname_ = 'ResidualSquareCoefficients'
        elif nodeName_ == 'VarianceCoefficients':
            obj_ = VarianceCoefficients.factory()
            obj_.build(child_)
            self.VarianceCoefficients = obj_
            obj_.original_tagname_ = 'VarianceCoefficients'
# end class GARCHPart


class ResidualSquareCoefficients(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Residuals=None, MACoefficients=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Residuals = Residuals
        self.MACoefficients = MACoefficients
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResidualSquareCoefficients)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResidualSquareCoefficients.subclass:
            return ResidualSquareCoefficients.subclass(*args_, **kwargs_)
        else:
            return ResidualSquareCoefficients(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Residuals(self): return self.Residuals
    def set_Residuals(self, Residuals): self.Residuals = Residuals
    def get_MACoefficients(self): return self.MACoefficients
    def set_MACoefficients(self, MACoefficients): self.MACoefficients = MACoefficients
    def hasContent_(self):
        if (
            self.Extension or
            self.Residuals is not None or
            self.MACoefficients is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResidualSquareCoefficients', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResidualSquareCoefficients')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResidualSquareCoefficients')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResidualSquareCoefficients', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResidualSquareCoefficients'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ResidualSquareCoefficients', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Residuals is not None:
            self.Residuals.export(outfile, level, namespace_, name_='Residuals', pretty_print=pretty_print)
        if self.MACoefficients is not None:
            self.MACoefficients.export(outfile, level, namespace_, name_='MACoefficients', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ResidualSquareCoefficients', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Residuals is not None:
            Residuals_ = self.Residuals
            Residuals_.to_etree(element, name_='Residuals', mapping_=mapping_)
        if self.MACoefficients is not None:
            MACoefficients_ = self.MACoefficients
            MACoefficients_.to_etree(element, name_='MACoefficients', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ResidualSquareCoefficients'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Residuals is not None:
            showIndent(outfile, level)
            outfile.write('Residuals=model_.Residuals(\n')
            self.Residuals.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MACoefficients is not None:
            showIndent(outfile, level)
            outfile.write('MACoefficients=model_.MACoefficients(\n')
            self.MACoefficients.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Residuals':
            obj_ = Residuals.factory()
            obj_.build(child_)
            self.Residuals = obj_
            obj_.original_tagname_ = 'Residuals'
        elif nodeName_ == 'MACoefficients':
            obj_ = MACoefficients.factory()
            obj_.build(child_)
            self.MACoefficients = obj_
            obj_.original_tagname_ = 'MACoefficients'
# end class ResidualSquareCoefficients


class VarianceCoefficients(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, PastVariances=None, MACoefficients=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.PastVariances = PastVariances
        self.MACoefficients = MACoefficients
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VarianceCoefficients)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VarianceCoefficients.subclass:
            return VarianceCoefficients.subclass(*args_, **kwargs_)
        else:
            return VarianceCoefficients(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_PastVariances(self): return self.PastVariances
    def set_PastVariances(self, PastVariances): self.PastVariances = PastVariances
    def get_MACoefficients(self): return self.MACoefficients
    def set_MACoefficients(self, MACoefficients): self.MACoefficients = MACoefficients
    def hasContent_(self):
        if (
            self.Extension or
            self.PastVariances is not None or
            self.MACoefficients is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VarianceCoefficients', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VarianceCoefficients')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VarianceCoefficients')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VarianceCoefficients', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VarianceCoefficients'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VarianceCoefficients', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.PastVariances is not None:
            self.PastVariances.export(outfile, level, namespace_, name_='PastVariances', pretty_print=pretty_print)
        if self.MACoefficients is not None:
            self.MACoefficients.export(outfile, level, namespace_, name_='MACoefficients', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='VarianceCoefficients', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.PastVariances is not None:
            PastVariances_ = self.PastVariances
            PastVariances_.to_etree(element, name_='PastVariances', mapping_=mapping_)
        if self.MACoefficients is not None:
            MACoefficients_ = self.MACoefficients
            MACoefficients_.to_etree(element, name_='MACoefficients', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='VarianceCoefficients'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.PastVariances is not None:
            showIndent(outfile, level)
            outfile.write('PastVariances=model_.PastVariances(\n')
            self.PastVariances.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MACoefficients is not None:
            showIndent(outfile, level)
            outfile.write('MACoefficients=model_.MACoefficients(\n')
            self.MACoefficients.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'PastVariances':
            obj_ = PastVariances.factory()
            obj_.build(child_)
            self.PastVariances = obj_
            obj_.original_tagname_ = 'PastVariances'
        elif nodeName_ == 'MACoefficients':
            obj_ = MACoefficients.factory()
            obj_.build(child_)
            self.MACoefficients = obj_
            obj_.original_tagname_ = 'MACoefficients'
# end class VarianceCoefficients


class PastVariances(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PastVariances)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PastVariances.subclass:
            return PastVariances.subclass(*args_, **kwargs_)
        else:
            return PastVariances(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PastVariances', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PastVariances')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PastVariances')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PastVariances', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PastVariances'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PastVariances', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PastVariances', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PastVariances'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class PastVariances


class StateSpaceModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, variance=None, period='none', intercept='0', Extension=None, StateVector=None, TransitionMatrix=None, MeasurementMatrix=None, InterceptVector=None, PredictedStateCovarianceMatrix=None, SelectedStateCovarianceMatrix=None, ObservationVarianceMatrix=None, PsiVector=None, DynamicRegressor=None):
        self.original_tagname_ = None
        self.variance = _cast(None, variance)
        self.period = _cast(None, period)
        self.intercept = _cast(None, intercept)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.StateVector = StateVector
        self.TransitionMatrix = TransitionMatrix
        self.MeasurementMatrix = MeasurementMatrix
        self.InterceptVector = InterceptVector
        self.PredictedStateCovarianceMatrix = PredictedStateCovarianceMatrix
        self.SelectedStateCovarianceMatrix = SelectedStateCovarianceMatrix
        self.ObservationVarianceMatrix = ObservationVarianceMatrix
        self.PsiVector = PsiVector
        if DynamicRegressor is None:
            self.DynamicRegressor = []
        else:
            self.DynamicRegressor = DynamicRegressor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StateSpaceModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StateSpaceModel.subclass:
            return StateSpaceModel.subclass(*args_, **kwargs_)
        else:
            return StateSpaceModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_StateVector(self): return self.StateVector
    def set_StateVector(self, StateVector): self.StateVector = StateVector
    def get_TransitionMatrix(self): return self.TransitionMatrix
    def set_TransitionMatrix(self, TransitionMatrix): self.TransitionMatrix = TransitionMatrix
    def get_MeasurementMatrix(self): return self.MeasurementMatrix
    def set_MeasurementMatrix(self, MeasurementMatrix): self.MeasurementMatrix = MeasurementMatrix
    def get_InterceptVector(self): return self.InterceptVector
    def set_InterceptVector(self, InterceptVector): self.InterceptVector = InterceptVector
    def get_PredictedStateCovarianceMatrix(self): return self.PredictedStateCovarianceMatrix
    def set_PredictedStateCovarianceMatrix(self, PredictedStateCovarianceMatrix): self.PredictedStateCovarianceMatrix = PredictedStateCovarianceMatrix
    def get_SelectedStateCovarianceMatrix(self): return self.SelectedStateCovarianceMatrix
    def set_SelectedStateCovarianceMatrix(self, SelectedStateCovarianceMatrix): self.SelectedStateCovarianceMatrix = SelectedStateCovarianceMatrix
    def get_ObservationVarianceMatrix(self): return self.ObservationVarianceMatrix
    def set_ObservationVarianceMatrix(self, ObservationVarianceMatrix): self.ObservationVarianceMatrix = ObservationVarianceMatrix
    def get_PsiVector(self): return self.PsiVector
    def set_PsiVector(self, PsiVector): self.PsiVector = PsiVector
    def get_DynamicRegressor(self): return self.DynamicRegressor
    def set_DynamicRegressor(self, DynamicRegressor): self.DynamicRegressor = DynamicRegressor
    def add_DynamicRegressor(self, value): self.DynamicRegressor.append(value)
    def insert_DynamicRegressor_at(self, index, value): self.DynamicRegressor.insert(index, value)
    def replace_DynamicRegressor_at(self, index, value): self.DynamicRegressor[index] = value
    def get_variance(self): return self.variance
    def set_variance(self, variance): self.variance = variance
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_intercept(self): return self.intercept
    def set_intercept(self, intercept): self.intercept = intercept
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.StateVector is not None or
            self.TransitionMatrix is not None or
            self.MeasurementMatrix is not None or
            self.InterceptVector is not None or
            self.PredictedStateCovarianceMatrix is not None or
            self.SelectedStateCovarianceMatrix is not None or
            self.ObservationVarianceMatrix is not None or
            self.PsiVector is not None or
            self.DynamicRegressor
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StateSpaceModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StateSpaceModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StateSpaceModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StateSpaceModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StateSpaceModel'):
        if self.variance is not None and 'variance' not in already_processed:
            already_processed.add('variance')
            outfile.write(' variance=%s' % (quote_attrib(self.variance), ))
        if self.period != "none" and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.period), input_name='period')), ))
        if self.intercept != 0 and 'intercept' not in already_processed:
            already_processed.add('intercept')
            outfile.write(' intercept=%s' % (quote_attrib(self.intercept), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StateSpaceModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.StateVector is not None:
            self.StateVector.export(outfile, level, namespace_, name_='StateVector', pretty_print=pretty_print)
        if self.TransitionMatrix is not None:
            self.TransitionMatrix.export(outfile, level, namespace_, name_='TransitionMatrix', pretty_print=pretty_print)
        if self.MeasurementMatrix is not None:
            self.MeasurementMatrix.export(outfile, level, namespace_, name_='MeasurementMatrix', pretty_print=pretty_print)
        if self.InterceptVector is not None:
            self.InterceptVector.export(outfile, level, namespace_, name_='InterceptVector', pretty_print=pretty_print)
        if self.PredictedStateCovarianceMatrix is not None:
            self.PredictedStateCovarianceMatrix.export(outfile, level, namespace_, name_='PredictedStateCovarianceMatrix', pretty_print=pretty_print)
        if self.SelectedStateCovarianceMatrix is not None:
            self.SelectedStateCovarianceMatrix.export(outfile, level, namespace_, name_='SelectedStateCovarianceMatrix', pretty_print=pretty_print)
        if self.ObservationVarianceMatrix is not None:
            self.ObservationVarianceMatrix.export(outfile, level, namespace_, name_='ObservationVarianceMatrix', pretty_print=pretty_print)
        if self.PsiVector is not None:
            self.PsiVector.export(outfile, level, namespace_, name_='PsiVector', pretty_print=pretty_print)
        for DynamicRegressor_ in self.DynamicRegressor:
            DynamicRegressor_.export(outfile, level, namespace_, name_='DynamicRegressor', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='StateSpaceModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.variance is not None:
            element.set('variance', self.variance)
        if self.period is not None:
            element.set('period', self.gds_format_string(self.period))
        if self.intercept is not None:
            element.set('intercept', self.intercept)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.StateVector is not None:
            StateVector_ = self.StateVector
            StateVector_.to_etree(element, name_='StateVector', mapping_=mapping_)
        if self.TransitionMatrix is not None:
            TransitionMatrix_ = self.TransitionMatrix
            TransitionMatrix_.to_etree(element, name_='TransitionMatrix', mapping_=mapping_)
        if self.MeasurementMatrix is not None:
            MeasurementMatrix_ = self.MeasurementMatrix
            MeasurementMatrix_.to_etree(element, name_='MeasurementMatrix', mapping_=mapping_)
        if self.InterceptVector is not None:
            InterceptVector_ = self.InterceptVector
            InterceptVector_.to_etree(element, name_='InterceptVector', mapping_=mapping_)
        if self.PredictedStateCovarianceMatrix is not None:
            PredictedStateCovarianceMatrix_ = self.PredictedStateCovarianceMatrix
            PredictedStateCovarianceMatrix_.to_etree(element, name_='PredictedStateCovarianceMatrix', mapping_=mapping_)
        if self.SelectedStateCovarianceMatrix is not None:
            SelectedStateCovarianceMatrix_ = self.SelectedStateCovarianceMatrix
            SelectedStateCovarianceMatrix_.to_etree(element, name_='SelectedStateCovarianceMatrix', mapping_=mapping_)
        if self.ObservationVarianceMatrix is not None:
            ObservationVarianceMatrix_ = self.ObservationVarianceMatrix
            ObservationVarianceMatrix_.to_etree(element, name_='ObservationVarianceMatrix', mapping_=mapping_)
        if self.PsiVector is not None:
            PsiVector_ = self.PsiVector
            PsiVector_.to_etree(element, name_='PsiVector', mapping_=mapping_)
        for DynamicRegressor_ in self.DynamicRegressor:
            DynamicRegressor_.to_etree(element, name_='DynamicRegressor', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='StateSpaceModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.variance is not None and 'variance' not in already_processed:
            already_processed.add('variance')
            showIndent(outfile, level)
            outfile.write('variance=%e,\n' % (self.variance,))
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            showIndent(outfile, level)
            outfile.write('period="%s",\n' % (self.period,))
        if self.intercept is not None and 'intercept' not in already_processed:
            already_processed.add('intercept')
            showIndent(outfile, level)
            outfile.write('intercept=%e,\n' % (self.intercept,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.StateVector is not None:
            showIndent(outfile, level)
            outfile.write('StateVector=model_.StateVector(\n')
            self.StateVector.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TransitionMatrix is not None:
            showIndent(outfile, level)
            outfile.write('TransitionMatrix=model_.TransitionMatrix(\n')
            self.TransitionMatrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MeasurementMatrix is not None:
            showIndent(outfile, level)
            outfile.write('MeasurementMatrix=model_.MeasurementMatrix(\n')
            self.MeasurementMatrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InterceptVector is not None:
            showIndent(outfile, level)
            outfile.write('InterceptVector=model_.InterceptVector(\n')
            self.InterceptVector.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PredictedStateCovarianceMatrix is not None:
            showIndent(outfile, level)
            outfile.write('PredictedStateCovarianceMatrix=model_.PredictedStateCovarianceMatrix(\n')
            self.PredictedStateCovarianceMatrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SelectedStateCovarianceMatrix is not None:
            showIndent(outfile, level)
            outfile.write('SelectedStateCovarianceMatrix=model_.SelectedStateCovarianceMatrix(\n')
            self.SelectedStateCovarianceMatrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ObservationVarianceMatrix is not None:
            showIndent(outfile, level)
            outfile.write('ObservationVarianceMatrix=model_.ObservationVarianceMatrix(\n')
            self.ObservationVarianceMatrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PsiVector is not None:
            showIndent(outfile, level)
            outfile.write('PsiVector=model_.PsiVector(\n')
            self.PsiVector.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('DynamicRegressor=[\n')
        level += 1
        for DynamicRegressor_ in self.DynamicRegressor:
            showIndent(outfile, level)
            outfile.write('model_.DynamicRegressor(\n')
            DynamicRegressor_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('variance', node)
        if value is not None and 'variance' not in already_processed:
            already_processed.add('variance')
            try:
                self.variance = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (variance): %s' % exp)
            self.validate_REAL_NUMBER(self.variance)    # validate type REAL-NUMBER
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            self.period = value
        value = find_attr_value_('intercept', node)
        if value is not None and 'intercept' not in already_processed:
            already_processed.add('intercept')
            try:
                self.intercept = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (intercept): %s' % exp)
            self.validate_REAL_NUMBER(self.intercept)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'StateVector':
            obj_ = StateVector.factory()
            obj_.build(child_)
            self.StateVector = obj_
            obj_.original_tagname_ = 'StateVector'
        elif nodeName_ == 'TransitionMatrix':
            obj_ = TransitionMatrix.factory()
            obj_.build(child_)
            self.TransitionMatrix = obj_
            obj_.original_tagname_ = 'TransitionMatrix'
        elif nodeName_ == 'MeasurementMatrix':
            obj_ = MeasurementMatrix.factory()
            obj_.build(child_)
            self.MeasurementMatrix = obj_
            obj_.original_tagname_ = 'MeasurementMatrix'
        elif nodeName_ == 'InterceptVector':
            obj_ = InterceptVector.factory()
            obj_.build(child_)
            self.InterceptVector = obj_
            obj_.original_tagname_ = 'InterceptVector'
        elif nodeName_ == 'PredictedStateCovarianceMatrix':
            obj_ = PredictedStateCovarianceMatrix.factory()
            obj_.build(child_)
            self.PredictedStateCovarianceMatrix = obj_
            obj_.original_tagname_ = 'PredictedStateCovarianceMatrix'
        elif nodeName_ == 'SelectedStateCovarianceMatrix':
            obj_ = SelectedStateCovarianceMatrix.factory()
            obj_.build(child_)
            self.SelectedStateCovarianceMatrix = obj_
            obj_.original_tagname_ = 'SelectedStateCovarianceMatrix'
        elif nodeName_ == 'ObservationVarianceMatrix':
            obj_ = ObservationVarianceMatrix.factory()
            obj_.build(child_)
            self.ObservationVarianceMatrix = obj_
            obj_.original_tagname_ = 'ObservationVarianceMatrix'
        elif nodeName_ == 'PsiVector':
            obj_ = PsiVector.factory()
            obj_.build(child_)
            self.PsiVector = obj_
            obj_.original_tagname_ = 'PsiVector'
        elif nodeName_ == 'DynamicRegressor':
            obj_ = DynamicRegressor.factory()
            obj_.build(child_)
            self.DynamicRegressor.append(obj_)
            obj_.original_tagname_ = 'DynamicRegressor'
# end class StateSpaceModel


class StateVector(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StateVector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StateVector.subclass:
            return StateVector.subclass(*args_, **kwargs_)
        else:
            return StateVector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StateVector', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StateVector')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StateVector')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StateVector', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StateVector'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StateVector', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='StateVector', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='StateVector'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class StateVector


class TransitionMatrix(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Matrix=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Matrix = Matrix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransitionMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransitionMatrix.subclass:
            return TransitionMatrix.subclass(*args_, **kwargs_)
        else:
            return TransitionMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Matrix(self): return self.Matrix
    def set_Matrix(self, Matrix): self.Matrix = Matrix
    def hasContent_(self):
        if (
            self.Extension or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TransitionMatrix', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransitionMatrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransitionMatrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TransitionMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransitionMatrix'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TransitionMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Matrix is not None:
            self.Matrix.export(outfile, level, namespace_, name_='Matrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TransitionMatrix', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Matrix is not None:
            Matrix_ = self.Matrix
            Matrix_.to_etree(element, name_='Matrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TransitionMatrix'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Matrix is not None:
            showIndent(outfile, level)
            outfile.write('Matrix=model_.Matrix(\n')
            self.Matrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory()
            obj_.build(child_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class TransitionMatrix


class MeasurementMatrix(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Matrix=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Matrix = Matrix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasurementMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasurementMatrix.subclass:
            return MeasurementMatrix.subclass(*args_, **kwargs_)
        else:
            return MeasurementMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Matrix(self): return self.Matrix
    def set_Matrix(self, Matrix): self.Matrix = Matrix
    def hasContent_(self):
        if (
            self.Extension or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MeasurementMatrix', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasurementMatrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasurementMatrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MeasurementMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeasurementMatrix'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MeasurementMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Matrix is not None:
            self.Matrix.export(outfile, level, namespace_, name_='Matrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MeasurementMatrix', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Matrix is not None:
            Matrix_ = self.Matrix
            Matrix_.to_etree(element, name_='Matrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MeasurementMatrix'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Matrix is not None:
            showIndent(outfile, level)
            outfile.write('Matrix=model_.Matrix(\n')
            self.Matrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory()
            obj_.build(child_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class MeasurementMatrix


class InterceptVector(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_='state', Extension=None, Array=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InterceptVector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InterceptVector.subclass:
            return InterceptVector.subclass(*args_, **kwargs_)
        else:
            return InterceptVector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InterceptVector', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InterceptVector')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterceptVector')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InterceptVector', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InterceptVector'):
        if self.type_ != "state" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InterceptVector', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InterceptVector', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='InterceptVector'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class InterceptVector


class PredictedStateCovarianceMatrix(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Matrix=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Matrix = Matrix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PredictedStateCovarianceMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PredictedStateCovarianceMatrix.subclass:
            return PredictedStateCovarianceMatrix.subclass(*args_, **kwargs_)
        else:
            return PredictedStateCovarianceMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Matrix(self): return self.Matrix
    def set_Matrix(self, Matrix): self.Matrix = Matrix
    def hasContent_(self):
        if (
            self.Extension or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PredictedStateCovarianceMatrix', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PredictedStateCovarianceMatrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PredictedStateCovarianceMatrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PredictedStateCovarianceMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PredictedStateCovarianceMatrix'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PredictedStateCovarianceMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Matrix is not None:
            self.Matrix.export(outfile, level, namespace_, name_='Matrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PredictedStateCovarianceMatrix', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Matrix is not None:
            Matrix_ = self.Matrix
            Matrix_.to_etree(element, name_='Matrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PredictedStateCovarianceMatrix'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Matrix is not None:
            showIndent(outfile, level)
            outfile.write('Matrix=model_.Matrix(\n')
            self.Matrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory()
            obj_.build(child_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class PredictedStateCovarianceMatrix


class SelectedStateCovarianceMatrix(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Matrix=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Matrix = Matrix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SelectedStateCovarianceMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SelectedStateCovarianceMatrix.subclass:
            return SelectedStateCovarianceMatrix.subclass(*args_, **kwargs_)
        else:
            return SelectedStateCovarianceMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Matrix(self): return self.Matrix
    def set_Matrix(self, Matrix): self.Matrix = Matrix
    def hasContent_(self):
        if (
            self.Extension or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SelectedStateCovarianceMatrix', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SelectedStateCovarianceMatrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SelectedStateCovarianceMatrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SelectedStateCovarianceMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SelectedStateCovarianceMatrix'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SelectedStateCovarianceMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Matrix is not None:
            self.Matrix.export(outfile, level, namespace_, name_='Matrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SelectedStateCovarianceMatrix', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Matrix is not None:
            Matrix_ = self.Matrix
            Matrix_.to_etree(element, name_='Matrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SelectedStateCovarianceMatrix'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Matrix is not None:
            showIndent(outfile, level)
            outfile.write('Matrix=model_.Matrix(\n')
            self.Matrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory()
            obj_.build(child_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class SelectedStateCovarianceMatrix


class ObservationVarianceMatrix(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Matrix=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Matrix = Matrix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObservationVarianceMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObservationVarianceMatrix.subclass:
            return ObservationVarianceMatrix.subclass(*args_, **kwargs_)
        else:
            return ObservationVarianceMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Matrix(self): return self.Matrix
    def set_Matrix(self, Matrix): self.Matrix = Matrix
    def hasContent_(self):
        if (
            self.Extension or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObservationVarianceMatrix', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObservationVarianceMatrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObservationVarianceMatrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ObservationVarianceMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObservationVarianceMatrix'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ObservationVarianceMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Matrix is not None:
            self.Matrix.export(outfile, level, namespace_, name_='Matrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ObservationVarianceMatrix', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Matrix is not None:
            Matrix_ = self.Matrix
            Matrix_.to_etree(element, name_='Matrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ObservationVarianceMatrix'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Matrix is not None:
            showIndent(outfile, level)
            outfile.write('Matrix=model_.Matrix(\n')
            self.Matrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory()
            obj_.build(child_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class ObservationVarianceMatrix


class PsiVector(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, targetField=None, variance=None, Extension=None, Array=None):
        self.original_tagname_ = None
        self.targetField = _cast(None, targetField)
        self.variance = _cast(None, variance)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PsiVector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PsiVector.subclass:
            return PsiVector.subclass(*args_, **kwargs_)
        else:
            return PsiVector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def get_targetField(self): return self.targetField
    def set_targetField(self, targetField): self.targetField = targetField
    def get_variance(self): return self.variance
    def set_variance(self, variance): self.variance = variance
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PsiVector', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PsiVector')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PsiVector')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PsiVector', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PsiVector'):
        if self.targetField is not None and 'targetField' not in already_processed:
            already_processed.add('targetField')
            outfile.write(' targetField=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetField), input_name='targetField')), ))
        if self.variance is not None and 'variance' not in already_processed:
            already_processed.add('variance')
            outfile.write(' variance=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.variance), input_name='variance')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PsiVector', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PsiVector', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.targetField is not None:
            element.set('targetField', self.gds_format_string(self.targetField))
        if self.variance is not None:
            element.set('variance', self.gds_format_string(self.variance))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PsiVector'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.targetField is not None and 'targetField' not in already_processed:
            already_processed.add('targetField')
            showIndent(outfile, level)
            outfile.write('targetField="%s",\n' % (self.targetField,))
        if self.variance is not None and 'variance' not in already_processed:
            already_processed.add('variance')
            showIndent(outfile, level)
            outfile.write('variance="%s",\n' % (self.variance,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('targetField', node)
        if value is not None and 'targetField' not in already_processed:
            already_processed.add('targetField')
            self.targetField = value
        value = find_attr_value_('variance', node)
        if value is not None and 'variance' not in already_processed:
            already_processed.add('variance')
            self.variance = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class PsiVector


class SpectralAnalysis(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpectralAnalysis)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpectralAnalysis.subclass:
            return SpectralAnalysis.subclass(*args_, **kwargs_)
        else:
            return SpectralAnalysis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SpectralAnalysis', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpectralAnalysis')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpectralAnalysis')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpectralAnalysis', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpectralAnalysis'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SpectralAnalysis', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SpectralAnalysis', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SpectralAnalysis'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class SpectralAnalysis


class SeasonalTrendDecomposition(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SeasonalTrendDecomposition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SeasonalTrendDecomposition.subclass:
            return SeasonalTrendDecomposition.subclass(*args_, **kwargs_)
        else:
            return SeasonalTrendDecomposition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SeasonalTrendDecomposition', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SeasonalTrendDecomposition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SeasonalTrendDecomposition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SeasonalTrendDecomposition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SeasonalTrendDecomposition'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SeasonalTrendDecomposition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SeasonalTrendDecomposition', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='SeasonalTrendDecomposition'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class SeasonalTrendDecomposition


class NeuralNetwork(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, activationFunction=None, normalizationMethod='none', threshold='0', width=None, altitude='1.0', numberOfLayers=None, isScorable=True, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, NeuralInputs=None, NeuralLayer=None, NeuralOutputs=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.activationFunction = _cast(None, activationFunction)
        self.normalizationMethod = _cast(None, normalizationMethod)
        self.threshold = _cast(None, threshold)
        self.width = _cast(None, width)
        self.altitude = _cast(None, altitude)
        self.numberOfLayers = _cast(int, numberOfLayers)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.ModelExplanation = ModelExplanation
        self.Targets = Targets
        self.LocalTransformations = LocalTransformations
        self.NeuralInputs = NeuralInputs
        if NeuralLayer is None:
            self.NeuralLayer = []
        else:
            self.NeuralLayer = NeuralLayer
        self.NeuralOutputs = NeuralOutputs
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NeuralNetwork)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NeuralNetwork.subclass:
            return NeuralNetwork.subclass(*args_, **kwargs_)
        else:
            return NeuralNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_ModelExplanation(self): return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation): self.ModelExplanation = ModelExplanation
    def get_Targets(self): return self.Targets
    def set_Targets(self, Targets): self.Targets = Targets
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_NeuralInputs(self): return self.NeuralInputs
    def set_NeuralInputs(self, NeuralInputs): self.NeuralInputs = NeuralInputs
    def get_NeuralLayer(self): return self.NeuralLayer
    def set_NeuralLayer(self, NeuralLayer): self.NeuralLayer = NeuralLayer
    def add_NeuralLayer(self, value): self.NeuralLayer.append(value)
    def insert_NeuralLayer_at(self, index, value): self.NeuralLayer.insert(index, value)
    def replace_NeuralLayer_at(self, index, value): self.NeuralLayer[index] = value
    def get_NeuralOutputs(self): return self.NeuralOutputs
    def set_NeuralOutputs(self, NeuralOutputs): self.NeuralOutputs = NeuralOutputs
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_activationFunction(self): return self.activationFunction
    def set_activationFunction(self, activationFunction): self.activationFunction = activationFunction
    def get_normalizationMethod(self): return self.normalizationMethod
    def set_normalizationMethod(self, normalizationMethod): self.normalizationMethod = normalizationMethod
    def get_threshold(self): return self.threshold
    def set_threshold(self, threshold): self.threshold = threshold
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_altitude(self): return self.altitude
    def set_altitude(self, altitude): self.altitude = altitude
    def get_numberOfLayers(self): return self.numberOfLayers
    def set_numberOfLayers(self, numberOfLayers): self.numberOfLayers = numberOfLayers
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_ACTIVATION_FUNCTION(self, value):
        # Validate type ACTIVATION-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['threshold', 'logistic', 'tanh', 'identity', 'exponential', 'reciprocal', 'square', 'Gauss', 'sine', 'cosine', 'Elliott', 'arctan', 'rectifier', 'radialBasis']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ACTIVATION-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_NN_NORMALIZATION_METHOD(self, value):
        # Validate type NN-NORMALIZATION-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'simplemax', 'softmax']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NN-NORMALIZATION-METHOD' % {"value" : value.encode("utf-8")} )
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.NeuralInputs is not None or
            self.NeuralLayer or
            self.NeuralOutputs is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NeuralNetwork', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NeuralNetwork')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NeuralNetwork')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NeuralNetwork', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NeuralNetwork'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.activationFunction is not None and 'activationFunction' not in already_processed:
            already_processed.add('activationFunction')
            outfile.write(' activationFunction=%s' % (quote_attrib(self.activationFunction), ))
        if self.normalizationMethod != "none" and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            outfile.write(' normalizationMethod=%s' % (quote_attrib(self.normalizationMethod), ))
        if self.threshold != 0 and 'threshold' not in already_processed:
            already_processed.add('threshold')
            outfile.write(' threshold=%s' % (quote_attrib(self.threshold), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (quote_attrib(self.width), ))
        if self.altitude != 1.0 and 'altitude' not in already_processed:
            already_processed.add('altitude')
            outfile.write(' altitude=%s' % (quote_attrib(self.altitude), ))
        if self.numberOfLayers is not None and 'numberOfLayers' not in already_processed:
            already_processed.add('numberOfLayers')
            outfile.write(' numberOfLayers="%s"' % self.gds_format_integer(self.numberOfLayers, input_name='numberOfLayers'))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='NeuralNetwork', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            self.ModelExplanation.export(outfile, level, namespace_, name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            self.Targets.export(outfile, level, namespace_, name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        if self.NeuralInputs is not None:
            self.NeuralInputs.export(outfile, level, namespace_, name_='NeuralInputs', pretty_print=pretty_print)
        for NeuralLayer_ in self.NeuralLayer:
            NeuralLayer_.export(outfile, level, namespace_, name_='NeuralLayer', pretty_print=pretty_print)
        if self.NeuralOutputs is not None:
            self.NeuralOutputs.export(outfile, level, namespace_, name_='NeuralOutputs', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NeuralNetwork', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.activationFunction is not None:
            element.set('activationFunction', self.activationFunction)
        if self.normalizationMethod is not None:
            element.set('normalizationMethod', self.normalizationMethod)
        if self.threshold is not None:
            element.set('threshold', self.threshold)
        if self.width is not None:
            element.set('width', self.width)
        if self.altitude is not None:
            element.set('altitude', self.altitude)
        if self.numberOfLayers is not None:
            element.set('numberOfLayers', self.gds_format_integer(self.numberOfLayers))
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.ModelExplanation is not None:
            ModelExplanation_ = self.ModelExplanation
            ModelExplanation_.to_etree(element, name_='ModelExplanation', mapping_=mapping_)
        if self.Targets is not None:
            Targets_ = self.Targets
            Targets_.to_etree(element, name_='Targets', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        if self.NeuralInputs is not None:
            NeuralInputs_ = self.NeuralInputs
            NeuralInputs_.to_etree(element, name_='NeuralInputs', mapping_=mapping_)
        for NeuralLayer_ in self.NeuralLayer:
            NeuralLayer_.to_etree(element, name_='NeuralLayer', mapping_=mapping_)
        if self.NeuralOutputs is not None:
            NeuralOutputs_ = self.NeuralOutputs
            NeuralOutputs_.to_etree(element, name_='NeuralOutputs', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NeuralNetwork'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.activationFunction is not None and 'activationFunction' not in already_processed:
            already_processed.add('activationFunction')
            showIndent(outfile, level)
            outfile.write('activationFunction="%s",\n' % (self.activationFunction,))
        if self.normalizationMethod is not None and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            showIndent(outfile, level)
            outfile.write('normalizationMethod="%s",\n' % (self.normalizationMethod,))
        if self.threshold is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            showIndent(outfile, level)
            outfile.write('threshold=%e,\n' % (self.threshold,))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            showIndent(outfile, level)
            outfile.write('width=%e,\n' % (self.width,))
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            showIndent(outfile, level)
            outfile.write('altitude=%e,\n' % (self.altitude,))
        if self.numberOfLayers is not None and 'numberOfLayers' not in already_processed:
            already_processed.add('numberOfLayers')
            showIndent(outfile, level)
            outfile.write('numberOfLayers=%d,\n' % (self.numberOfLayers,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelExplanation is not None:
            showIndent(outfile, level)
            outfile.write('ModelExplanation=model_.ModelExplanation(\n')
            self.ModelExplanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targets is not None:
            showIndent(outfile, level)
            outfile.write('Targets=model_.Targets(\n')
            self.Targets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NeuralInputs is not None:
            showIndent(outfile, level)
            outfile.write('NeuralInputs=model_.NeuralInputs(\n')
            self.NeuralInputs.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('NeuralLayer=[\n')
        level += 1
        for NeuralLayer_ in self.NeuralLayer:
            showIndent(outfile, level)
            outfile.write('model_.NeuralLayer(\n')
            NeuralLayer_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.NeuralOutputs is not None:
            showIndent(outfile, level)
            outfile.write('NeuralOutputs=model_.NeuralOutputs(\n')
            self.NeuralOutputs.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('activationFunction', node)
        if value is not None and 'activationFunction' not in already_processed:
            already_processed.add('activationFunction')
            self.activationFunction = value
            self.validate_ACTIVATION_FUNCTION(self.activationFunction)    # validate type ACTIVATION-FUNCTION
        value = find_attr_value_('normalizationMethod', node)
        if value is not None and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            self.normalizationMethod = value
            self.validate_NN_NORMALIZATION_METHOD(self.normalizationMethod)    # validate type NN-NORMALIZATION-METHOD
        value = find_attr_value_('threshold', node)
        if value is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            try:
                self.threshold = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (threshold): %s' % exp)
            self.validate_REAL_NUMBER(self.threshold)    # validate type REAL-NUMBER
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            try:
                self.width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
            self.validate_REAL_NUMBER(self.width)    # validate type REAL-NUMBER
        value = find_attr_value_('altitude', node)
        if value is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            try:
                self.altitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (altitude): %s' % exp)
            self.validate_REAL_NUMBER(self.altitude)    # validate type REAL-NUMBER
        value = find_attr_value_('numberOfLayers', node)
        if value is not None and 'numberOfLayers' not in already_processed:
            already_processed.add('numberOfLayers')
            try:
                self.numberOfLayers = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfLayers < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory()
            obj_.build(child_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory()
            obj_.build(child_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'NeuralInputs':
            obj_ = NeuralInputs.factory()
            obj_.build(child_)
            self.NeuralInputs = obj_
            obj_.original_tagname_ = 'NeuralInputs'
        elif nodeName_ == 'NeuralLayer':
            obj_ = NeuralLayer.factory()
            obj_.build(child_)
            self.NeuralLayer.append(obj_)
            obj_.original_tagname_ = 'NeuralLayer'
        elif nodeName_ == 'NeuralOutputs':
            obj_ = NeuralOutputs.factory()
            obj_.build(child_)
            self.NeuralOutputs = obj_
            obj_.original_tagname_ = 'NeuralOutputs'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class NeuralNetwork


class NeuralInputs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numberOfInputs=None, Extension=None, NeuralInput=None):
        self.original_tagname_ = None
        self.numberOfInputs = _cast(int, numberOfInputs)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if NeuralInput is None:
            self.NeuralInput = []
        else:
            self.NeuralInput = NeuralInput
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NeuralInputs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NeuralInputs.subclass:
            return NeuralInputs.subclass(*args_, **kwargs_)
        else:
            return NeuralInputs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_NeuralInput(self): return self.NeuralInput
    def set_NeuralInput(self, NeuralInput): self.NeuralInput = NeuralInput
    def add_NeuralInput(self, value): self.NeuralInput.append(value)
    def insert_NeuralInput_at(self, index, value): self.NeuralInput.insert(index, value)
    def replace_NeuralInput_at(self, index, value): self.NeuralInput[index] = value
    def get_numberOfInputs(self): return self.numberOfInputs
    def set_numberOfInputs(self, numberOfInputs): self.numberOfInputs = numberOfInputs
    def hasContent_(self):
        if (
            self.Extension or
            self.NeuralInput
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NeuralInputs', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NeuralInputs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NeuralInputs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NeuralInputs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NeuralInputs'):
        if self.numberOfInputs is not None and 'numberOfInputs' not in already_processed:
            already_processed.add('numberOfInputs')
            outfile.write(' numberOfInputs="%s"' % self.gds_format_integer(self.numberOfInputs, input_name='numberOfInputs'))
    def exportChildren(self, outfile, level, namespace_='', name_='NeuralInputs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for NeuralInput_ in self.NeuralInput:
            NeuralInput_.export(outfile, level, namespace_, name_='NeuralInput', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NeuralInputs', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.numberOfInputs is not None:
            element.set('numberOfInputs', self.gds_format_integer(self.numberOfInputs))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for NeuralInput_ in self.NeuralInput:
            NeuralInput_.to_etree(element, name_='NeuralInput', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NeuralInputs'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfInputs is not None and 'numberOfInputs' not in already_processed:
            already_processed.add('numberOfInputs')
            showIndent(outfile, level)
            outfile.write('numberOfInputs=%d,\n' % (self.numberOfInputs,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NeuralInput=[\n')
        level += 1
        for NeuralInput_ in self.NeuralInput:
            showIndent(outfile, level)
            outfile.write('model_.NeuralInput(\n')
            NeuralInput_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfInputs', node)
        if value is not None and 'numberOfInputs' not in already_processed:
            already_processed.add('numberOfInputs')
            try:
                self.numberOfInputs = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfInputs < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'NeuralInput':
            obj_ = NeuralInput.factory()
            obj_.build(child_)
            self.NeuralInput.append(obj_)
            obj_.original_tagname_ = 'NeuralInput'
# end class NeuralInputs


class NeuralLayer(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numberOfNeurons=None, activationFunction=None, threshold=None, width=None, altitude=None, normalizationMethod=None, Extension=None, Neuron=None):
        self.original_tagname_ = None
        self.numberOfNeurons = _cast(int, numberOfNeurons)
        self.activationFunction = _cast(None, activationFunction)
        self.threshold = _cast(None, threshold)
        self.width = _cast(None, width)
        self.altitude = _cast(None, altitude)
        self.normalizationMethod = _cast(None, normalizationMethod)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Neuron is None:
            self.Neuron = []
        else:
            self.Neuron = Neuron
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NeuralLayer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NeuralLayer.subclass:
            return NeuralLayer.subclass(*args_, **kwargs_)
        else:
            return NeuralLayer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Neuron(self): return self.Neuron
    def set_Neuron(self, Neuron): self.Neuron = Neuron
    def add_Neuron(self, value): self.Neuron.append(value)
    def insert_Neuron_at(self, index, value): self.Neuron.insert(index, value)
    def replace_Neuron_at(self, index, value): self.Neuron[index] = value
    def get_numberOfNeurons(self): return self.numberOfNeurons
    def set_numberOfNeurons(self, numberOfNeurons): self.numberOfNeurons = numberOfNeurons
    def get_activationFunction(self): return self.activationFunction
    def set_activationFunction(self, activationFunction): self.activationFunction = activationFunction
    def get_threshold(self): return self.threshold
    def set_threshold(self, threshold): self.threshold = threshold
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_altitude(self): return self.altitude
    def set_altitude(self, altitude): self.altitude = altitude
    def get_normalizationMethod(self): return self.normalizationMethod
    def set_normalizationMethod(self, normalizationMethod): self.normalizationMethod = normalizationMethod
    def validate_ACTIVATION_FUNCTION(self, value):
        # Validate type ACTIVATION-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['threshold', 'logistic', 'tanh', 'identity', 'exponential', 'reciprocal', 'square', 'Gauss', 'sine', 'cosine', 'Elliott', 'arctan', 'rectifier', 'radialBasis']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ACTIVATION-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_NN_NORMALIZATION_METHOD(self, value):
        # Validate type NN-NORMALIZATION-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'simplemax', 'softmax']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NN-NORMALIZATION-METHOD' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Extension or
            self.Neuron
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NeuralLayer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NeuralLayer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NeuralLayer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NeuralLayer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NeuralLayer'):
        if self.numberOfNeurons is not None and 'numberOfNeurons' not in already_processed:
            already_processed.add('numberOfNeurons')
            outfile.write(' numberOfNeurons="%s"' % self.gds_format_integer(self.numberOfNeurons, input_name='numberOfNeurons'))
        if self.activationFunction is not None and 'activationFunction' not in already_processed:
            already_processed.add('activationFunction')
            outfile.write(' activationFunction=%s' % (quote_attrib(self.activationFunction), ))
        if self.threshold is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            outfile.write(' threshold=%s' % (quote_attrib(self.threshold), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (quote_attrib(self.width), ))
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            outfile.write(' altitude=%s' % (quote_attrib(self.altitude), ))
        if self.normalizationMethod is not None and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            outfile.write(' normalizationMethod=%s' % (quote_attrib(self.normalizationMethod), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NeuralLayer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Neuron_ in self.Neuron:
            Neuron_.export(outfile, level, namespace_, name_='Neuron', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NeuralLayer', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.numberOfNeurons is not None:
            element.set('numberOfNeurons', self.gds_format_integer(self.numberOfNeurons))
        if self.activationFunction is not None:
            element.set('activationFunction', self.activationFunction)
        if self.threshold is not None:
            element.set('threshold', self.threshold)
        if self.width is not None:
            element.set('width', self.width)
        if self.altitude is not None:
            element.set('altitude', self.altitude)
        if self.normalizationMethod is not None:
            element.set('normalizationMethod', self.normalizationMethod)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Neuron_ in self.Neuron:
            Neuron_.to_etree(element, name_='Neuron', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NeuralLayer'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfNeurons is not None and 'numberOfNeurons' not in already_processed:
            already_processed.add('numberOfNeurons')
            showIndent(outfile, level)
            outfile.write('numberOfNeurons=%d,\n' % (self.numberOfNeurons,))
        if self.activationFunction is not None and 'activationFunction' not in already_processed:
            already_processed.add('activationFunction')
            showIndent(outfile, level)
            outfile.write('activationFunction="%s",\n' % (self.activationFunction,))
        if self.threshold is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            showIndent(outfile, level)
            outfile.write('threshold=%e,\n' % (self.threshold,))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            showIndent(outfile, level)
            outfile.write('width=%e,\n' % (self.width,))
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            showIndent(outfile, level)
            outfile.write('altitude=%e,\n' % (self.altitude,))
        if self.normalizationMethod is not None and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            showIndent(outfile, level)
            outfile.write('normalizationMethod="%s",\n' % (self.normalizationMethod,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Neuron=[\n')
        level += 1
        for Neuron_ in self.Neuron:
            showIndent(outfile, level)
            outfile.write('model_.Neuron(\n')
            Neuron_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfNeurons', node)
        if value is not None and 'numberOfNeurons' not in already_processed:
            already_processed.add('numberOfNeurons')
            try:
                self.numberOfNeurons = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfNeurons < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('activationFunction', node)
        if value is not None and 'activationFunction' not in already_processed:
            already_processed.add('activationFunction')
            self.activationFunction = value
            self.validate_ACTIVATION_FUNCTION(self.activationFunction)    # validate type ACTIVATION-FUNCTION
        value = find_attr_value_('threshold', node)
        if value is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            try:
                self.threshold = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (threshold): %s' % exp)
            self.validate_REAL_NUMBER(self.threshold)    # validate type REAL-NUMBER
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            try:
                self.width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
            self.validate_REAL_NUMBER(self.width)    # validate type REAL-NUMBER
        value = find_attr_value_('altitude', node)
        if value is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            try:
                self.altitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (altitude): %s' % exp)
            self.validate_REAL_NUMBER(self.altitude)    # validate type REAL-NUMBER
        value = find_attr_value_('normalizationMethod', node)
        if value is not None and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            self.normalizationMethod = value
            self.validate_NN_NORMALIZATION_METHOD(self.normalizationMethod)    # validate type NN-NORMALIZATION-METHOD
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Neuron':
            obj_ = Neuron.factory()
            obj_.build(child_)
            self.Neuron.append(obj_)
            obj_.original_tagname_ = 'Neuron'
# end class NeuralLayer


class NeuralOutputs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numberOfOutputs=None, Extension=None, NeuralOutput=None):
        self.original_tagname_ = None
        self.numberOfOutputs = _cast(int, numberOfOutputs)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if NeuralOutput is None:
            self.NeuralOutput = []
        else:
            self.NeuralOutput = NeuralOutput
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NeuralOutputs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NeuralOutputs.subclass:
            return NeuralOutputs.subclass(*args_, **kwargs_)
        else:
            return NeuralOutputs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_NeuralOutput(self): return self.NeuralOutput
    def set_NeuralOutput(self, NeuralOutput): self.NeuralOutput = NeuralOutput
    def add_NeuralOutput(self, value): self.NeuralOutput.append(value)
    def insert_NeuralOutput_at(self, index, value): self.NeuralOutput.insert(index, value)
    def replace_NeuralOutput_at(self, index, value): self.NeuralOutput[index] = value
    def get_numberOfOutputs(self): return self.numberOfOutputs
    def set_numberOfOutputs(self, numberOfOutputs): self.numberOfOutputs = numberOfOutputs
    def hasContent_(self):
        if (
            self.Extension or
            self.NeuralOutput
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NeuralOutputs', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NeuralOutputs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NeuralOutputs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NeuralOutputs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NeuralOutputs'):
        if self.numberOfOutputs is not None and 'numberOfOutputs' not in already_processed:
            already_processed.add('numberOfOutputs')
            outfile.write(' numberOfOutputs="%s"' % self.gds_format_integer(self.numberOfOutputs, input_name='numberOfOutputs'))
    def exportChildren(self, outfile, level, namespace_='', name_='NeuralOutputs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for NeuralOutput_ in self.NeuralOutput:
            NeuralOutput_.export(outfile, level, namespace_, name_='NeuralOutput', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NeuralOutputs', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.numberOfOutputs is not None:
            element.set('numberOfOutputs', self.gds_format_integer(self.numberOfOutputs))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for NeuralOutput_ in self.NeuralOutput:
            NeuralOutput_.to_etree(element, name_='NeuralOutput', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NeuralOutputs'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfOutputs is not None and 'numberOfOutputs' not in already_processed:
            already_processed.add('numberOfOutputs')
            showIndent(outfile, level)
            outfile.write('numberOfOutputs=%d,\n' % (self.numberOfOutputs,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NeuralOutput=[\n')
        level += 1
        for NeuralOutput_ in self.NeuralOutput:
            showIndent(outfile, level)
            outfile.write('model_.NeuralOutput(\n')
            NeuralOutput_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfOutputs', node)
        if value is not None and 'numberOfOutputs' not in already_processed:
            already_processed.add('numberOfOutputs')
            try:
                self.numberOfOutputs = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfOutputs < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'NeuralOutput':
            obj_ = NeuralOutput.factory()
            obj_.build(child_)
            self.NeuralOutput.append(obj_)
            obj_.original_tagname_ = 'NeuralOutput'
# end class NeuralOutputs


class NeuralInput(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, Extension=None, DerivedField=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.DerivedField = DerivedField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NeuralInput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NeuralInput.subclass:
            return NeuralInput.subclass(*args_, **kwargs_)
        else:
            return NeuralInput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_DerivedField(self): return self.DerivedField
    def set_DerivedField(self, DerivedField): self.DerivedField = DerivedField
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_NN_NEURON_ID(self, value):
        # Validate type NN-NEURON-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.DerivedField is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NeuralInput', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NeuralInput')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NeuralInput')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NeuralInput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NeuralInput'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NeuralInput', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.DerivedField is not None:
            self.DerivedField.export(outfile, level, namespace_, name_='DerivedField', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NeuralInput', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.id is not None:
            element.set('id', self.id)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.DerivedField is not None:
            DerivedField_ = self.DerivedField
            DerivedField_.to_etree(element, name_='DerivedField', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NeuralInput'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DerivedField is not None:
            showIndent(outfile, level)
            outfile.write('DerivedField=model_.DerivedField(\n')
            self.DerivedField.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_NN_NEURON_ID(self.id)    # validate type NN-NEURON-ID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'DerivedField':
            obj_ = DerivedField.factory()
            obj_.build(child_)
            self.DerivedField = obj_
            obj_.original_tagname_ = 'DerivedField'
# end class NeuralInput


class Neuron(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, bias=None, width=None, altitude=None, Extension=None, Con=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.bias = _cast(None, bias)
        self.width = _cast(None, width)
        self.altitude = _cast(None, altitude)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Con is None:
            self.Con = []
        else:
            self.Con = Con
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Neuron)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Neuron.subclass:
            return Neuron.subclass(*args_, **kwargs_)
        else:
            return Neuron(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Con(self): return self.Con
    def set_Con(self, Con): self.Con = Con
    def add_Con(self, value): self.Con.append(value)
    def insert_Con_at(self, index, value): self.Con.insert(index, value)
    def replace_Con_at(self, index, value): self.Con[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_bias(self): return self.bias
    def set_bias(self, bias): self.bias = bias
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_altitude(self): return self.altitude
    def set_altitude(self, altitude): self.altitude = altitude
    def validate_NN_NEURON_ID(self, value):
        # Validate type NN-NEURON-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Con
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Neuron', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Neuron')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Neuron')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Neuron', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Neuron'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.bias is not None and 'bias' not in already_processed:
            already_processed.add('bias')
            outfile.write(' bias=%s' % (quote_attrib(self.bias), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (quote_attrib(self.width), ))
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            outfile.write(' altitude=%s' % (quote_attrib(self.altitude), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Neuron', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Con_ in self.Con:
            Con_.export(outfile, level, namespace_, name_='Con', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Neuron', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.id is not None:
            element.set('id', self.id)
        if self.bias is not None:
            element.set('bias', self.bias)
        if self.width is not None:
            element.set('width', self.width)
        if self.altitude is not None:
            element.set('altitude', self.altitude)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Con_ in self.Con:
            Con_.to_etree(element, name_='Con', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Neuron'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.bias is not None and 'bias' not in already_processed:
            already_processed.add('bias')
            showIndent(outfile, level)
            outfile.write('bias=%e,\n' % (self.bias,))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            showIndent(outfile, level)
            outfile.write('width=%e,\n' % (self.width,))
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            showIndent(outfile, level)
            outfile.write('altitude=%e,\n' % (self.altitude,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Con=[\n')
        level += 1
        for Con_ in self.Con:
            showIndent(outfile, level)
            outfile.write('model_.Con(\n')
            Con_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_NN_NEURON_ID(self.id)    # validate type NN-NEURON-ID
        value = find_attr_value_('bias', node)
        if value is not None and 'bias' not in already_processed:
            already_processed.add('bias')
            try:
                self.bias = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (bias): %s' % exp)
            self.validate_REAL_NUMBER(self.bias)    # validate type REAL-NUMBER
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            try:
                self.width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (width): %s' % exp)
            self.validate_REAL_NUMBER(self.width)    # validate type REAL-NUMBER
        value = find_attr_value_('altitude', node)
        if value is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            try:
                self.altitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (altitude): %s' % exp)
            self.validate_REAL_NUMBER(self.altitude)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Con':
            obj_ = Con.factory()
            obj_.build(child_)
            self.Con.append(obj_)
            obj_.original_tagname_ = 'Con'
# end class Neuron


class Con(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, from_=None, weight=None, Extension=None):
        self.original_tagname_ = None
        self.from_ = _cast(None, from_)
        self.weight = _cast(None, weight)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Con)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Con.subclass:
            return Con.subclass(*args_, **kwargs_)
        else:
            return Con(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_from(self): return self.from_
    def set_from(self, from_): self.from_ = from_
    def get_weight(self): return self.weight
    def set_weight(self, weight): self.weight = weight
    def validate_NN_NEURON_IDREF(self, value):
        # Validate type NN-NEURON-IDREF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Con', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Con')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Con')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Con', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Con'):
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' from=%s' % (quote_attrib(self.from_), ))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight=%s' % (quote_attrib(self.weight), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Con', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Con', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.from_ is not None:
            element.set('from', self.from_)
        if self.weight is not None:
            element.set('weight', self.weight)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Con'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            showIndent(outfile, level)
            outfile.write('from_="%s",\n' % (self.from_,))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            showIndent(outfile, level)
            outfile.write('weight=%e,\n' % (self.weight,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            self.from_ = value
            self.validate_NN_NEURON_IDREF(self.from_)    # validate type NN-NEURON-IDREF
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            try:
                self.weight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (weight): %s' % exp)
            self.validate_REAL_NUMBER(self.weight)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Con


class NeuralOutput(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, outputNeuron=None, Extension=None, DerivedField=None):
        self.original_tagname_ = None
        self.outputNeuron = _cast(None, outputNeuron)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.DerivedField = DerivedField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NeuralOutput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NeuralOutput.subclass:
            return NeuralOutput.subclass(*args_, **kwargs_)
        else:
            return NeuralOutput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_DerivedField(self): return self.DerivedField
    def set_DerivedField(self, DerivedField): self.DerivedField = DerivedField
    def get_outputNeuron(self): return self.outputNeuron
    def set_outputNeuron(self, outputNeuron): self.outputNeuron = outputNeuron
    def validate_NN_NEURON_IDREF(self, value):
        # Validate type NN-NEURON-IDREF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.DerivedField is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NeuralOutput', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NeuralOutput')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NeuralOutput')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NeuralOutput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NeuralOutput'):
        if self.outputNeuron is not None and 'outputNeuron' not in already_processed:
            already_processed.add('outputNeuron')
            outfile.write(' outputNeuron=%s' % (quote_attrib(self.outputNeuron), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NeuralOutput', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.DerivedField is not None:
            self.DerivedField.export(outfile, level, namespace_, name_='DerivedField', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NeuralOutput', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.outputNeuron is not None:
            element.set('outputNeuron', self.outputNeuron)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.DerivedField is not None:
            DerivedField_ = self.DerivedField
            DerivedField_.to_etree(element, name_='DerivedField', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NeuralOutput'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.outputNeuron is not None and 'outputNeuron' not in already_processed:
            already_processed.add('outputNeuron')
            showIndent(outfile, level)
            outfile.write('outputNeuron="%s",\n' % (self.outputNeuron,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DerivedField is not None:
            showIndent(outfile, level)
            outfile.write('DerivedField=model_.DerivedField(\n')
            self.DerivedField.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('outputNeuron', node)
        if value is not None and 'outputNeuron' not in already_processed:
            already_processed.add('outputNeuron')
            self.outputNeuron = value
            self.validate_NN_NEURON_IDREF(self.outputNeuron)    # validate type NN-NEURON-IDREF
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'DerivedField':
            obj_ = DerivedField.factory()
            obj_.build(child_)
            self.DerivedField = obj_
            obj_.original_tagname_ = 'DerivedField'
# end class NeuralOutput


class DataDictionary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numberOfFields=None, Extension=None, DataField=None, Taxonomy=None):
        self.original_tagname_ = None
        self.numberOfFields = _cast(int, numberOfFields)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if DataField is None:
            self.DataField = []
        else:
            self.DataField = DataField
        if Taxonomy is None:
            self.Taxonomy = []
        else:
            self.Taxonomy = Taxonomy
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataDictionary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataDictionary.subclass:
            return DataDictionary.subclass(*args_, **kwargs_)
        else:
            return DataDictionary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_DataField(self): return self.DataField
    def set_DataField(self, DataField): self.DataField = DataField
    def add_DataField(self, value): self.DataField.append(value)
    def insert_DataField_at(self, index, value): self.DataField.insert(index, value)
    def replace_DataField_at(self, index, value): self.DataField[index] = value
    def get_Taxonomy(self): return self.Taxonomy
    def set_Taxonomy(self, Taxonomy): self.Taxonomy = Taxonomy
    def add_Taxonomy(self, value): self.Taxonomy.append(value)
    def insert_Taxonomy_at(self, index, value): self.Taxonomy.insert(index, value)
    def replace_Taxonomy_at(self, index, value): self.Taxonomy[index] = value
    def get_numberOfFields(self): return self.numberOfFields
    def set_numberOfFields(self, numberOfFields): self.numberOfFields = numberOfFields
    def hasContent_(self):
        if (
            self.Extension or
            self.DataField or
            self.Taxonomy
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DataDictionary', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataDictionary')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataDictionary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DataDictionary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataDictionary'):
        if self.numberOfFields is not None and 'numberOfFields' not in already_processed:
            already_processed.add('numberOfFields')
            outfile.write(' numberOfFields="%s"' % self.gds_format_integer(self.numberOfFields, input_name='numberOfFields'))
    def exportChildren(self, outfile, level, namespace_='', name_='DataDictionary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for DataField_ in self.DataField:
            DataField_.export(outfile, level, namespace_, name_='DataField', pretty_print=pretty_print)
        for Taxonomy_ in self.Taxonomy:
            Taxonomy_.export(outfile, level, namespace_, name_='Taxonomy', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DataDictionary', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.numberOfFields is not None:
            element.set('numberOfFields', self.gds_format_integer(self.numberOfFields))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for DataField_ in self.DataField:
            DataField_.to_etree(element, name_='DataField', mapping_=mapping_)
        for Taxonomy_ in self.Taxonomy:
            Taxonomy_.to_etree(element, name_='Taxonomy', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DataDictionary'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfFields is not None and 'numberOfFields' not in already_processed:
            already_processed.add('numberOfFields')
            showIndent(outfile, level)
            outfile.write('numberOfFields=%d,\n' % (self.numberOfFields,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataField=[\n')
        level += 1
        for DataField_ in self.DataField:
            showIndent(outfile, level)
            outfile.write('model_.DataField(\n')
            DataField_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Taxonomy=[\n')
        level += 1
        for Taxonomy_ in self.Taxonomy:
            showIndent(outfile, level)
            outfile.write('model_.Taxonomy(\n')
            Taxonomy_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfFields', node)
        if value is not None and 'numberOfFields' not in already_processed:
            already_processed.add('numberOfFields')
            try:
                self.numberOfFields = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfFields < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'DataField':
            obj_ = DataField.factory()
            obj_.build(child_)
            self.DataField.append(obj_)
            obj_.original_tagname_ = 'DataField'
        elif nodeName_ == 'Taxonomy':
            obj_ = Taxonomy.factory()
            obj_.build(child_)
            self.Taxonomy.append(obj_)
            obj_.original_tagname_ = 'Taxonomy'
# end class DataDictionary


class DataField(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, optype=None, dataType=None, taxonomy=None, isCyclic='0', Extension=None, Interval=None, Value=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.displayName = _cast(None, displayName)
        self.optype = _cast(None, optype)
        self.dataType = _cast(None, dataType)
        self.taxonomy = _cast(None, taxonomy)
        self.isCyclic = _cast(None, isCyclic)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Interval is None:
            self.Interval = []
        else:
            self.Interval = Interval
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataField.subclass:
            return DataField.subclass(*args_, **kwargs_)
        else:
            return DataField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Interval(self): return self.Interval
    def set_Interval(self, Interval): self.Interval = Interval
    def add_Interval(self, value): self.Interval.append(value)
    def insert_Interval_at(self, index, value): self.Interval.insert(index, value)
    def replace_Interval_at(self, index, value): self.Interval[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value_at(self, index, value): self.Value.insert(index, value)
    def replace_Value_at(self, index, value): self.Value[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_optype(self): return self.optype
    def set_optype(self, optype): self.optype = optype
    def get_dataType(self): return self.dataType
    def set_dataType(self, dataType): self.dataType = dataType
    def get_taxonomy(self): return self.taxonomy
    def set_taxonomy(self, taxonomy): self.taxonomy = taxonomy
    def get_isCyclic(self): return self.isCyclic
    def set_isCyclic(self, isCyclic): self.isCyclic = isCyclic
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_OPTYPE(self, value):
        # Validate type OPTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['categorical', 'ordinal', 'continuous']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OPTYPE' % {"value" : value.encode("utf-8")} )
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DATATYPE' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Extension or
            self.Interval or
            self.Value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DataField', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataField')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DataField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataField'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            outfile.write(' optype=%s' % (quote_attrib(self.optype), ))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (quote_attrib(self.dataType), ))
        if self.taxonomy is not None and 'taxonomy' not in already_processed:
            already_processed.add('taxonomy')
            outfile.write(' taxonomy=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.taxonomy), input_name='taxonomy')), ))
        if self.isCyclic != "0" and 'isCyclic' not in already_processed:
            already_processed.add('isCyclic')
            outfile.write(' isCyclic=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.isCyclic), input_name='isCyclic')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DataField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Interval_ in self.Interval:
            Interval_.export(outfile, level, namespace_, name_='Interval', pretty_print=pretty_print)
        for Value_ in self.Value:
            Value_.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DataField', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.name)
        if self.displayName is not None:
            element.set('displayName', self.gds_format_string(self.displayName))
        if self.optype is not None:
            element.set('optype', self.optype)
        if self.dataType is not None:
            element.set('dataType', self.dataType)
        if self.taxonomy is not None:
            element.set('taxonomy', self.gds_format_string(self.taxonomy))
        if self.isCyclic is not None:
            element.set('isCyclic', self.gds_format_string(self.isCyclic))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Interval_ in self.Interval:
            Interval_.to_etree(element, name_='Interval', mapping_=mapping_)
        for Value_ in self.Value:
            Value_.to_etree(element, name_='Value', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DataField'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            showIndent(outfile, level)
            outfile.write('displayName="%s",\n' % (self.displayName,))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            showIndent(outfile, level)
            outfile.write('optype="%s",\n' % (self.optype,))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            showIndent(outfile, level)
            outfile.write('dataType="%s",\n' % (self.dataType,))
        if self.taxonomy is not None and 'taxonomy' not in already_processed:
            already_processed.add('taxonomy')
            showIndent(outfile, level)
            outfile.write('taxonomy="%s",\n' % (self.taxonomy,))
        if self.isCyclic is not None and 'isCyclic' not in already_processed:
            already_processed.add('isCyclic')
            showIndent(outfile, level)
            outfile.write('isCyclic="%s",\n' % (self.isCyclic,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Interval=[\n')
        level += 1
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('model_.Interval(\n')
            Interval_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('model_.Value(\n')
            Value_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
        value = find_attr_value_('optype', node)
        if value is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            self.optype = value
            self.validate_OPTYPE(self.optype)    # validate type OPTYPE
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
        value = find_attr_value_('taxonomy', node)
        if value is not None and 'taxonomy' not in already_processed:
            already_processed.add('taxonomy')
            self.taxonomy = value
        value = find_attr_value_('isCyclic', node)
        if value is not None and 'isCyclic' not in already_processed:
            already_processed.add('isCyclic')
            self.isCyclic = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Interval':
            obj_ = Interval.factory()
            obj_.build(child_)
            self.Interval.append(obj_)
            obj_.original_tagname_ = 'Interval'
        elif nodeName_ == 'Value':
            obj_ = Value.factory()
            obj_.build(child_)
            self.Value.append(obj_)
            obj_.original_tagname_ = 'Value'
# end class DataField


class Value(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, displayValue=None, property='valid', Extension=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.displayValue = _cast(None, displayValue)
        self.property = _cast(None, property)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Value)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Value.subclass:
            return Value.subclass(*args_, **kwargs_)
        else:
            return Value(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_displayValue(self): return self.displayValue
    def set_displayValue(self, displayValue): self.displayValue = displayValue
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Value', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Value')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Value')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Value', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Value'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.displayValue is not None and 'displayValue' not in already_processed:
            already_processed.add('displayValue')
            outfile.write(' displayValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayValue), input_name='displayValue')), ))
        if self.property != "valid" and 'property' not in already_processed:
            already_processed.add('property')
            outfile.write(' property=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.property), input_name='property')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Value', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Value', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.displayValue is not None:
            element.set('displayValue', self.gds_format_string(self.displayValue))
        if self.property is not None:
            element.set('property', self.gds_format_string(self.property))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Value'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.displayValue is not None and 'displayValue' not in already_processed:
            already_processed.add('displayValue')
            showIndent(outfile, level)
            outfile.write('displayValue="%s",\n' % (self.displayValue,))
        if self.property is not None and 'property' not in already_processed:
            already_processed.add('property')
            showIndent(outfile, level)
            outfile.write('property="%s",\n' % (self.property,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('displayValue', node)
        if value is not None and 'displayValue' not in already_processed:
            already_processed.add('displayValue')
            self.displayValue = value
        value = find_attr_value_('property', node)
        if value is not None and 'property' not in already_processed:
            already_processed.add('property')
            self.property = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Value


class Interval(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, closure=None, leftMargin=None, rightMargin=None, Extension=None):
        self.original_tagname_ = None
        self.closure = _cast(None, closure)
        self.leftMargin = _cast(None, leftMargin)
        self.rightMargin = _cast(None, rightMargin)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Interval)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Interval.subclass:
            return Interval.subclass(*args_, **kwargs_)
        else:
            return Interval(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_closure(self): return self.closure
    def set_closure(self, closure): self.closure = closure
    def get_leftMargin(self): return self.leftMargin
    def set_leftMargin(self, leftMargin): self.leftMargin = leftMargin
    def get_rightMargin(self): return self.rightMargin
    def set_rightMargin(self, rightMargin): self.rightMargin = rightMargin
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Interval', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Interval')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Interval')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Interval', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Interval'):
        if self.closure is not None and 'closure' not in already_processed:
            already_processed.add('closure')
            outfile.write(' closure=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.closure), input_name='closure')), ))
        if self.leftMargin is not None and 'leftMargin' not in already_processed:
            already_processed.add('leftMargin')
            outfile.write(' leftMargin=%s' % (quote_attrib(self.leftMargin), ))
        if self.rightMargin is not None and 'rightMargin' not in already_processed:
            already_processed.add('rightMargin')
            outfile.write(' rightMargin=%s' % (quote_attrib(self.rightMargin), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Interval', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Interval', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.closure is not None:
            element.set('closure', self.gds_format_string(self.closure))
        if self.leftMargin is not None:
            element.set('leftMargin', self.leftMargin)
        if self.rightMargin is not None:
            element.set('rightMargin', self.rightMargin)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Interval'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.closure is not None and 'closure' not in already_processed:
            already_processed.add('closure')
            showIndent(outfile, level)
            outfile.write('closure="%s",\n' % (self.closure,))
        if self.leftMargin is not None and 'leftMargin' not in already_processed:
            already_processed.add('leftMargin')
            showIndent(outfile, level)
            outfile.write('leftMargin=%e,\n' % (self.leftMargin,))
        if self.rightMargin is not None and 'rightMargin' not in already_processed:
            already_processed.add('rightMargin')
            showIndent(outfile, level)
            outfile.write('rightMargin=%e,\n' % (self.rightMargin,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('closure', node)
        if value is not None and 'closure' not in already_processed:
            already_processed.add('closure')
            self.closure = value
        value = find_attr_value_('leftMargin', node)
        if value is not None and 'leftMargin' not in already_processed:
            already_processed.add('leftMargin')
            try:
                self.leftMargin = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (leftMargin): %s' % exp)
            self.validate_NUMBER(self.leftMargin)    # validate type NUMBER
        value = find_attr_value_('rightMargin', node)
        if value is not None and 'rightMargin' not in already_processed:
            already_processed.add('rightMargin')
            try:
                self.rightMargin = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rightMargin): %s' % exp)
            self.validate_NUMBER(self.rightMargin)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Interval


class Header(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, copyright=None, description=None, modelVersion=None, Extension=None, Application=None, Annotation=None, Timestamp=None):
        self.original_tagname_ = None
        self.copyright = _cast(None, copyright)
        self.description = _cast(None, description)
        self.modelVersion = _cast(None, modelVersion)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Application = Application
        if Annotation is None:
            self.Annotation = []
        else:
            self.Annotation = Annotation
        self.Timestamp = Timestamp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Header)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Header.subclass:
            return Header.subclass(*args_, **kwargs_)
        else:
            return Header(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Application(self): return self.Application
    def set_Application(self, Application): self.Application = Application
    def get_Annotation(self): return self.Annotation
    def set_Annotation(self, Annotation): self.Annotation = Annotation
    def add_Annotation(self, value): self.Annotation.append(value)
    def insert_Annotation_at(self, index, value): self.Annotation.insert(index, value)
    def replace_Annotation_at(self, index, value): self.Annotation[index] = value
    def get_Timestamp(self): return self.Timestamp
    def set_Timestamp(self, Timestamp): self.Timestamp = Timestamp
    def get_copyright(self): return self.copyright
    def set_copyright(self, copyright): self.copyright = copyright
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_modelVersion(self): return self.modelVersion
    def set_modelVersion(self, modelVersion): self.modelVersion = modelVersion
    def hasContent_(self):
        if (
            self.Extension or
            self.Application is not None or
            self.Annotation or
            self.Timestamp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Header', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Header')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Header')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Header', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Header'):
        if self.copyright is not None and 'copyright' not in already_processed:
            already_processed.add('copyright')
            outfile.write(' copyright=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.copyright), input_name='copyright')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.modelVersion is not None and 'modelVersion' not in already_processed:
            already_processed.add('modelVersion')
            outfile.write(' modelVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelVersion), input_name='modelVersion')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Header', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Application is not None:
            self.Application.export(outfile, level, namespace_, name_='Application', pretty_print=pretty_print)
        for Annotation_ in self.Annotation:
            Annotation_.export(outfile, level, namespace_, name_='Annotation', pretty_print=pretty_print)
        if self.Timestamp is not None:
            self.Timestamp.export(outfile, level, namespace_, name_='Timestamp', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Header', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.copyright is not None:
            element.set('copyright', self.gds_format_string(self.copyright))
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        if self.modelVersion is not None:
            element.set('modelVersion', self.gds_format_string(self.modelVersion))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Application is not None:
            Application_ = self.Application
            Application_.to_etree(element, name_='Application', mapping_=mapping_)
        for Annotation_ in self.Annotation:
            Annotation_.to_etree(element, name_='Annotation', mapping_=mapping_)
        if self.Timestamp is not None:
            Timestamp_ = self.Timestamp
            Timestamp_.to_etree(element, name_='Timestamp', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Header'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.copyright is not None and 'copyright' not in already_processed:
            already_processed.add('copyright')
            showIndent(outfile, level)
            outfile.write('copyright="%s",\n' % (self.copyright,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            showIndent(outfile, level)
            outfile.write('description="%s",\n' % (self.description,))
        if self.modelVersion is not None and 'modelVersion' not in already_processed:
            already_processed.add('modelVersion')
            showIndent(outfile, level)
            outfile.write('modelVersion="%s",\n' % (self.modelVersion,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Application is not None:
            showIndent(outfile, level)
            outfile.write('Application=model_.Application(\n')
            self.Application.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Annotation=[\n')
        level += 1
        for Annotation_ in self.Annotation:
            showIndent(outfile, level)
            outfile.write('model_.Annotation(\n')
            Annotation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Timestamp is not None:
            showIndent(outfile, level)
            outfile.write('Timestamp=model_.Timestamp(\n')
            self.Timestamp.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('copyright', node)
        if value is not None and 'copyright' not in already_processed:
            already_processed.add('copyright')
            self.copyright = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('modelVersion', node)
        if value is not None and 'modelVersion' not in already_processed:
            already_processed.add('modelVersion')
            self.modelVersion = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Application':
            obj_ = Application.factory()
            obj_.build(child_)
            self.Application = obj_
            obj_.original_tagname_ = 'Application'
        elif nodeName_ == 'Annotation':
            obj_ = Annotation.factory()
            obj_.build(child_)
            self.Annotation.append(obj_)
            obj_.original_tagname_ = 'Annotation'
        elif nodeName_ == 'Timestamp':
            obj_ = Timestamp.factory()
            obj_.build(child_)
            self.Timestamp = obj_
            obj_.original_tagname_ = 'Timestamp'
# end class Header


class Application(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, version=None, Extension=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.version = _cast(None, version)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Application)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Application.subclass:
            return Application.subclass(*args_, **kwargs_)
        else:
            return Application(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Application', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Application')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Application')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Application', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Application'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Application', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Application', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.version is not None:
            element.set('version', self.gds_format_string(self.version))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Application'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Application


class Annotation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Annotation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Annotation.subclass:
            return Annotation.subclass(*args_, **kwargs_)
        else:
            return Annotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.Extension or
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Annotation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Annotation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Annotation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Annotation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Annotation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Annotation', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Annotation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for item_ in self.content_:
            item_.to_etree(element)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Annotation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'Extension', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_Extension'):
              self.add_Extension(obj_.value)
            elif hasattr(self, 'set_Extension'):
              self.set_Extension(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class Annotation


class Timestamp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Timestamp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Timestamp.subclass:
            return Timestamp.subclass(*args_, **kwargs_)
        else:
            return Timestamp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.Extension or
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Timestamp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Timestamp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Timestamp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Timestamp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Timestamp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Timestamp', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Timestamp', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for item_ in self.content_:
            item_.to_etree(element)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Timestamp'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'Extension', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_Extension'):
              self.add_Extension(obj_.value)
            elif hasattr(self, 'set_Extension'):
              self.set_Extension(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class Timestamp


class NaiveBayesModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, threshold=None, functionName=None, algorithmName=None, isScorable=True, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, BayesInputs=None, BayesOutput=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.threshold = _cast(None, threshold)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.ModelExplanation = ModelExplanation
        self.Targets = Targets
        self.LocalTransformations = LocalTransformations
        self.BayesInputs = BayesInputs
        self.BayesOutput = BayesOutput
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NaiveBayesModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NaiveBayesModel.subclass:
            return NaiveBayesModel.subclass(*args_, **kwargs_)
        else:
            return NaiveBayesModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_ModelExplanation(self): return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation): self.ModelExplanation = ModelExplanation
    def get_Targets(self): return self.Targets
    def set_Targets(self, Targets): self.Targets = Targets
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_BayesInputs(self): return self.BayesInputs
    def set_BayesInputs(self, BayesInputs): self.BayesInputs = BayesInputs
    def get_BayesOutput(self): return self.BayesOutput
    def set_BayesOutput(self, BayesOutput): self.BayesOutput = BayesOutput
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_threshold(self): return self.threshold
    def set_threshold(self, threshold): self.threshold = threshold
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.BayesInputs is not None or
            self.BayesOutput is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NaiveBayesModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NaiveBayesModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NaiveBayesModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NaiveBayesModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NaiveBayesModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.threshold is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            outfile.write(' threshold=%s' % (quote_attrib(self.threshold), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='NaiveBayesModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            self.ModelExplanation.export(outfile, level, namespace_, name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            self.Targets.export(outfile, level, namespace_, name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        if self.BayesInputs is not None:
            self.BayesInputs.export(outfile, level, namespace_, name_='BayesInputs', pretty_print=pretty_print)
        if self.BayesOutput is not None:
            self.BayesOutput.export(outfile, level, namespace_, name_='BayesOutput', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NaiveBayesModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.threshold is not None:
            element.set('threshold', self.threshold)
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.ModelExplanation is not None:
            ModelExplanation_ = self.ModelExplanation
            ModelExplanation_.to_etree(element, name_='ModelExplanation', mapping_=mapping_)
        if self.Targets is not None:
            Targets_ = self.Targets
            Targets_.to_etree(element, name_='Targets', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        if self.BayesInputs is not None:
            BayesInputs_ = self.BayesInputs
            BayesInputs_.to_etree(element, name_='BayesInputs', mapping_=mapping_)
        if self.BayesOutput is not None:
            BayesOutput_ = self.BayesOutput
            BayesOutput_.to_etree(element, name_='BayesOutput', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NaiveBayesModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.threshold is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            showIndent(outfile, level)
            outfile.write('threshold=%e,\n' % (self.threshold,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelExplanation is not None:
            showIndent(outfile, level)
            outfile.write('ModelExplanation=model_.ModelExplanation(\n')
            self.ModelExplanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targets is not None:
            showIndent(outfile, level)
            outfile.write('Targets=model_.Targets(\n')
            self.Targets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BayesInputs is not None:
            showIndent(outfile, level)
            outfile.write('BayesInputs=model_.BayesInputs(\n')
            self.BayesInputs.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BayesOutput is not None:
            showIndent(outfile, level)
            outfile.write('BayesOutput=model_.BayesOutput(\n')
            self.BayesOutput.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('threshold', node)
        if value is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            try:
                self.threshold = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (threshold): %s' % exp)
            self.validate_REAL_NUMBER(self.threshold)    # validate type REAL-NUMBER
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory()
            obj_.build(child_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory()
            obj_.build(child_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'BayesInputs':
            obj_ = BayesInputs.factory()
            obj_.build(child_)
            self.BayesInputs = obj_
            obj_.original_tagname_ = 'BayesInputs'
        elif nodeName_ == 'BayesOutput':
            obj_ = BayesOutput.factory()
            obj_.build(child_)
            self.BayesOutput = obj_
            obj_.original_tagname_ = 'BayesOutput'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class NaiveBayesModel


class BayesInputs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, BayesInput=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if BayesInput is None:
            self.BayesInput = []
        else:
            self.BayesInput = BayesInput
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BayesInputs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BayesInputs.subclass:
            return BayesInputs.subclass(*args_, **kwargs_)
        else:
            return BayesInputs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_BayesInput(self): return self.BayesInput
    def set_BayesInput(self, BayesInput): self.BayesInput = BayesInput
    def add_BayesInput(self, value): self.BayesInput.append(value)
    def insert_BayesInput_at(self, index, value): self.BayesInput.insert(index, value)
    def replace_BayesInput_at(self, index, value): self.BayesInput[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.BayesInput
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BayesInputs', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BayesInputs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BayesInputs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BayesInputs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BayesInputs'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BayesInputs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for BayesInput_ in self.BayesInput:
            BayesInput_.export(outfile, level, namespace_, name_='BayesInput', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BayesInputs', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for BayesInput_ in self.BayesInput:
            BayesInput_.to_etree(element, name_='BayesInput', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BayesInputs'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BayesInput=[\n')
        level += 1
        for BayesInput_ in self.BayesInput:
            showIndent(outfile, level)
            outfile.write('model_.BayesInput(\n')
            BayesInput_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'BayesInput':
            obj_ = BayesInput.factory()
            obj_.build(child_)
            self.BayesInput.append(obj_)
            obj_.original_tagname_ = 'BayesInput'
# end class BayesInputs


class BayesInput(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fieldName=None, Extension=None, TargetValueStats=None, DerivedField=None, PairCounts=None):
        self.original_tagname_ = None
        self.fieldName = _cast(None, fieldName)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.TargetValueStats = TargetValueStats
        self.DerivedField = DerivedField
        if PairCounts is None:
            self.PairCounts = []
        else:
            self.PairCounts = PairCounts
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BayesInput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BayesInput.subclass:
            return BayesInput.subclass(*args_, **kwargs_)
        else:
            return BayesInput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_TargetValueStats(self): return self.TargetValueStats
    def set_TargetValueStats(self, TargetValueStats): self.TargetValueStats = TargetValueStats
    def get_DerivedField(self): return self.DerivedField
    def set_DerivedField(self, DerivedField): self.DerivedField = DerivedField
    def get_PairCounts(self): return self.PairCounts
    def set_PairCounts(self, PairCounts): self.PairCounts = PairCounts
    def add_PairCounts(self, value): self.PairCounts.append(value)
    def insert_PairCounts_at(self, index, value): self.PairCounts.insert(index, value)
    def replace_PairCounts_at(self, index, value): self.PairCounts[index] = value
    def get_fieldName(self): return self.fieldName
    def set_fieldName(self, fieldName): self.fieldName = fieldName
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.TargetValueStats is not None or
            self.DerivedField is not None or
            self.PairCounts
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BayesInput', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BayesInput')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BayesInput')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BayesInput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BayesInput'):
        if self.fieldName is not None and 'fieldName' not in already_processed:
            already_processed.add('fieldName')
            outfile.write(' fieldName=%s' % (quote_attrib(self.fieldName), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BayesInput', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.TargetValueStats is not None:
            self.TargetValueStats.export(outfile, level, namespace_, name_='TargetValueStats', pretty_print=pretty_print)
        if self.DerivedField is not None:
            self.DerivedField.export(outfile, level, namespace_, name_='DerivedField', pretty_print=pretty_print)
        for PairCounts_ in self.PairCounts:
            PairCounts_.export(outfile, level, namespace_, name_='PairCounts', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BayesInput', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.fieldName is not None:
            element.set('fieldName', self.fieldName)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.TargetValueStats is not None:
            TargetValueStats_ = self.TargetValueStats
            TargetValueStats_.to_etree(element, name_='TargetValueStats', mapping_=mapping_)
        if self.DerivedField is not None:
            DerivedField_ = self.DerivedField
            DerivedField_.to_etree(element, name_='DerivedField', mapping_=mapping_)
        for PairCounts_ in self.PairCounts:
            PairCounts_.to_etree(element, name_='PairCounts', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BayesInput'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fieldName is not None and 'fieldName' not in already_processed:
            already_processed.add('fieldName')
            showIndent(outfile, level)
            outfile.write('fieldName="%s",\n' % (self.fieldName,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.TargetValueStats is not None:
            showIndent(outfile, level)
            outfile.write('TargetValueStats=model_.TargetValueStats(\n')
            self.TargetValueStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DerivedField is not None:
            showIndent(outfile, level)
            outfile.write('DerivedField=model_.DerivedField(\n')
            self.DerivedField.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('PairCounts=[\n')
        level += 1
        for PairCounts_ in self.PairCounts:
            showIndent(outfile, level)
            outfile.write('model_.PairCounts(\n')
            PairCounts_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fieldName', node)
        if value is not None and 'fieldName' not in already_processed:
            already_processed.add('fieldName')
            self.fieldName = value
            self.validate_FIELD_NAME(self.fieldName)    # validate type FIELD-NAME
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TargetValueStats':
            obj_ = TargetValueStats.factory()
            obj_.build(child_)
            self.TargetValueStats = obj_
            obj_.original_tagname_ = 'TargetValueStats'
        elif nodeName_ == 'DerivedField':
            obj_ = DerivedField.factory()
            obj_.build(child_)
            self.DerivedField = obj_
            obj_.original_tagname_ = 'DerivedField'
        elif nodeName_ == 'PairCounts':
            obj_ = PairCounts.factory()
            obj_.build(child_)
            self.PairCounts.append(obj_)
            obj_.original_tagname_ = 'PairCounts'
# end class BayesInput


class BayesOutput(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fieldName=None, Extension=None, TargetValueCounts=None):
        self.original_tagname_ = None
        self.fieldName = _cast(None, fieldName)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.TargetValueCounts = TargetValueCounts
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BayesOutput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BayesOutput.subclass:
            return BayesOutput.subclass(*args_, **kwargs_)
        else:
            return BayesOutput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_TargetValueCounts(self): return self.TargetValueCounts
    def set_TargetValueCounts(self, TargetValueCounts): self.TargetValueCounts = TargetValueCounts
    def get_fieldName(self): return self.fieldName
    def set_fieldName(self, fieldName): self.fieldName = fieldName
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.TargetValueCounts is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BayesOutput', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BayesOutput')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BayesOutput')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BayesOutput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BayesOutput'):
        if self.fieldName is not None and 'fieldName' not in already_processed:
            already_processed.add('fieldName')
            outfile.write(' fieldName=%s' % (quote_attrib(self.fieldName), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BayesOutput', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.TargetValueCounts is not None:
            self.TargetValueCounts.export(outfile, level, namespace_, name_='TargetValueCounts', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BayesOutput', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.fieldName is not None:
            element.set('fieldName', self.fieldName)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.TargetValueCounts is not None:
            TargetValueCounts_ = self.TargetValueCounts
            TargetValueCounts_.to_etree(element, name_='TargetValueCounts', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BayesOutput'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fieldName is not None and 'fieldName' not in already_processed:
            already_processed.add('fieldName')
            showIndent(outfile, level)
            outfile.write('fieldName="%s",\n' % (self.fieldName,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.TargetValueCounts is not None:
            showIndent(outfile, level)
            outfile.write('TargetValueCounts=model_.TargetValueCounts(\n')
            self.TargetValueCounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fieldName', node)
        if value is not None and 'fieldName' not in already_processed:
            already_processed.add('fieldName')
            self.fieldName = value
            self.validate_FIELD_NAME(self.fieldName)    # validate type FIELD-NAME
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TargetValueCounts':
            obj_ = TargetValueCounts.factory()
            obj_.build(child_)
            self.TargetValueCounts = obj_
            obj_.original_tagname_ = 'TargetValueCounts'
# end class BayesOutput


class TargetValueStats(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, TargetValueStat=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if TargetValueStat is None:
            self.TargetValueStat = []
        else:
            self.TargetValueStat = TargetValueStat
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetValueStats)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetValueStats.subclass:
            return TargetValueStats.subclass(*args_, **kwargs_)
        else:
            return TargetValueStats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_TargetValueStat(self): return self.TargetValueStat
    def set_TargetValueStat(self, TargetValueStat): self.TargetValueStat = TargetValueStat
    def add_TargetValueStat(self, value): self.TargetValueStat.append(value)
    def insert_TargetValueStat_at(self, index, value): self.TargetValueStat.insert(index, value)
    def replace_TargetValueStat_at(self, index, value): self.TargetValueStat[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.TargetValueStat
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TargetValueStats', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TargetValueStats')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetValueStats')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TargetValueStats', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TargetValueStats'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TargetValueStats', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for TargetValueStat_ in self.TargetValueStat:
            TargetValueStat_.export(outfile, level, namespace_, name_='TargetValueStat', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TargetValueStats', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for TargetValueStat_ in self.TargetValueStat:
            TargetValueStat_.to_etree(element, name_='TargetValueStat', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TargetValueStats'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TargetValueStat=[\n')
        level += 1
        for TargetValueStat_ in self.TargetValueStat:
            showIndent(outfile, level)
            outfile.write('model_.TargetValueStat(\n')
            TargetValueStat_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TargetValueStat':
            obj_ = TargetValueStat.factory()
            obj_.build(child_)
            self.TargetValueStat.append(obj_)
            obj_.original_tagname_ = 'TargetValueStat'
# end class TargetValueStats


class TargetValueStat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, Extension=None, AnyDistribution=None, GaussianDistribution=None, PoissonDistribution=None, UniformDistribution=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.AnyDistribution = AnyDistribution
        self.GaussianDistribution = GaussianDistribution
        self.PoissonDistribution = PoissonDistribution
        self.UniformDistribution = UniformDistribution
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetValueStat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetValueStat.subclass:
            return TargetValueStat.subclass(*args_, **kwargs_)
        else:
            return TargetValueStat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_AnyDistribution(self): return self.AnyDistribution
    def set_AnyDistribution(self, AnyDistribution): self.AnyDistribution = AnyDistribution
    def get_GaussianDistribution(self): return self.GaussianDistribution
    def set_GaussianDistribution(self, GaussianDistribution): self.GaussianDistribution = GaussianDistribution
    def get_PoissonDistribution(self): return self.PoissonDistribution
    def set_PoissonDistribution(self, PoissonDistribution): self.PoissonDistribution = PoissonDistribution
    def get_UniformDistribution(self): return self.UniformDistribution
    def set_UniformDistribution(self, UniformDistribution): self.UniformDistribution = UniformDistribution
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.Extension or
            self.AnyDistribution is not None or
            self.GaussianDistribution is not None or
            self.PoissonDistribution is not None or
            self.UniformDistribution is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TargetValueStat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TargetValueStat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetValueStat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TargetValueStat', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TargetValueStat'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TargetValueStat', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.AnyDistribution is not None:
            self.AnyDistribution.export(outfile, level, namespace_, name_='AnyDistribution', pretty_print=pretty_print)
        if self.GaussianDistribution is not None:
            self.GaussianDistribution.export(outfile, level, namespace_, name_='GaussianDistribution', pretty_print=pretty_print)
        if self.PoissonDistribution is not None:
            self.PoissonDistribution.export(outfile, level, namespace_, name_='PoissonDistribution', pretty_print=pretty_print)
        if self.UniformDistribution is not None:
            self.UniformDistribution.export(outfile, level, namespace_, name_='UniformDistribution', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TargetValueStat', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.AnyDistribution is not None:
            AnyDistribution_ = self.AnyDistribution
            AnyDistribution_.to_etree(element, name_='AnyDistribution', mapping_=mapping_)
        if self.GaussianDistribution is not None:
            GaussianDistribution_ = self.GaussianDistribution
            GaussianDistribution_.to_etree(element, name_='GaussianDistribution', mapping_=mapping_)
        if self.PoissonDistribution is not None:
            PoissonDistribution_ = self.PoissonDistribution
            PoissonDistribution_.to_etree(element, name_='PoissonDistribution', mapping_=mapping_)
        if self.UniformDistribution is not None:
            UniformDistribution_ = self.UniformDistribution
            UniformDistribution_.to_etree(element, name_='UniformDistribution', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TargetValueStat'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.AnyDistribution is not None:
            showIndent(outfile, level)
            outfile.write('AnyDistribution=model_.AnyDistribution(\n')
            self.AnyDistribution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GaussianDistribution is not None:
            showIndent(outfile, level)
            outfile.write('GaussianDistribution=model_.GaussianDistribution(\n')
            self.GaussianDistribution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PoissonDistribution is not None:
            showIndent(outfile, level)
            outfile.write('PoissonDistribution=model_.PoissonDistribution(\n')
            self.PoissonDistribution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.UniformDistribution is not None:
            showIndent(outfile, level)
            outfile.write('UniformDistribution=model_.UniformDistribution(\n')
            self.UniformDistribution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'AnyDistribution':
            obj_ = AnyDistribution.factory()
            obj_.build(child_)
            self.AnyDistribution = obj_
            obj_.original_tagname_ = 'AnyDistribution'
        elif nodeName_ == 'GaussianDistribution':
            obj_ = GaussianDistribution.factory()
            obj_.build(child_)
            self.GaussianDistribution = obj_
            obj_.original_tagname_ = 'GaussianDistribution'
        elif nodeName_ == 'PoissonDistribution':
            obj_ = PoissonDistribution.factory()
            obj_.build(child_)
            self.PoissonDistribution = obj_
            obj_.original_tagname_ = 'PoissonDistribution'
        elif nodeName_ == 'UniformDistribution':
            obj_ = UniformDistribution.factory()
            obj_.build(child_)
            self.UniformDistribution = obj_
            obj_.original_tagname_ = 'UniformDistribution'
# end class TargetValueStat


class PairCounts(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, Extension=None, TargetValueCounts=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.TargetValueCounts = TargetValueCounts
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PairCounts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PairCounts.subclass:
            return PairCounts.subclass(*args_, **kwargs_)
        else:
            return PairCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_TargetValueCounts(self): return self.TargetValueCounts
    def set_TargetValueCounts(self, TargetValueCounts): self.TargetValueCounts = TargetValueCounts
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.Extension or
            self.TargetValueCounts is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PairCounts', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PairCounts')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PairCounts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PairCounts', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PairCounts'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PairCounts', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.TargetValueCounts is not None:
            self.TargetValueCounts.export(outfile, level, namespace_, name_='TargetValueCounts', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PairCounts', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.TargetValueCounts is not None:
            TargetValueCounts_ = self.TargetValueCounts
            TargetValueCounts_.to_etree(element, name_='TargetValueCounts', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PairCounts'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.TargetValueCounts is not None:
            showIndent(outfile, level)
            outfile.write('TargetValueCounts=model_.TargetValueCounts(\n')
            self.TargetValueCounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TargetValueCounts':
            obj_ = TargetValueCounts.factory()
            obj_.build(child_)
            self.TargetValueCounts = obj_
            obj_.original_tagname_ = 'TargetValueCounts'
# end class PairCounts


class TargetValueCounts(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, TargetValueCount=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if TargetValueCount is None:
            self.TargetValueCount = []
        else:
            self.TargetValueCount = TargetValueCount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetValueCounts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetValueCounts.subclass:
            return TargetValueCounts.subclass(*args_, **kwargs_)
        else:
            return TargetValueCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_TargetValueCount(self): return self.TargetValueCount
    def set_TargetValueCount(self, TargetValueCount): self.TargetValueCount = TargetValueCount
    def add_TargetValueCount(self, value): self.TargetValueCount.append(value)
    def insert_TargetValueCount_at(self, index, value): self.TargetValueCount.insert(index, value)
    def replace_TargetValueCount_at(self, index, value): self.TargetValueCount[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.TargetValueCount
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TargetValueCounts', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TargetValueCounts')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetValueCounts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TargetValueCounts', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TargetValueCounts'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TargetValueCounts', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for TargetValueCount_ in self.TargetValueCount:
            TargetValueCount_.export(outfile, level, namespace_, name_='TargetValueCount', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TargetValueCounts', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for TargetValueCount_ in self.TargetValueCount:
            TargetValueCount_.to_etree(element, name_='TargetValueCount', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TargetValueCounts'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TargetValueCount=[\n')
        level += 1
        for TargetValueCount_ in self.TargetValueCount:
            showIndent(outfile, level)
            outfile.write('model_.TargetValueCount(\n')
            TargetValueCount_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TargetValueCount':
            obj_ = TargetValueCount.factory()
            obj_.build(child_)
            self.TargetValueCount.append(obj_)
            obj_.original_tagname_ = 'TargetValueCount'
# end class TargetValueCounts


class TargetValueCount(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, count=None, Extension=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.count = _cast(None, count)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetValueCount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetValueCount.subclass:
            return TargetValueCount.subclass(*args_, **kwargs_)
        else:
            return TargetValueCount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TargetValueCount', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TargetValueCount')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetValueCount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TargetValueCount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TargetValueCount'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count=%s' % (quote_attrib(self.count), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TargetValueCount', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TargetValueCount', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.count is not None:
            element.set('count', self.count)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TargetValueCount'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%e,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (count): %s' % exp)
            self.validate_REAL_NUMBER(self.count)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class TargetValueCount


class BaselineModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, isScorable=True, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, TestDistributions=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.ModelExplanation = ModelExplanation
        self.Targets = Targets
        self.LocalTransformations = LocalTransformations
        self.TestDistributions = TestDistributions
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaselineModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaselineModel.subclass:
            return BaselineModel.subclass(*args_, **kwargs_)
        else:
            return BaselineModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_ModelExplanation(self): return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation): self.ModelExplanation = ModelExplanation
    def get_Targets(self): return self.Targets
    def set_Targets(self, Targets): self.Targets = Targets
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_TestDistributions(self): return self.TestDistributions
    def set_TestDistributions(self, TestDistributions): self.TestDistributions = TestDistributions
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.TestDistributions is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BaselineModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaselineModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BaselineModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BaselineModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BaselineModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='BaselineModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            self.ModelExplanation.export(outfile, level, namespace_, name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            self.Targets.export(outfile, level, namespace_, name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        if self.TestDistributions is not None:
            self.TestDistributions.export(outfile, level, namespace_, name_='TestDistributions', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BaselineModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.ModelExplanation is not None:
            ModelExplanation_ = self.ModelExplanation
            ModelExplanation_.to_etree(element, name_='ModelExplanation', mapping_=mapping_)
        if self.Targets is not None:
            Targets_ = self.Targets
            Targets_.to_etree(element, name_='Targets', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        if self.TestDistributions is not None:
            TestDistributions_ = self.TestDistributions
            TestDistributions_.to_etree(element, name_='TestDistributions', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BaselineModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelExplanation is not None:
            showIndent(outfile, level)
            outfile.write('ModelExplanation=model_.ModelExplanation(\n')
            self.ModelExplanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targets is not None:
            showIndent(outfile, level)
            outfile.write('Targets=model_.Targets(\n')
            self.Targets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TestDistributions is not None:
            showIndent(outfile, level)
            outfile.write('TestDistributions=model_.TestDistributions(\n')
            self.TestDistributions.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory()
            obj_.build(child_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory()
            obj_.build(child_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'TestDistributions':
            obj_ = TestDistributions.factory()
            obj_.build(child_)
            self.TestDistributions = obj_
            obj_.original_tagname_ = 'TestDistributions'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class BaselineModel


class TestDistributions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, testStatistic=None, resetValue='0.0', windowSize='0', weightField=None, normalizationScheme=None, Extension=None, Baseline=None, Alternate=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.testStatistic = _cast(None, testStatistic)
        self.resetValue = _cast(None, resetValue)
        self.windowSize = _cast(None, windowSize)
        self.weightField = _cast(None, weightField)
        self.normalizationScheme = _cast(None, normalizationScheme)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Baseline = Baseline
        self.Alternate = Alternate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TestDistributions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TestDistributions.subclass:
            return TestDistributions.subclass(*args_, **kwargs_)
        else:
            return TestDistributions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Baseline(self): return self.Baseline
    def set_Baseline(self, Baseline): self.Baseline = Baseline
    def get_Alternate(self): return self.Alternate
    def set_Alternate(self, Alternate): self.Alternate = Alternate
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_testStatistic(self): return self.testStatistic
    def set_testStatistic(self, testStatistic): self.testStatistic = testStatistic
    def get_resetValue(self): return self.resetValue
    def set_resetValue(self, resetValue): self.resetValue = resetValue
    def get_windowSize(self): return self.windowSize
    def set_windowSize(self, windowSize): self.windowSize = windowSize
    def get_weightField(self): return self.weightField
    def set_weightField(self, weightField): self.weightField = weightField
    def get_normalizationScheme(self): return self.normalizationScheme
    def set_normalizationScheme(self, normalizationScheme): self.normalizationScheme = normalizationScheme
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_BASELINE_TEST_STATISTIC(self, value):
        # Validate type BASELINE-TEST-STATISTIC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['zValue', 'chiSquareIndependence', 'chiSquareDistribution', 'CUSUM', 'scalarProduct']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BASELINE-TEST-STATISTIC' % {"value" : value.encode("utf-8")} )
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Baseline is not None or
            self.Alternate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TestDistributions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TestDistributions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TestDistributions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TestDistributions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TestDistributions'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.testStatistic is not None and 'testStatistic' not in already_processed:
            already_processed.add('testStatistic')
            outfile.write(' testStatistic=%s' % (quote_attrib(self.testStatistic), ))
        if self.resetValue != 0.0 and 'resetValue' not in already_processed:
            already_processed.add('resetValue')
            outfile.write(' resetValue=%s' % (quote_attrib(self.resetValue), ))
        if self.windowSize != 0 and 'windowSize' not in already_processed:
            already_processed.add('windowSize')
            outfile.write(' windowSize=%s' % (quote_attrib(self.windowSize), ))
        if self.weightField is not None and 'weightField' not in already_processed:
            already_processed.add('weightField')
            outfile.write(' weightField=%s' % (quote_attrib(self.weightField), ))
        if self.normalizationScheme is not None and 'normalizationScheme' not in already_processed:
            already_processed.add('normalizationScheme')
            outfile.write(' normalizationScheme=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.normalizationScheme), input_name='normalizationScheme')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TestDistributions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Baseline is not None:
            self.Baseline.export(outfile, level, namespace_, name_='Baseline', pretty_print=pretty_print)
        if self.Alternate is not None:
            self.Alternate.export(outfile, level, namespace_, name_='Alternate', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TestDistributions', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.testStatistic is not None:
            element.set('testStatistic', self.testStatistic)
        if self.resetValue is not None:
            element.set('resetValue', self.resetValue)
        if self.windowSize is not None:
            element.set('windowSize', self.windowSize)
        if self.weightField is not None:
            element.set('weightField', self.weightField)
        if self.normalizationScheme is not None:
            element.set('normalizationScheme', self.gds_format_string(self.normalizationScheme))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Baseline is not None:
            Baseline_ = self.Baseline
            Baseline_.to_etree(element, name_='Baseline', mapping_=mapping_)
        if self.Alternate is not None:
            Alternate_ = self.Alternate
            Alternate_.to_etree(element, name_='Alternate', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TestDistributions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.testStatistic is not None and 'testStatistic' not in already_processed:
            already_processed.add('testStatistic')
            showIndent(outfile, level)
            outfile.write('testStatistic="%s",\n' % (self.testStatistic,))
        if self.resetValue is not None and 'resetValue' not in already_processed:
            already_processed.add('resetValue')
            showIndent(outfile, level)
            outfile.write('resetValue=%e,\n' % (self.resetValue,))
        if self.windowSize is not None and 'windowSize' not in already_processed:
            already_processed.add('windowSize')
            showIndent(outfile, level)
            outfile.write('windowSize=%d,\n' % (self.windowSize,))
        if self.weightField is not None and 'weightField' not in already_processed:
            already_processed.add('weightField')
            showIndent(outfile, level)
            outfile.write('weightField="%s",\n' % (self.weightField,))
        if self.normalizationScheme is not None and 'normalizationScheme' not in already_processed:
            already_processed.add('normalizationScheme')
            showIndent(outfile, level)
            outfile.write('normalizationScheme="%s",\n' % (self.normalizationScheme,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Baseline is not None:
            showIndent(outfile, level)
            outfile.write('Baseline=model_.Baseline(\n')
            self.Baseline.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Alternate is not None:
            showIndent(outfile, level)
            outfile.write('Alternate=model_.Alternate(\n')
            self.Alternate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('testStatistic', node)
        if value is not None and 'testStatistic' not in already_processed:
            already_processed.add('testStatistic')
            self.testStatistic = value
            self.validate_BASELINE_TEST_STATISTIC(self.testStatistic)    # validate type BASELINE-TEST-STATISTIC
        value = find_attr_value_('resetValue', node)
        if value is not None and 'resetValue' not in already_processed:
            already_processed.add('resetValue')
            try:
                self.resetValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (resetValue): %s' % exp)
            self.validate_REAL_NUMBER(self.resetValue)    # validate type REAL-NUMBER
        value = find_attr_value_('windowSize', node)
        if value is not None and 'windowSize' not in already_processed:
            already_processed.add('windowSize')
            try:
                self.windowSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.windowSize)    # validate type INT-NUMBER
        value = find_attr_value_('weightField', node)
        if value is not None and 'weightField' not in already_processed:
            already_processed.add('weightField')
            self.weightField = value
            self.validate_FIELD_NAME(self.weightField)    # validate type FIELD-NAME
        value = find_attr_value_('normalizationScheme', node)
        if value is not None and 'normalizationScheme' not in already_processed:
            already_processed.add('normalizationScheme')
            self.normalizationScheme = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Baseline':
            obj_ = Baseline.factory()
            obj_.build(child_)
            self.Baseline = obj_
            obj_.original_tagname_ = 'Baseline'
        elif nodeName_ == 'Alternate':
            obj_ = Alternate.factory()
            obj_.build(child_)
            self.Alternate = obj_
            obj_.original_tagname_ = 'Alternate'
# end class TestDistributions


class Baseline(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AnyDistribution=None, GaussianDistribution=None, PoissonDistribution=None, UniformDistribution=None, CountTable=None, NormalizedCountTable=None, FieldRef=None):
        self.original_tagname_ = None
        self.AnyDistribution = AnyDistribution
        self.GaussianDistribution = GaussianDistribution
        self.PoissonDistribution = PoissonDistribution
        self.UniformDistribution = UniformDistribution
        self.CountTable = CountTable
        self.NormalizedCountTable = NormalizedCountTable
        if FieldRef is None:
            self.FieldRef = []
        else:
            self.FieldRef = FieldRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Baseline)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Baseline.subclass:
            return Baseline.subclass(*args_, **kwargs_)
        else:
            return Baseline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AnyDistribution(self): return self.AnyDistribution
    def set_AnyDistribution(self, AnyDistribution): self.AnyDistribution = AnyDistribution
    def get_GaussianDistribution(self): return self.GaussianDistribution
    def set_GaussianDistribution(self, GaussianDistribution): self.GaussianDistribution = GaussianDistribution
    def get_PoissonDistribution(self): return self.PoissonDistribution
    def set_PoissonDistribution(self, PoissonDistribution): self.PoissonDistribution = PoissonDistribution
    def get_UniformDistribution(self): return self.UniformDistribution
    def set_UniformDistribution(self, UniformDistribution): self.UniformDistribution = UniformDistribution
    def get_CountTable(self): return self.CountTable
    def set_CountTable(self, CountTable): self.CountTable = CountTable
    def get_NormalizedCountTable(self): return self.NormalizedCountTable
    def set_NormalizedCountTable(self, NormalizedCountTable): self.NormalizedCountTable = NormalizedCountTable
    def get_FieldRef(self): return self.FieldRef
    def set_FieldRef(self, FieldRef): self.FieldRef = FieldRef
    def add_FieldRef(self, value): self.FieldRef.append(value)
    def insert_FieldRef_at(self, index, value): self.FieldRef.insert(index, value)
    def replace_FieldRef_at(self, index, value): self.FieldRef[index] = value
    def hasContent_(self):
        if (
            self.AnyDistribution is not None or
            self.GaussianDistribution is not None or
            self.PoissonDistribution is not None or
            self.UniformDistribution is not None or
            self.CountTable is not None or
            self.NormalizedCountTable is not None or
            self.FieldRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Baseline', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Baseline')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Baseline')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Baseline', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Baseline'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Baseline', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AnyDistribution is not None:
            self.AnyDistribution.export(outfile, level, namespace_, name_='AnyDistribution', pretty_print=pretty_print)
        if self.GaussianDistribution is not None:
            self.GaussianDistribution.export(outfile, level, namespace_, name_='GaussianDistribution', pretty_print=pretty_print)
        if self.PoissonDistribution is not None:
            self.PoissonDistribution.export(outfile, level, namespace_, name_='PoissonDistribution', pretty_print=pretty_print)
        if self.UniformDistribution is not None:
            self.UniformDistribution.export(outfile, level, namespace_, name_='UniformDistribution', pretty_print=pretty_print)
        if self.CountTable is not None:
            self.CountTable.export(outfile, level, namespace_, name_='CountTable', pretty_print=pretty_print)
        if self.NormalizedCountTable is not None:
            self.NormalizedCountTable.export(outfile, level, namespace_, name_='NormalizedCountTable', pretty_print=pretty_print)
        for FieldRef_ in self.FieldRef:
            FieldRef_.export(outfile, level, namespace_, name_='FieldRef', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Baseline', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.AnyDistribution is not None:
            AnyDistribution_ = self.AnyDistribution
            AnyDistribution_.to_etree(element, name_='AnyDistribution', mapping_=mapping_)
        if self.GaussianDistribution is not None:
            GaussianDistribution_ = self.GaussianDistribution
            GaussianDistribution_.to_etree(element, name_='GaussianDistribution', mapping_=mapping_)
        if self.PoissonDistribution is not None:
            PoissonDistribution_ = self.PoissonDistribution
            PoissonDistribution_.to_etree(element, name_='PoissonDistribution', mapping_=mapping_)
        if self.UniformDistribution is not None:
            UniformDistribution_ = self.UniformDistribution
            UniformDistribution_.to_etree(element, name_='UniformDistribution', mapping_=mapping_)
        if self.CountTable is not None:
            CountTable_ = self.CountTable
            CountTable_.to_etree(element, name_='CountTable', mapping_=mapping_)
        if self.NormalizedCountTable is not None:
            NormalizedCountTable_ = self.NormalizedCountTable
            NormalizedCountTable_.to_etree(element, name_='NormalizedCountTable', mapping_=mapping_)
        for FieldRef_ in self.FieldRef:
            FieldRef_.to_etree(element, name_='FieldRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Baseline'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AnyDistribution is not None:
            showIndent(outfile, level)
            outfile.write('AnyDistribution=model_.AnyDistribution(\n')
            self.AnyDistribution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GaussianDistribution is not None:
            showIndent(outfile, level)
            outfile.write('GaussianDistribution=model_.GaussianDistribution(\n')
            self.GaussianDistribution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PoissonDistribution is not None:
            showIndent(outfile, level)
            outfile.write('PoissonDistribution=model_.PoissonDistribution(\n')
            self.PoissonDistribution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.UniformDistribution is not None:
            showIndent(outfile, level)
            outfile.write('UniformDistribution=model_.UniformDistribution(\n')
            self.UniformDistribution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CountTable is not None:
            showIndent(outfile, level)
            outfile.write('CountTable=model_.CountTable(\n')
            self.CountTable.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormalizedCountTable is not None:
            showIndent(outfile, level)
            outfile.write('NormalizedCountTable=model_.NormalizedCountTable(\n')
            self.NormalizedCountTable.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('FieldRef=[\n')
        level += 1
        for FieldRef_ in self.FieldRef:
            showIndent(outfile, level)
            outfile.write('model_.FieldRef(\n')
            FieldRef_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AnyDistribution':
            obj_ = AnyDistribution.factory()
            obj_.build(child_)
            self.AnyDistribution = obj_
            obj_.original_tagname_ = 'AnyDistribution'
        elif nodeName_ == 'GaussianDistribution':
            obj_ = GaussianDistribution.factory()
            obj_.build(child_)
            self.GaussianDistribution = obj_
            obj_.original_tagname_ = 'GaussianDistribution'
        elif nodeName_ == 'PoissonDistribution':
            obj_ = PoissonDistribution.factory()
            obj_.build(child_)
            self.PoissonDistribution = obj_
            obj_.original_tagname_ = 'PoissonDistribution'
        elif nodeName_ == 'UniformDistribution':
            obj_ = UniformDistribution.factory()
            obj_.build(child_)
            self.UniformDistribution = obj_
            obj_.original_tagname_ = 'UniformDistribution'
        elif nodeName_ == 'CountTable':
            obj_ = COUNT_TABLE_TYPE.factory()
            obj_.build(child_)
            self.CountTable = obj_
            obj_.original_tagname_ = 'CountTable'
        elif nodeName_ == 'NormalizedCountTable':
            obj_ = COUNT_TABLE_TYPE.factory()
            obj_.build(child_)
            self.NormalizedCountTable = obj_
            obj_.original_tagname_ = 'NormalizedCountTable'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory()
            obj_.build(child_)
            self.FieldRef.append(obj_)
            obj_.original_tagname_ = 'FieldRef'
# end class Baseline


class Alternate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AnyDistribution=None, GaussianDistribution=None, PoissonDistribution=None, UniformDistribution=None):
        self.original_tagname_ = None
        self.AnyDistribution = AnyDistribution
        self.GaussianDistribution = GaussianDistribution
        self.PoissonDistribution = PoissonDistribution
        self.UniformDistribution = UniformDistribution
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Alternate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Alternate.subclass:
            return Alternate.subclass(*args_, **kwargs_)
        else:
            return Alternate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AnyDistribution(self): return self.AnyDistribution
    def set_AnyDistribution(self, AnyDistribution): self.AnyDistribution = AnyDistribution
    def get_GaussianDistribution(self): return self.GaussianDistribution
    def set_GaussianDistribution(self, GaussianDistribution): self.GaussianDistribution = GaussianDistribution
    def get_PoissonDistribution(self): return self.PoissonDistribution
    def set_PoissonDistribution(self, PoissonDistribution): self.PoissonDistribution = PoissonDistribution
    def get_UniformDistribution(self): return self.UniformDistribution
    def set_UniformDistribution(self, UniformDistribution): self.UniformDistribution = UniformDistribution
    def hasContent_(self):
        if (
            self.AnyDistribution is not None or
            self.GaussianDistribution is not None or
            self.PoissonDistribution is not None or
            self.UniformDistribution is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Alternate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Alternate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Alternate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Alternate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Alternate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Alternate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AnyDistribution is not None:
            self.AnyDistribution.export(outfile, level, namespace_, name_='AnyDistribution', pretty_print=pretty_print)
        if self.GaussianDistribution is not None:
            self.GaussianDistribution.export(outfile, level, namespace_, name_='GaussianDistribution', pretty_print=pretty_print)
        if self.PoissonDistribution is not None:
            self.PoissonDistribution.export(outfile, level, namespace_, name_='PoissonDistribution', pretty_print=pretty_print)
        if self.UniformDistribution is not None:
            self.UniformDistribution.export(outfile, level, namespace_, name_='UniformDistribution', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Alternate', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.AnyDistribution is not None:
            AnyDistribution_ = self.AnyDistribution
            AnyDistribution_.to_etree(element, name_='AnyDistribution', mapping_=mapping_)
        if self.GaussianDistribution is not None:
            GaussianDistribution_ = self.GaussianDistribution
            GaussianDistribution_.to_etree(element, name_='GaussianDistribution', mapping_=mapping_)
        if self.PoissonDistribution is not None:
            PoissonDistribution_ = self.PoissonDistribution
            PoissonDistribution_.to_etree(element, name_='PoissonDistribution', mapping_=mapping_)
        if self.UniformDistribution is not None:
            UniformDistribution_ = self.UniformDistribution
            UniformDistribution_.to_etree(element, name_='UniformDistribution', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Alternate'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AnyDistribution is not None:
            showIndent(outfile, level)
            outfile.write('AnyDistribution=model_.AnyDistribution(\n')
            self.AnyDistribution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GaussianDistribution is not None:
            showIndent(outfile, level)
            outfile.write('GaussianDistribution=model_.GaussianDistribution(\n')
            self.GaussianDistribution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PoissonDistribution is not None:
            showIndent(outfile, level)
            outfile.write('PoissonDistribution=model_.PoissonDistribution(\n')
            self.PoissonDistribution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.UniformDistribution is not None:
            showIndent(outfile, level)
            outfile.write('UniformDistribution=model_.UniformDistribution(\n')
            self.UniformDistribution.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AnyDistribution':
            obj_ = AnyDistribution.factory()
            obj_.build(child_)
            self.AnyDistribution = obj_
            obj_.original_tagname_ = 'AnyDistribution'
        elif nodeName_ == 'GaussianDistribution':
            obj_ = GaussianDistribution.factory()
            obj_.build(child_)
            self.GaussianDistribution = obj_
            obj_.original_tagname_ = 'GaussianDistribution'
        elif nodeName_ == 'PoissonDistribution':
            obj_ = PoissonDistribution.factory()
            obj_.build(child_)
            self.PoissonDistribution = obj_
            obj_.original_tagname_ = 'PoissonDistribution'
        elif nodeName_ == 'UniformDistribution':
            obj_ = UniformDistribution.factory()
            obj_.build(child_)
            self.UniformDistribution = obj_
            obj_.original_tagname_ = 'UniformDistribution'
# end class Alternate


class AnyDistribution(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mean=None, variance=None, Extension=None):
        self.original_tagname_ = None
        self.mean = _cast(None, mean)
        self.variance = _cast(None, variance)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnyDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnyDistribution.subclass:
            return AnyDistribution.subclass(*args_, **kwargs_)
        else:
            return AnyDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_mean(self): return self.mean
    def set_mean(self, mean): self.mean = mean
    def get_variance(self): return self.variance
    def set_variance(self, variance): self.variance = variance
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AnyDistribution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AnyDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnyDistribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AnyDistribution', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AnyDistribution'):
        if self.mean is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            outfile.write(' mean=%s' % (quote_attrib(self.mean), ))
        if self.variance is not None and 'variance' not in already_processed:
            already_processed.add('variance')
            outfile.write(' variance=%s' % (quote_attrib(self.variance), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AnyDistribution', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AnyDistribution', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.mean is not None:
            element.set('mean', self.mean)
        if self.variance is not None:
            element.set('variance', self.variance)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='AnyDistribution'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mean is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            showIndent(outfile, level)
            outfile.write('mean=%e,\n' % (self.mean,))
        if self.variance is not None and 'variance' not in already_processed:
            already_processed.add('variance')
            showIndent(outfile, level)
            outfile.write('variance=%e,\n' % (self.variance,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mean', node)
        if value is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            try:
                self.mean = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (mean): %s' % exp)
            self.validate_REAL_NUMBER(self.mean)    # validate type REAL-NUMBER
        value = find_attr_value_('variance', node)
        if value is not None and 'variance' not in already_processed:
            already_processed.add('variance')
            try:
                self.variance = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (variance): %s' % exp)
            self.validate_REAL_NUMBER(self.variance)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class AnyDistribution


class GaussianDistribution(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mean=None, variance=None, Extension=None):
        self.original_tagname_ = None
        self.mean = _cast(None, mean)
        self.variance = _cast(None, variance)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GaussianDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GaussianDistribution.subclass:
            return GaussianDistribution.subclass(*args_, **kwargs_)
        else:
            return GaussianDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_mean(self): return self.mean
    def set_mean(self, mean): self.mean = mean
    def get_variance(self): return self.variance
    def set_variance(self, variance): self.variance = variance
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GaussianDistribution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GaussianDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GaussianDistribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GaussianDistribution', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GaussianDistribution'):
        if self.mean is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            outfile.write(' mean=%s' % (quote_attrib(self.mean), ))
        if self.variance is not None and 'variance' not in already_processed:
            already_processed.add('variance')
            outfile.write(' variance=%s' % (quote_attrib(self.variance), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GaussianDistribution', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GaussianDistribution', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.mean is not None:
            element.set('mean', self.mean)
        if self.variance is not None:
            element.set('variance', self.variance)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='GaussianDistribution'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mean is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            showIndent(outfile, level)
            outfile.write('mean=%e,\n' % (self.mean,))
        if self.variance is not None and 'variance' not in already_processed:
            already_processed.add('variance')
            showIndent(outfile, level)
            outfile.write('variance=%e,\n' % (self.variance,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mean', node)
        if value is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            try:
                self.mean = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (mean): %s' % exp)
            self.validate_REAL_NUMBER(self.mean)    # validate type REAL-NUMBER
        value = find_attr_value_('variance', node)
        if value is not None and 'variance' not in already_processed:
            already_processed.add('variance')
            try:
                self.variance = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (variance): %s' % exp)
            self.validate_REAL_NUMBER(self.variance)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class GaussianDistribution


class PoissonDistribution(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mean=None, Extension=None):
        self.original_tagname_ = None
        self.mean = _cast(None, mean)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PoissonDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PoissonDistribution.subclass:
            return PoissonDistribution.subclass(*args_, **kwargs_)
        else:
            return PoissonDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_mean(self): return self.mean
    def set_mean(self, mean): self.mean = mean
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PoissonDistribution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PoissonDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PoissonDistribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PoissonDistribution', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PoissonDistribution'):
        if self.mean is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            outfile.write(' mean=%s' % (quote_attrib(self.mean), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PoissonDistribution', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PoissonDistribution', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.mean is not None:
            element.set('mean', self.mean)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='PoissonDistribution'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mean is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            showIndent(outfile, level)
            outfile.write('mean=%e,\n' % (self.mean,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mean', node)
        if value is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            try:
                self.mean = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (mean): %s' % exp)
            self.validate_REAL_NUMBER(self.mean)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class PoissonDistribution


class UniformDistribution(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lower=None, upper=None, Extension=None):
        self.original_tagname_ = None
        self.lower = _cast(None, lower)
        self.upper = _cast(None, upper)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UniformDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UniformDistribution.subclass:
            return UniformDistribution.subclass(*args_, **kwargs_)
        else:
            return UniformDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_lower(self): return self.lower
    def set_lower(self, lower): self.lower = lower
    def get_upper(self): return self.upper
    def set_upper(self, upper): self.upper = upper
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UniformDistribution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UniformDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UniformDistribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UniformDistribution', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UniformDistribution'):
        if self.lower is not None and 'lower' not in already_processed:
            already_processed.add('lower')
            outfile.write(' lower=%s' % (quote_attrib(self.lower), ))
        if self.upper is not None and 'upper' not in already_processed:
            already_processed.add('upper')
            outfile.write(' upper=%s' % (quote_attrib(self.upper), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UniformDistribution', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='UniformDistribution', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.lower is not None:
            element.set('lower', self.lower)
        if self.upper is not None:
            element.set('upper', self.upper)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UniformDistribution'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lower is not None and 'lower' not in already_processed:
            already_processed.add('lower')
            showIndent(outfile, level)
            outfile.write('lower=%e,\n' % (self.lower,))
        if self.upper is not None and 'upper' not in already_processed:
            already_processed.add('upper')
            showIndent(outfile, level)
            outfile.write('upper=%e,\n' % (self.upper,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lower', node)
        if value is not None and 'lower' not in already_processed:
            already_processed.add('lower')
            try:
                self.lower = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lower): %s' % exp)
            self.validate_REAL_NUMBER(self.lower)    # validate type REAL-NUMBER
        value = find_attr_value_('upper', node)
        if value is not None and 'upper' not in already_processed:
            already_processed.add('upper')
            try:
                self.upper = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (upper): %s' % exp)
            self.validate_REAL_NUMBER(self.upper)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class UniformDistribution


class COUNT_TABLE_TYPE(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sample=None, Extension=None, FieldValue=None, FieldValueCount=None):
        self.original_tagname_ = None
        self.sample = _cast(None, sample)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if FieldValue is None:
            self.FieldValue = []
        else:
            self.FieldValue = FieldValue
        if FieldValueCount is None:
            self.FieldValueCount = []
        else:
            self.FieldValueCount = FieldValueCount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COUNT_TABLE_TYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COUNT_TABLE_TYPE.subclass:
            return COUNT_TABLE_TYPE.subclass(*args_, **kwargs_)
        else:
            return COUNT_TABLE_TYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_FieldValue(self): return self.FieldValue
    def set_FieldValue(self, FieldValue): self.FieldValue = FieldValue
    def add_FieldValue(self, value): self.FieldValue.append(value)
    def insert_FieldValue_at(self, index, value): self.FieldValue.insert(index, value)
    def replace_FieldValue_at(self, index, value): self.FieldValue[index] = value
    def get_FieldValueCount(self): return self.FieldValueCount
    def set_FieldValueCount(self, FieldValueCount): self.FieldValueCount = FieldValueCount
    def add_FieldValueCount(self, value): self.FieldValueCount.append(value)
    def insert_FieldValueCount_at(self, index, value): self.FieldValueCount.insert(index, value)
    def replace_FieldValueCount_at(self, index, value): self.FieldValueCount[index] = value
    def get_sample(self): return self.sample
    def set_sample(self, sample): self.sample = sample
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.FieldValue or
            self.FieldValueCount
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COUNT-TABLE-TYPE', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COUNT-TABLE-TYPE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COUNT-TABLE-TYPE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COUNT-TABLE-TYPE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COUNT-TABLE-TYPE'):
        if self.sample is not None and 'sample' not in already_processed:
            already_processed.add('sample')
            outfile.write(' sample=%s' % (quote_attrib(self.sample), ))
    def exportChildren(self, outfile, level, namespace_='', name_='COUNT-TABLE-TYPE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for FieldValue_ in self.FieldValue:
            FieldValue_.export(outfile, level, namespace_, name_='FieldValue', pretty_print=pretty_print)
        for FieldValueCount_ in self.FieldValueCount:
            FieldValueCount_.export(outfile, level, namespace_, name_='FieldValueCount', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='COUNT-TABLE-TYPE', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.sample is not None:
            element.set('sample', self.sample)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for FieldValue_ in self.FieldValue:
            FieldValue_.to_etree(element, name_='FieldValue', mapping_=mapping_)
        for FieldValueCount_ in self.FieldValueCount:
            FieldValueCount_.to_etree(element, name_='FieldValueCount', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='COUNT-TABLE-TYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sample is not None and 'sample' not in already_processed:
            already_processed.add('sample')
            showIndent(outfile, level)
            outfile.write('sample=%e,\n' % (self.sample,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FieldValue=[\n')
        level += 1
        for FieldValue_ in self.FieldValue:
            showIndent(outfile, level)
            outfile.write('model_.FieldValue(\n')
            FieldValue_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FieldValueCount=[\n')
        level += 1
        for FieldValueCount_ in self.FieldValueCount:
            showIndent(outfile, level)
            outfile.write('model_.FieldValueCount(\n')
            FieldValueCount_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sample', node)
        if value is not None and 'sample' not in already_processed:
            already_processed.add('sample')
            try:
                self.sample = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sample): %s' % exp)
            self.validate_NUMBER(self.sample)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'FieldValue':
            obj_ = FieldValue.factory()
            obj_.build(child_)
            self.FieldValue.append(obj_)
            obj_.original_tagname_ = 'FieldValue'
        elif nodeName_ == 'FieldValueCount':
            obj_ = FieldValueCount.factory()
            obj_.build(child_)
            self.FieldValueCount.append(obj_)
            obj_.original_tagname_ = 'FieldValueCount'
# end class COUNT_TABLE_TYPE


class FieldValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, value=None, Extension=None, FieldValue_member=None, FieldValueCount=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.value = _cast(None, value)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if FieldValue_member is None:
            self.FieldValue = []
        else:
            self.FieldValue = FieldValue_member
        if FieldValueCount is None:
            self.FieldValueCount = []
        else:
            self.FieldValueCount = FieldValueCount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FieldValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FieldValue.subclass:
            return FieldValue.subclass(*args_, **kwargs_)
        else:
            return FieldValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_FieldValue(self): return self.FieldValue
    def set_FieldValue(self, FieldValue): self.FieldValue = FieldValue
    def add_FieldValue(self, value): self.FieldValue.append(value)
    def insert_FieldValue_at(self, index, value): self.FieldValue.insert(index, value)
    def replace_FieldValue_at(self, index, value): self.FieldValue[index] = value
    def get_FieldValueCount(self): return self.FieldValueCount
    def set_FieldValueCount(self, FieldValueCount): self.FieldValueCount = FieldValueCount
    def add_FieldValueCount(self, value): self.FieldValueCount.append(value)
    def insert_FieldValueCount_at(self, index, value): self.FieldValueCount.insert(index, value)
    def replace_FieldValueCount_at(self, index, value): self.FieldValueCount[index] = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.FieldValue or
            self.FieldValueCount
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FieldValue', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FieldValue')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FieldValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FieldValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FieldValue'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FieldValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for FieldValue_ in self.FieldValue:
            FieldValue_.export(outfile, level, namespace_, name_='FieldValue', pretty_print=pretty_print)
        for FieldValueCount_ in self.FieldValueCount:
            FieldValueCount_.export(outfile, level, namespace_, name_='FieldValueCount', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='FieldValue', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for FieldValue_ in self.FieldValue:
            FieldValue_.to_etree(element, name_='FieldValue', mapping_=mapping_)
        for FieldValueCount_ in self.FieldValueCount:
            FieldValueCount_.to_etree(element, name_='FieldValueCount', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FieldValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FieldValue=[\n')
        level += 1
        for FieldValue_ in self.FieldValue:
            showIndent(outfile, level)
            outfile.write('model_.FieldValue(\n')
            FieldValue_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FieldValueCount=[\n')
        level += 1
        for FieldValueCount_ in self.FieldValueCount:
            showIndent(outfile, level)
            outfile.write('model_.FieldValueCount(\n')
            FieldValueCount_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'FieldValue':
            obj_ = FieldValue.factory()
            obj_.build(child_)
            self.FieldValue.append(obj_)
            obj_.original_tagname_ = 'FieldValue'
        elif nodeName_ == 'FieldValueCount':
            obj_ = FieldValueCount.factory()
            obj_.build(child_)
            self.FieldValueCount.append(obj_)
            obj_.original_tagname_ = 'FieldValueCount'
# end class FieldValue


class FieldValueCount(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, value=None, count=None, Extension=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.value = _cast(None, value)
        self.count = _cast(None, count)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FieldValueCount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FieldValueCount.subclass:
            return FieldValueCount.subclass(*args_, **kwargs_)
        else:
            return FieldValueCount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FieldValueCount', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FieldValueCount')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FieldValueCount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FieldValueCount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FieldValueCount'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count=%s' % (quote_attrib(self.count), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FieldValueCount', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='FieldValueCount', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.count is not None:
            element.set('count', self.count)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='FieldValueCount'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%e,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (count): %s' % exp)
            self.validate_NUMBER(self.count)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class FieldValueCount


class BayesianNetworkModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, modelType='General', inferenceMethod='Other', isScorable=True, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, BayesianNetworkNodes=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.modelType = _cast(None, modelType)
        self.inferenceMethod = _cast(None, inferenceMethod)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.ModelExplanation = ModelExplanation
        self.Targets = Targets
        self.LocalTransformations = LocalTransformations
        self.BayesianNetworkNodes = BayesianNetworkNodes
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BayesianNetworkModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BayesianNetworkModel.subclass:
            return BayesianNetworkModel.subclass(*args_, **kwargs_)
        else:
            return BayesianNetworkModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_ModelExplanation(self): return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation): self.ModelExplanation = ModelExplanation
    def get_Targets(self): return self.Targets
    def set_Targets(self, Targets): self.Targets = Targets
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_BayesianNetworkNodes(self): return self.BayesianNetworkNodes
    def set_BayesianNetworkNodes(self, BayesianNetworkNodes): self.BayesianNetworkNodes = BayesianNetworkNodes
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_modelType(self): return self.modelType
    def set_modelType(self, modelType): self.modelType = modelType
    def get_inferenceMethod(self): return self.inferenceMethod
    def set_inferenceMethod(self, inferenceMethod): self.inferenceMethod = inferenceMethod
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_BN_TYPE(self, value):
        # Validate type BN-TYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['General', 'TAN', 'Markov-blanket']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BN-TYPE' % {"value" : value.encode("utf-8")} )
    def validate_INFERENCE_TYPE(self, value):
        # Validate type INFERENCE-TYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Other', 'MCMC', 'Exact']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on INFERENCE-TYPE' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.BayesianNetworkNodes is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BayesianNetworkModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BayesianNetworkModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BayesianNetworkModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BayesianNetworkModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BayesianNetworkModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.modelType != "General" and 'modelType' not in already_processed:
            already_processed.add('modelType')
            outfile.write(' modelType=%s' % (quote_attrib(self.modelType), ))
        if self.inferenceMethod != "Other" and 'inferenceMethod' not in already_processed:
            already_processed.add('inferenceMethod')
            outfile.write(' inferenceMethod=%s' % (quote_attrib(self.inferenceMethod), ))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='BayesianNetworkModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            self.ModelExplanation.export(outfile, level, namespace_, name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            self.Targets.export(outfile, level, namespace_, name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        if self.BayesianNetworkNodes is not None:
            self.BayesianNetworkNodes.export(outfile, level, namespace_, name_='BayesianNetworkNodes', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BayesianNetworkModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.modelType is not None:
            element.set('modelType', self.modelType)
        if self.inferenceMethod is not None:
            element.set('inferenceMethod', self.inferenceMethod)
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.ModelExplanation is not None:
            ModelExplanation_ = self.ModelExplanation
            ModelExplanation_.to_etree(element, name_='ModelExplanation', mapping_=mapping_)
        if self.Targets is not None:
            Targets_ = self.Targets
            Targets_.to_etree(element, name_='Targets', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        if self.BayesianNetworkNodes is not None:
            BayesianNetworkNodes_ = self.BayesianNetworkNodes
            BayesianNetworkNodes_.to_etree(element, name_='BayesianNetworkNodes', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BayesianNetworkModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.modelType is not None and 'modelType' not in already_processed:
            already_processed.add('modelType')
            showIndent(outfile, level)
            outfile.write('modelType="%s",\n' % (self.modelType,))
        if self.inferenceMethod is not None and 'inferenceMethod' not in already_processed:
            already_processed.add('inferenceMethod')
            showIndent(outfile, level)
            outfile.write('inferenceMethod="%s",\n' % (self.inferenceMethod,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelExplanation is not None:
            showIndent(outfile, level)
            outfile.write('ModelExplanation=model_.ModelExplanation(\n')
            self.ModelExplanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targets is not None:
            showIndent(outfile, level)
            outfile.write('Targets=model_.Targets(\n')
            self.Targets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BayesianNetworkNodes is not None:
            showIndent(outfile, level)
            outfile.write('BayesianNetworkNodes=model_.BayesianNetworkNodes(\n')
            self.BayesianNetworkNodes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('modelType', node)
        if value is not None and 'modelType' not in already_processed:
            already_processed.add('modelType')
            self.modelType = value
            self.validate_BN_TYPE(self.modelType)    # validate type BN-TYPE
        value = find_attr_value_('inferenceMethod', node)
        if value is not None and 'inferenceMethod' not in already_processed:
            already_processed.add('inferenceMethod')
            self.inferenceMethod = value
            self.validate_INFERENCE_TYPE(self.inferenceMethod)    # validate type INFERENCE-TYPE
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory()
            obj_.build(child_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory()
            obj_.build(child_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'BayesianNetworkNodes':
            obj_ = BayesianNetworkNodes.factory()
            obj_.build(child_)
            self.BayesianNetworkNodes = obj_
            obj_.original_tagname_ = 'BayesianNetworkNodes'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class BayesianNetworkModel


class BayesianNetworkNodes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, DiscreteNode=None, ContinuousNode=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if DiscreteNode is None:
            self.DiscreteNode = []
        else:
            self.DiscreteNode = DiscreteNode
        if ContinuousNode is None:
            self.ContinuousNode = []
        else:
            self.ContinuousNode = ContinuousNode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BayesianNetworkNodes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BayesianNetworkNodes.subclass:
            return BayesianNetworkNodes.subclass(*args_, **kwargs_)
        else:
            return BayesianNetworkNodes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_DiscreteNode(self): return self.DiscreteNode
    def set_DiscreteNode(self, DiscreteNode): self.DiscreteNode = DiscreteNode
    def add_DiscreteNode(self, value): self.DiscreteNode.append(value)
    def insert_DiscreteNode_at(self, index, value): self.DiscreteNode.insert(index, value)
    def replace_DiscreteNode_at(self, index, value): self.DiscreteNode[index] = value
    def get_ContinuousNode(self): return self.ContinuousNode
    def set_ContinuousNode(self, ContinuousNode): self.ContinuousNode = ContinuousNode
    def add_ContinuousNode(self, value): self.ContinuousNode.append(value)
    def insert_ContinuousNode_at(self, index, value): self.ContinuousNode.insert(index, value)
    def replace_ContinuousNode_at(self, index, value): self.ContinuousNode[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.DiscreteNode or
            self.ContinuousNode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BayesianNetworkNodes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BayesianNetworkNodes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BayesianNetworkNodes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BayesianNetworkNodes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BayesianNetworkNodes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BayesianNetworkNodes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for DiscreteNode_ in self.DiscreteNode:
            DiscreteNode_.export(outfile, level, namespace_, name_='DiscreteNode', pretty_print=pretty_print)
        for ContinuousNode_ in self.ContinuousNode:
            ContinuousNode_.export(outfile, level, namespace_, name_='ContinuousNode', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BayesianNetworkNodes', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for DiscreteNode_ in self.DiscreteNode:
            DiscreteNode_.to_etree(element, name_='DiscreteNode', mapping_=mapping_)
        for ContinuousNode_ in self.ContinuousNode:
            ContinuousNode_.to_etree(element, name_='ContinuousNode', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='BayesianNetworkNodes'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DiscreteNode=[\n')
        level += 1
        for DiscreteNode_ in self.DiscreteNode:
            showIndent(outfile, level)
            outfile.write('model_.DiscreteNode(\n')
            DiscreteNode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ContinuousNode=[\n')
        level += 1
        for ContinuousNode_ in self.ContinuousNode:
            showIndent(outfile, level)
            outfile.write('model_.ContinuousNode(\n')
            ContinuousNode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'DiscreteNode':
            obj_ = DiscreteNode.factory()
            obj_.build(child_)
            self.DiscreteNode.append(obj_)
            obj_.original_tagname_ = 'DiscreteNode'
        elif nodeName_ == 'ContinuousNode':
            obj_ = ContinuousNode.factory()
            obj_.build(child_)
            self.ContinuousNode.append(obj_)
            obj_.original_tagname_ = 'ContinuousNode'
# end class BayesianNetworkNodes


class DiscreteNode(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, count=None, Extension=None, DerivedField=None, DiscreteConditionalProbability=None, ValueProbability=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.count = _cast(None, count)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if DerivedField is None:
            self.DerivedField = []
        else:
            self.DerivedField = DerivedField
        if DiscreteConditionalProbability is None:
            self.DiscreteConditionalProbability = []
        else:
            self.DiscreteConditionalProbability = DiscreteConditionalProbability
        if ValueProbability is None:
            self.ValueProbability = []
        else:
            self.ValueProbability = ValueProbability
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiscreteNode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiscreteNode.subclass:
            return DiscreteNode.subclass(*args_, **kwargs_)
        else:
            return DiscreteNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_DerivedField(self): return self.DerivedField
    def set_DerivedField(self, DerivedField): self.DerivedField = DerivedField
    def add_DerivedField(self, value): self.DerivedField.append(value)
    def insert_DerivedField_at(self, index, value): self.DerivedField.insert(index, value)
    def replace_DerivedField_at(self, index, value): self.DerivedField[index] = value
    def get_DiscreteConditionalProbability(self): return self.DiscreteConditionalProbability
    def set_DiscreteConditionalProbability(self, DiscreteConditionalProbability): self.DiscreteConditionalProbability = DiscreteConditionalProbability
    def add_DiscreteConditionalProbability(self, value): self.DiscreteConditionalProbability.append(value)
    def insert_DiscreteConditionalProbability_at(self, index, value): self.DiscreteConditionalProbability.insert(index, value)
    def replace_DiscreteConditionalProbability_at(self, index, value): self.DiscreteConditionalProbability[index] = value
    def get_ValueProbability(self): return self.ValueProbability
    def set_ValueProbability(self, ValueProbability): self.ValueProbability = ValueProbability
    def add_ValueProbability(self, value): self.ValueProbability.append(value)
    def insert_ValueProbability_at(self, index, value): self.ValueProbability.insert(index, value)
    def replace_ValueProbability_at(self, index, value): self.ValueProbability[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.DerivedField or
            self.DiscreteConditionalProbability or
            self.ValueProbability
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiscreteNode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DiscreteNode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiscreteNode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DiscreteNode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiscreteNode'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count=%s' % (quote_attrib(self.count), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DiscreteNode', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for DerivedField_ in self.DerivedField:
            DerivedField_.export(outfile, level, namespace_, name_='DerivedField', pretty_print=pretty_print)
        for DiscreteConditionalProbability_ in self.DiscreteConditionalProbability:
            DiscreteConditionalProbability_.export(outfile, level, namespace_, name_='DiscreteConditionalProbability', pretty_print=pretty_print)
        for ValueProbability_ in self.ValueProbability:
            ValueProbability_.export(outfile, level, namespace_, name_='ValueProbability', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DiscreteNode', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.name)
        if self.count is not None:
            element.set('count', self.count)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for DerivedField_ in self.DerivedField:
            DerivedField_.to_etree(element, name_='DerivedField', mapping_=mapping_)
        for DiscreteConditionalProbability_ in self.DiscreteConditionalProbability:
            DiscreteConditionalProbability_.to_etree(element, name_='DiscreteConditionalProbability', mapping_=mapping_)
        for ValueProbability_ in self.ValueProbability:
            ValueProbability_.to_etree(element, name_='ValueProbability', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DiscreteNode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%e,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DerivedField=[\n')
        level += 1
        for DerivedField_ in self.DerivedField:
            showIndent(outfile, level)
            outfile.write('model_.DerivedField(\n')
            DerivedField_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DiscreteConditionalProbability=[\n')
        level += 1
        for DiscreteConditionalProbability_ in self.DiscreteConditionalProbability:
            showIndent(outfile, level)
            outfile.write('model_.DiscreteConditionalProbability(\n')
            DiscreteConditionalProbability_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ValueProbability=[\n')
        level += 1
        for ValueProbability_ in self.ValueProbability:
            showIndent(outfile, level)
            outfile.write('model_.ValueProbability(\n')
            ValueProbability_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (count): %s' % exp)
            self.validate_REAL_NUMBER(self.count)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'DerivedField':
            obj_ = DerivedField.factory()
            obj_.build(child_)
            self.DerivedField.append(obj_)
            obj_.original_tagname_ = 'DerivedField'
        elif nodeName_ == 'DiscreteConditionalProbability':
            obj_ = DiscreteConditionalProbability.factory()
            obj_.build(child_)
            self.DiscreteConditionalProbability.append(obj_)
            obj_.original_tagname_ = 'DiscreteConditionalProbability'
        elif nodeName_ == 'ValueProbability':
            obj_ = ValueProbability.factory()
            obj_.build(child_)
            self.ValueProbability.append(obj_)
            obj_.original_tagname_ = 'ValueProbability'
# end class DiscreteNode


class ContinuousNode(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, count=None, Extension=None, DerivedField=None, ContinuousConditionalProbability=None, ContinuousDistribution=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.count = _cast(None, count)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if DerivedField is None:
            self.DerivedField = []
        else:
            self.DerivedField = DerivedField
        if ContinuousConditionalProbability is None:
            self.ContinuousConditionalProbability = []
        else:
            self.ContinuousConditionalProbability = ContinuousConditionalProbability
        if ContinuousDistribution is None:
            self.ContinuousDistribution = []
        else:
            self.ContinuousDistribution = ContinuousDistribution
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContinuousNode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContinuousNode.subclass:
            return ContinuousNode.subclass(*args_, **kwargs_)
        else:
            return ContinuousNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_DerivedField(self): return self.DerivedField
    def set_DerivedField(self, DerivedField): self.DerivedField = DerivedField
    def add_DerivedField(self, value): self.DerivedField.append(value)
    def insert_DerivedField_at(self, index, value): self.DerivedField.insert(index, value)
    def replace_DerivedField_at(self, index, value): self.DerivedField[index] = value
    def get_ContinuousConditionalProbability(self): return self.ContinuousConditionalProbability
    def set_ContinuousConditionalProbability(self, ContinuousConditionalProbability): self.ContinuousConditionalProbability = ContinuousConditionalProbability
    def add_ContinuousConditionalProbability(self, value): self.ContinuousConditionalProbability.append(value)
    def insert_ContinuousConditionalProbability_at(self, index, value): self.ContinuousConditionalProbability.insert(index, value)
    def replace_ContinuousConditionalProbability_at(self, index, value): self.ContinuousConditionalProbability[index] = value
    def get_ContinuousDistribution(self): return self.ContinuousDistribution
    def set_ContinuousDistribution(self, ContinuousDistribution): self.ContinuousDistribution = ContinuousDistribution
    def add_ContinuousDistribution(self, value): self.ContinuousDistribution.append(value)
    def insert_ContinuousDistribution_at(self, index, value): self.ContinuousDistribution.insert(index, value)
    def replace_ContinuousDistribution_at(self, index, value): self.ContinuousDistribution[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.DerivedField or
            self.ContinuousConditionalProbability or
            self.ContinuousDistribution
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContinuousNode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContinuousNode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContinuousNode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContinuousNode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContinuousNode'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count=%s' % (quote_attrib(self.count), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ContinuousNode', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for DerivedField_ in self.DerivedField:
            DerivedField_.export(outfile, level, namespace_, name_='DerivedField', pretty_print=pretty_print)
        for ContinuousConditionalProbability_ in self.ContinuousConditionalProbability:
            ContinuousConditionalProbability_.export(outfile, level, namespace_, name_='ContinuousConditionalProbability', pretty_print=pretty_print)
        for ContinuousDistribution_ in self.ContinuousDistribution:
            ContinuousDistribution_.export(outfile, level, namespace_, name_='ContinuousDistribution', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ContinuousNode', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.name is not None:
            element.set('name', self.name)
        if self.count is not None:
            element.set('count', self.count)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for DerivedField_ in self.DerivedField:
            DerivedField_.to_etree(element, name_='DerivedField', mapping_=mapping_)
        for ContinuousConditionalProbability_ in self.ContinuousConditionalProbability:
            ContinuousConditionalProbability_.to_etree(element, name_='ContinuousConditionalProbability', mapping_=mapping_)
        for ContinuousDistribution_ in self.ContinuousDistribution:
            ContinuousDistribution_.to_etree(element, name_='ContinuousDistribution', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ContinuousNode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%e,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DerivedField=[\n')
        level += 1
        for DerivedField_ in self.DerivedField:
            showIndent(outfile, level)
            outfile.write('model_.DerivedField(\n')
            DerivedField_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ContinuousConditionalProbability=[\n')
        level += 1
        for ContinuousConditionalProbability_ in self.ContinuousConditionalProbability:
            showIndent(outfile, level)
            outfile.write('model_.ContinuousConditionalProbability(\n')
            ContinuousConditionalProbability_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ContinuousDistribution=[\n')
        level += 1
        for ContinuousDistribution_ in self.ContinuousDistribution:
            showIndent(outfile, level)
            outfile.write('model_.ContinuousDistribution(\n')
            ContinuousDistribution_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (count): %s' % exp)
            self.validate_REAL_NUMBER(self.count)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'DerivedField':
            obj_ = DerivedField.factory()
            obj_.build(child_)
            self.DerivedField.append(obj_)
            obj_.original_tagname_ = 'DerivedField'
        elif nodeName_ == 'ContinuousConditionalProbability':
            obj_ = ContinuousConditionalProbability.factory()
            obj_.build(child_)
            self.ContinuousConditionalProbability.append(obj_)
            obj_.original_tagname_ = 'ContinuousConditionalProbability'
        elif nodeName_ == 'ContinuousDistribution':
            obj_ = ContinuousDistribution.factory()
            obj_.build(child_)
            self.ContinuousDistribution.append(obj_)
            obj_.original_tagname_ = 'ContinuousDistribution'
# end class ContinuousNode


class DiscreteConditionalProbability(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, Extension=None, ParentValue=None, ValueProbability=None):
        self.original_tagname_ = None
        self.count = _cast(None, count)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if ParentValue is None:
            self.ParentValue = []
        else:
            self.ParentValue = ParentValue
        if ValueProbability is None:
            self.ValueProbability = []
        else:
            self.ValueProbability = ValueProbability
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiscreteConditionalProbability)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiscreteConditionalProbability.subclass:
            return DiscreteConditionalProbability.subclass(*args_, **kwargs_)
        else:
            return DiscreteConditionalProbability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_ParentValue(self): return self.ParentValue
    def set_ParentValue(self, ParentValue): self.ParentValue = ParentValue
    def add_ParentValue(self, value): self.ParentValue.append(value)
    def insert_ParentValue_at(self, index, value): self.ParentValue.insert(index, value)
    def replace_ParentValue_at(self, index, value): self.ParentValue[index] = value
    def get_ValueProbability(self): return self.ValueProbability
    def set_ValueProbability(self, ValueProbability): self.ValueProbability = ValueProbability
    def add_ValueProbability(self, value): self.ValueProbability.append(value)
    def insert_ValueProbability_at(self, index, value): self.ValueProbability.insert(index, value)
    def replace_ValueProbability_at(self, index, value): self.ValueProbability[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.ParentValue or
            self.ValueProbability
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiscreteConditionalProbability', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DiscreteConditionalProbability')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiscreteConditionalProbability')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DiscreteConditionalProbability', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiscreteConditionalProbability'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count=%s' % (quote_attrib(self.count), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DiscreteConditionalProbability', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for ParentValue_ in self.ParentValue:
            ParentValue_.export(outfile, level, namespace_, name_='ParentValue', pretty_print=pretty_print)
        for ValueProbability_ in self.ValueProbability:
            ValueProbability_.export(outfile, level, namespace_, name_='ValueProbability', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DiscreteConditionalProbability', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.count is not None:
            element.set('count', self.count)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for ParentValue_ in self.ParentValue:
            ParentValue_.to_etree(element, name_='ParentValue', mapping_=mapping_)
        for ValueProbability_ in self.ValueProbability:
            ValueProbability_.to_etree(element, name_='ValueProbability', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DiscreteConditionalProbability'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%e,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ParentValue=[\n')
        level += 1
        for ParentValue_ in self.ParentValue:
            showIndent(outfile, level)
            outfile.write('model_.ParentValue(\n')
            ParentValue_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ValueProbability=[\n')
        level += 1
        for ValueProbability_ in self.ValueProbability:
            showIndent(outfile, level)
            outfile.write('model_.ValueProbability(\n')
            ValueProbability_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (count): %s' % exp)
            self.validate_REAL_NUMBER(self.count)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ParentValue':
            obj_ = ParentValue.factory()
            obj_.build(child_)
            self.ParentValue.append(obj_)
            obj_.original_tagname_ = 'ParentValue'
        elif nodeName_ == 'ValueProbability':
            obj_ = ValueProbability.factory()
            obj_.build(child_)
            self.ValueProbability.append(obj_)
            obj_.original_tagname_ = 'ValueProbability'
# end class DiscreteConditionalProbability


class ParentValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, parent=None, value=None, Extension=None):
        self.original_tagname_ = None
        self.parent = _cast(None, parent)
        self.value = _cast(None, value)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParentValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParentValue.subclass:
            return ParentValue.subclass(*args_, **kwargs_)
        else:
            return ParentValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_parent(self): return self.parent
    def set_parent(self, parent): self.parent = parent
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ParentValue', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParentValue')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParentValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ParentValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParentValue'):
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.add('parent')
            outfile.write(' parent=%s' % (quote_attrib(self.parent), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ParentValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ParentValue', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.parent is not None:
            element.set('parent', self.parent)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ParentValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.add('parent')
            showIndent(outfile, level)
            outfile.write('parent="%s",\n' % (self.parent,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parent', node)
        if value is not None and 'parent' not in already_processed:
            already_processed.add('parent')
            self.parent = value
            self.validate_FIELD_NAME(self.parent)    # validate type FIELD-NAME
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class ParentValue


class ValueProbability(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, probability=None, Extension=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.probability = _cast(None, probability)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValueProbability)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValueProbability.subclass:
            return ValueProbability.subclass(*args_, **kwargs_)
        else:
            return ValueProbability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_probability(self): return self.probability
    def set_probability(self, probability): self.probability = probability
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ValueProbability', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ValueProbability')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValueProbability')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ValueProbability', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValueProbability'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.probability is not None and 'probability' not in already_processed:
            already_processed.add('probability')
            outfile.write(' probability=%s' % (quote_attrib(self.probability), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ValueProbability', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ValueProbability', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.probability is not None:
            element.set('probability', self.probability)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ValueProbability'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.probability is not None and 'probability' not in already_processed:
            already_processed.add('probability')
            showIndent(outfile, level)
            outfile.write('probability=%e,\n' % (self.probability,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('probability', node)
        if value is not None and 'probability' not in already_processed:
            already_processed.add('probability')
            try:
                self.probability = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (probability): %s' % exp)
            self.validate_PROB_NUMBER(self.probability)    # validate type PROB-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class ValueProbability


class ContinuousConditionalProbability(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, Extension=None, ParentValue=None, ContinuousDistribution=None):
        self.original_tagname_ = None
        self.count = _cast(None, count)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if ParentValue is None:
            self.ParentValue = []
        else:
            self.ParentValue = ParentValue
        if ContinuousDistribution is None:
            self.ContinuousDistribution = []
        else:
            self.ContinuousDistribution = ContinuousDistribution
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContinuousConditionalProbability)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContinuousConditionalProbability.subclass:
            return ContinuousConditionalProbability.subclass(*args_, **kwargs_)
        else:
            return ContinuousConditionalProbability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_ParentValue(self): return self.ParentValue
    def set_ParentValue(self, ParentValue): self.ParentValue = ParentValue
    def add_ParentValue(self, value): self.ParentValue.append(value)
    def insert_ParentValue_at(self, index, value): self.ParentValue.insert(index, value)
    def replace_ParentValue_at(self, index, value): self.ParentValue[index] = value
    def get_ContinuousDistribution(self): return self.ContinuousDistribution
    def set_ContinuousDistribution(self, ContinuousDistribution): self.ContinuousDistribution = ContinuousDistribution
    def add_ContinuousDistribution(self, value): self.ContinuousDistribution.append(value)
    def insert_ContinuousDistribution_at(self, index, value): self.ContinuousDistribution.insert(index, value)
    def replace_ContinuousDistribution_at(self, index, value): self.ContinuousDistribution[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.ParentValue or
            self.ContinuousDistribution
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContinuousConditionalProbability', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContinuousConditionalProbability')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContinuousConditionalProbability')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContinuousConditionalProbability', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContinuousConditionalProbability'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count=%s' % (quote_attrib(self.count), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ContinuousConditionalProbability', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for ParentValue_ in self.ParentValue:
            ParentValue_.export(outfile, level, namespace_, name_='ParentValue', pretty_print=pretty_print)
        for ContinuousDistribution_ in self.ContinuousDistribution:
            ContinuousDistribution_.export(outfile, level, namespace_, name_='ContinuousDistribution', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ContinuousConditionalProbability', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.count is not None:
            element.set('count', self.count)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for ParentValue_ in self.ParentValue:
            ParentValue_.to_etree(element, name_='ParentValue', mapping_=mapping_)
        for ContinuousDistribution_ in self.ContinuousDistribution:
            ContinuousDistribution_.to_etree(element, name_='ContinuousDistribution', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ContinuousConditionalProbability'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%e,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ParentValue=[\n')
        level += 1
        for ParentValue_ in self.ParentValue:
            showIndent(outfile, level)
            outfile.write('model_.ParentValue(\n')
            ParentValue_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ContinuousDistribution=[\n')
        level += 1
        for ContinuousDistribution_ in self.ContinuousDistribution:
            showIndent(outfile, level)
            outfile.write('model_.ContinuousDistribution(\n')
            ContinuousDistribution_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (count): %s' % exp)
            self.validate_REAL_NUMBER(self.count)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ParentValue':
            obj_ = ParentValue.factory()
            obj_.build(child_)
            self.ParentValue.append(obj_)
            obj_.original_tagname_ = 'ParentValue'
        elif nodeName_ == 'ContinuousDistribution':
            obj_ = ContinuousDistribution.factory()
            obj_.build(child_)
            self.ContinuousDistribution.append(obj_)
            obj_.original_tagname_ = 'ContinuousDistribution'
# end class ContinuousConditionalProbability


class ContinuousDistribution(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, TriangularDistributionForBN=None, NormalDistributionForBN=None, LognormalDistributionForBN=None, UniformDistributionForBN=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.TriangularDistributionForBN = TriangularDistributionForBN
        self.NormalDistributionForBN = NormalDistributionForBN
        self.LognormalDistributionForBN = LognormalDistributionForBN
        self.UniformDistributionForBN = UniformDistributionForBN
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContinuousDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContinuousDistribution.subclass:
            return ContinuousDistribution.subclass(*args_, **kwargs_)
        else:
            return ContinuousDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_TriangularDistributionForBN(self): return self.TriangularDistributionForBN
    def set_TriangularDistributionForBN(self, TriangularDistributionForBN): self.TriangularDistributionForBN = TriangularDistributionForBN
    def get_NormalDistributionForBN(self): return self.NormalDistributionForBN
    def set_NormalDistributionForBN(self, NormalDistributionForBN): self.NormalDistributionForBN = NormalDistributionForBN
    def get_LognormalDistributionForBN(self): return self.LognormalDistributionForBN
    def set_LognormalDistributionForBN(self, LognormalDistributionForBN): self.LognormalDistributionForBN = LognormalDistributionForBN
    def get_UniformDistributionForBN(self): return self.UniformDistributionForBN
    def set_UniformDistributionForBN(self, UniformDistributionForBN): self.UniformDistributionForBN = UniformDistributionForBN
    def hasContent_(self):
        if (
            self.Extension or
            self.TriangularDistributionForBN is not None or
            self.NormalDistributionForBN is not None or
            self.LognormalDistributionForBN is not None or
            self.UniformDistributionForBN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContinuousDistribution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContinuousDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContinuousDistribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContinuousDistribution', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContinuousDistribution'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContinuousDistribution', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.TriangularDistributionForBN is not None:
            self.TriangularDistributionForBN.export(outfile, level, namespace_, name_='TriangularDistributionForBN', pretty_print=pretty_print)
        if self.NormalDistributionForBN is not None:
            self.NormalDistributionForBN.export(outfile, level, namespace_, name_='NormalDistributionForBN', pretty_print=pretty_print)
        if self.LognormalDistributionForBN is not None:
            self.LognormalDistributionForBN.export(outfile, level, namespace_, name_='LognormalDistributionForBN', pretty_print=pretty_print)
        if self.UniformDistributionForBN is not None:
            self.UniformDistributionForBN.export(outfile, level, namespace_, name_='UniformDistributionForBN', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ContinuousDistribution', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.TriangularDistributionForBN is not None:
            TriangularDistributionForBN_ = self.TriangularDistributionForBN
            TriangularDistributionForBN_.to_etree(element, name_='TriangularDistributionForBN', mapping_=mapping_)
        if self.NormalDistributionForBN is not None:
            NormalDistributionForBN_ = self.NormalDistributionForBN
            NormalDistributionForBN_.to_etree(element, name_='NormalDistributionForBN', mapping_=mapping_)
        if self.LognormalDistributionForBN is not None:
            LognormalDistributionForBN_ = self.LognormalDistributionForBN
            LognormalDistributionForBN_.to_etree(element, name_='LognormalDistributionForBN', mapping_=mapping_)
        if self.UniformDistributionForBN is not None:
            UniformDistributionForBN_ = self.UniformDistributionForBN
            UniformDistributionForBN_.to_etree(element, name_='UniformDistributionForBN', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ContinuousDistribution'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.TriangularDistributionForBN is not None:
            showIndent(outfile, level)
            outfile.write('TriangularDistributionForBN=model_.TriangularDistributionForBN(\n')
            self.TriangularDistributionForBN.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormalDistributionForBN is not None:
            showIndent(outfile, level)
            outfile.write('NormalDistributionForBN=model_.NormalDistributionForBN(\n')
            self.NormalDistributionForBN.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LognormalDistributionForBN is not None:
            showIndent(outfile, level)
            outfile.write('LognormalDistributionForBN=model_.LognormalDistributionForBN(\n')
            self.LognormalDistributionForBN.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.UniformDistributionForBN is not None:
            showIndent(outfile, level)
            outfile.write('UniformDistributionForBN=model_.UniformDistributionForBN(\n')
            self.UniformDistributionForBN.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TriangularDistributionForBN':
            obj_ = TriangularDistributionForBN.factory()
            obj_.build(child_)
            self.TriangularDistributionForBN = obj_
            obj_.original_tagname_ = 'TriangularDistributionForBN'
        elif nodeName_ == 'NormalDistributionForBN':
            obj_ = NormalDistributionForBN.factory()
            obj_.build(child_)
            self.NormalDistributionForBN = obj_
            obj_.original_tagname_ = 'NormalDistributionForBN'
        elif nodeName_ == 'LognormalDistributionForBN':
            obj_ = LognormalDistributionForBN.factory()
            obj_.build(child_)
            self.LognormalDistributionForBN = obj_
            obj_.original_tagname_ = 'LognormalDistributionForBN'
        elif nodeName_ == 'UniformDistributionForBN':
            obj_ = UniformDistributionForBN.factory()
            obj_.build(child_)
            self.UniformDistributionForBN = obj_
            obj_.original_tagname_ = 'UniformDistributionForBN'
# end class ContinuousDistribution


class TriangularDistributionForBN(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Mean=None, Lower=None, Upper=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Mean = Mean
        self.Lower = Lower
        self.Upper = Upper
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TriangularDistributionForBN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TriangularDistributionForBN.subclass:
            return TriangularDistributionForBN.subclass(*args_, **kwargs_)
        else:
            return TriangularDistributionForBN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Mean(self): return self.Mean
    def set_Mean(self, Mean): self.Mean = Mean
    def get_Lower(self): return self.Lower
    def set_Lower(self, Lower): self.Lower = Lower
    def get_Upper(self): return self.Upper
    def set_Upper(self, Upper): self.Upper = Upper
    def hasContent_(self):
        if (
            self.Extension or
            self.Mean is not None or
            self.Lower is not None or
            self.Upper is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TriangularDistributionForBN', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TriangularDistributionForBN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TriangularDistributionForBN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TriangularDistributionForBN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TriangularDistributionForBN'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TriangularDistributionForBN', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Mean is not None:
            self.Mean.export(outfile, level, namespace_, name_='Mean', pretty_print=pretty_print)
        if self.Lower is not None:
            self.Lower.export(outfile, level, namespace_, name_='Lower', pretty_print=pretty_print)
        if self.Upper is not None:
            self.Upper.export(outfile, level, namespace_, name_='Upper', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TriangularDistributionForBN', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Mean is not None:
            Mean_ = self.Mean
            Mean_.to_etree(element, name_='Mean', mapping_=mapping_)
        if self.Lower is not None:
            Lower_ = self.Lower
            Lower_.to_etree(element, name_='Lower', mapping_=mapping_)
        if self.Upper is not None:
            Upper_ = self.Upper
            Upper_.to_etree(element, name_='Upper', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TriangularDistributionForBN'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Mean is not None:
            showIndent(outfile, level)
            outfile.write('Mean=model_.Mean(\n')
            self.Mean.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Lower is not None:
            showIndent(outfile, level)
            outfile.write('Lower=model_.Lower(\n')
            self.Lower.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Upper is not None:
            showIndent(outfile, level)
            outfile.write('Upper=model_.Upper(\n')
            self.Upper.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Mean':
            obj_ = Mean.factory()
            obj_.build(child_)
            self.Mean = obj_
            obj_.original_tagname_ = 'Mean'
        elif nodeName_ == 'Lower':
            obj_ = Lower.factory()
            obj_.build(child_)
            self.Lower = obj_
            obj_.original_tagname_ = 'Lower'
        elif nodeName_ == 'Upper':
            obj_ = Upper.factory()
            obj_.build(child_)
            self.Upper = obj_
            obj_.original_tagname_ = 'Upper'
# end class TriangularDistributionForBN


class NormalDistributionForBN(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Mean=None, Variance=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Mean = Mean
        self.Variance = Variance
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NormalDistributionForBN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NormalDistributionForBN.subclass:
            return NormalDistributionForBN.subclass(*args_, **kwargs_)
        else:
            return NormalDistributionForBN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Mean(self): return self.Mean
    def set_Mean(self, Mean): self.Mean = Mean
    def get_Variance(self): return self.Variance
    def set_Variance(self, Variance): self.Variance = Variance
    def hasContent_(self):
        if (
            self.Extension or
            self.Mean is not None or
            self.Variance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NormalDistributionForBN', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NormalDistributionForBN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NormalDistributionForBN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NormalDistributionForBN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NormalDistributionForBN'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NormalDistributionForBN', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Mean is not None:
            self.Mean.export(outfile, level, namespace_, name_='Mean', pretty_print=pretty_print)
        if self.Variance is not None:
            self.Variance.export(outfile, level, namespace_, name_='Variance', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NormalDistributionForBN', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Mean is not None:
            Mean_ = self.Mean
            Mean_.to_etree(element, name_='Mean', mapping_=mapping_)
        if self.Variance is not None:
            Variance_ = self.Variance
            Variance_.to_etree(element, name_='Variance', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='NormalDistributionForBN'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Mean is not None:
            showIndent(outfile, level)
            outfile.write('Mean=model_.Mean(\n')
            self.Mean.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Variance is not None:
            showIndent(outfile, level)
            outfile.write('Variance=model_.Variance(\n')
            self.Variance.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Mean':
            obj_ = Mean.factory()
            obj_.build(child_)
            self.Mean = obj_
            obj_.original_tagname_ = 'Mean'
        elif nodeName_ == 'Variance':
            obj_ = Variance.factory()
            obj_.build(child_)
            self.Variance = obj_
            obj_.original_tagname_ = 'Variance'
# end class NormalDistributionForBN


class LognormalDistributionForBN(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Mean=None, Variance=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Mean = Mean
        self.Variance = Variance
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LognormalDistributionForBN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LognormalDistributionForBN.subclass:
            return LognormalDistributionForBN.subclass(*args_, **kwargs_)
        else:
            return LognormalDistributionForBN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Mean(self): return self.Mean
    def set_Mean(self, Mean): self.Mean = Mean
    def get_Variance(self): return self.Variance
    def set_Variance(self, Variance): self.Variance = Variance
    def hasContent_(self):
        if (
            self.Extension or
            self.Mean is not None or
            self.Variance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LognormalDistributionForBN', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LognormalDistributionForBN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LognormalDistributionForBN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LognormalDistributionForBN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LognormalDistributionForBN'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LognormalDistributionForBN', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Mean is not None:
            self.Mean.export(outfile, level, namespace_, name_='Mean', pretty_print=pretty_print)
        if self.Variance is not None:
            self.Variance.export(outfile, level, namespace_, name_='Variance', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='LognormalDistributionForBN', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Mean is not None:
            Mean_ = self.Mean
            Mean_.to_etree(element, name_='Mean', mapping_=mapping_)
        if self.Variance is not None:
            Variance_ = self.Variance
            Variance_.to_etree(element, name_='Variance', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='LognormalDistributionForBN'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Mean is not None:
            showIndent(outfile, level)
            outfile.write('Mean=model_.Mean(\n')
            self.Mean.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Variance is not None:
            showIndent(outfile, level)
            outfile.write('Variance=model_.Variance(\n')
            self.Variance.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Mean':
            obj_ = Mean.factory()
            obj_.build(child_)
            self.Mean = obj_
            obj_.original_tagname_ = 'Mean'
        elif nodeName_ == 'Variance':
            obj_ = Variance.factory()
            obj_.build(child_)
            self.Variance = obj_
            obj_.original_tagname_ = 'Variance'
# end class LognormalDistributionForBN


class UniformDistributionForBN(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Lower=None, Upper=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Lower = Lower
        self.Upper = Upper
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UniformDistributionForBN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UniformDistributionForBN.subclass:
            return UniformDistributionForBN.subclass(*args_, **kwargs_)
        else:
            return UniformDistributionForBN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Lower(self): return self.Lower
    def set_Lower(self, Lower): self.Lower = Lower
    def get_Upper(self): return self.Upper
    def set_Upper(self, Upper): self.Upper = Upper
    def hasContent_(self):
        if (
            self.Extension or
            self.Lower is not None or
            self.Upper is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UniformDistributionForBN', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UniformDistributionForBN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UniformDistributionForBN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UniformDistributionForBN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UniformDistributionForBN'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UniformDistributionForBN', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Lower is not None:
            self.Lower.export(outfile, level, namespace_, name_='Lower', pretty_print=pretty_print)
        if self.Upper is not None:
            self.Upper.export(outfile, level, namespace_, name_='Upper', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='UniformDistributionForBN', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Lower is not None:
            Lower_ = self.Lower
            Lower_.to_etree(element, name_='Lower', mapping_=mapping_)
        if self.Upper is not None:
            Upper_ = self.Upper
            Upper_.to_etree(element, name_='Upper', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='UniformDistributionForBN'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Lower is not None:
            showIndent(outfile, level)
            outfile.write('Lower=model_.Lower(\n')
            self.Lower.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Upper is not None:
            showIndent(outfile, level)
            outfile.write('Upper=model_.Upper(\n')
            self.Upper.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Lower':
            obj_ = Lower.factory()
            obj_.build(child_)
            self.Lower = obj_
            obj_.original_tagname_ = 'Lower'
        elif nodeName_ == 'Upper':
            obj_ = Upper.factory()
            obj_.build(child_)
            self.Upper = obj_
            obj_.original_tagname_ = 'Upper'
# end class UniformDistributionForBN


class Mean(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, FieldRef=None, Apply=None, Constant=None, NormContinuous=None, NormDiscrete=None, Discretize=None, MapValues=None, TextIndex=None, Aggregate=None, Lag=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.FieldRef = FieldRef
        self.Apply = Apply
        self.Constant = Constant
        self.NormContinuous = NormContinuous
        self.NormDiscrete = NormDiscrete
        self.Discretize = Discretize
        self.MapValues = MapValues
        self.TextIndex = TextIndex
        self.Aggregate = Aggregate
        self.Lag = Lag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Mean)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Mean.subclass:
            return Mean.subclass(*args_, **kwargs_)
        else:
            return Mean(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_FieldRef(self): return self.FieldRef
    def set_FieldRef(self, FieldRef): self.FieldRef = FieldRef
    def get_Apply(self): return self.Apply
    def set_Apply(self, Apply): self.Apply = Apply
    def get_Constant(self): return self.Constant
    def set_Constant(self, Constant): self.Constant = Constant
    def get_NormContinuous(self): return self.NormContinuous
    def set_NormContinuous(self, NormContinuous): self.NormContinuous = NormContinuous
    def get_NormDiscrete(self): return self.NormDiscrete
    def set_NormDiscrete(self, NormDiscrete): self.NormDiscrete = NormDiscrete
    def get_Discretize(self): return self.Discretize
    def set_Discretize(self, Discretize): self.Discretize = Discretize
    def get_MapValues(self): return self.MapValues
    def set_MapValues(self, MapValues): self.MapValues = MapValues
    def get_TextIndex(self): return self.TextIndex
    def set_TextIndex(self, TextIndex): self.TextIndex = TextIndex
    def get_Aggregate(self): return self.Aggregate
    def set_Aggregate(self, Aggregate): self.Aggregate = Aggregate
    def get_Lag(self): return self.Lag
    def set_Lag(self, Lag): self.Lag = Lag
    def hasContent_(self):
        if (
            self.Extension or
            self.FieldRef is not None or
            self.Apply is not None or
            self.Constant is not None or
            self.NormContinuous is not None or
            self.NormDiscrete is not None or
            self.Discretize is not None or
            self.MapValues is not None or
            self.TextIndex is not None or
            self.Aggregate is not None or
            self.Lag is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Mean', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Mean')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Mean')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Mean', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Mean'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Mean', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.FieldRef is not None:
            self.FieldRef.export(outfile, level, namespace_, name_='FieldRef', pretty_print=pretty_print)
        if self.Apply is not None:
            self.Apply.export(outfile, level, namespace_, name_='Apply', pretty_print=pretty_print)
        if self.Constant is not None:
            self.Constant.export(outfile, level, namespace_, name_='Constant', pretty_print=pretty_print)
        if self.NormContinuous is not None:
            self.NormContinuous.export(outfile, level, namespace_, name_='NormContinuous', pretty_print=pretty_print)
        if self.NormDiscrete is not None:
            self.NormDiscrete.export(outfile, level, namespace_, name_='NormDiscrete', pretty_print=pretty_print)
        if self.Discretize is not None:
            self.Discretize.export(outfile, level, namespace_, name_='Discretize', pretty_print=pretty_print)
        if self.MapValues is not None:
            self.MapValues.export(outfile, level, namespace_, name_='MapValues', pretty_print=pretty_print)
        if self.TextIndex is not None:
            self.TextIndex.export(outfile, level, namespace_, name_='TextIndex', pretty_print=pretty_print)
        if self.Aggregate is not None:
            self.Aggregate.export(outfile, level, namespace_, name_='Aggregate', pretty_print=pretty_print)
        if self.Lag is not None:
            self.Lag.export(outfile, level, namespace_, name_='Lag', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Mean', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.FieldRef is not None:
            FieldRef_ = self.FieldRef
            FieldRef_.to_etree(element, name_='FieldRef', mapping_=mapping_)
        if self.Apply is not None:
            Apply_ = self.Apply
            Apply_.to_etree(element, name_='Apply', mapping_=mapping_)
        if self.Constant is not None:
            Constant_ = self.Constant
            Constant_.to_etree(element, name_='Constant', mapping_=mapping_)
        if self.NormContinuous is not None:
            NormContinuous_ = self.NormContinuous
            NormContinuous_.to_etree(element, name_='NormContinuous', mapping_=mapping_)
        if self.NormDiscrete is not None:
            NormDiscrete_ = self.NormDiscrete
            NormDiscrete_.to_etree(element, name_='NormDiscrete', mapping_=mapping_)
        if self.Discretize is not None:
            Discretize_ = self.Discretize
            Discretize_.to_etree(element, name_='Discretize', mapping_=mapping_)
        if self.MapValues is not None:
            MapValues_ = self.MapValues
            MapValues_.to_etree(element, name_='MapValues', mapping_=mapping_)
        if self.TextIndex is not None:
            TextIndex_ = self.TextIndex
            TextIndex_.to_etree(element, name_='TextIndex', mapping_=mapping_)
        if self.Aggregate is not None:
            Aggregate_ = self.Aggregate
            Aggregate_.to_etree(element, name_='Aggregate', mapping_=mapping_)
        if self.Lag is not None:
            Lag_ = self.Lag
            Lag_.to_etree(element, name_='Lag', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Mean'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.FieldRef is not None:
            showIndent(outfile, level)
            outfile.write('FieldRef=model_.FieldRef(\n')
            self.FieldRef.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Apply is not None:
            showIndent(outfile, level)
            outfile.write('Apply=model_.Apply(\n')
            self.Apply.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Constant is not None:
            showIndent(outfile, level)
            outfile.write('Constant=model_.Constant(\n')
            self.Constant.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormContinuous is not None:
            showIndent(outfile, level)
            outfile.write('NormContinuous=model_.NormContinuous(\n')
            self.NormContinuous.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormDiscrete is not None:
            showIndent(outfile, level)
            outfile.write('NormDiscrete=model_.NormDiscrete(\n')
            self.NormDiscrete.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Discretize is not None:
            showIndent(outfile, level)
            outfile.write('Discretize=model_.Discretize(\n')
            self.Discretize.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MapValues is not None:
            showIndent(outfile, level)
            outfile.write('MapValues=model_.MapValues(\n')
            self.MapValues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextIndex is not None:
            showIndent(outfile, level)
            outfile.write('TextIndex=model_.TextIndex(\n')
            self.TextIndex.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Aggregate is not None:
            showIndent(outfile, level)
            outfile.write('Aggregate=model_.Aggregate(\n')
            self.Aggregate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Lag is not None:
            showIndent(outfile, level)
            outfile.write('Lag=model_.Lag(\n')
            self.Lag.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory()
            obj_.build(child_)
            self.FieldRef = obj_
            obj_.original_tagname_ = 'FieldRef'
        elif nodeName_ == 'Apply':
            obj_ = Apply.factory()
            obj_.build(child_)
            self.Apply = obj_
            obj_.original_tagname_ = 'Apply'
        elif nodeName_ == 'Constant':
            obj_ = Constant.factory()
            obj_.build(child_)
            self.Constant = obj_
            obj_.original_tagname_ = 'Constant'
        elif nodeName_ == 'NormContinuous':
            obj_ = NormContinuous.factory()
            obj_.build(child_)
            self.NormContinuous = obj_
            obj_.original_tagname_ = 'NormContinuous'
        elif nodeName_ == 'NormDiscrete':
            obj_ = NormDiscrete.factory()
            obj_.build(child_)
            self.NormDiscrete = obj_
            obj_.original_tagname_ = 'NormDiscrete'
        elif nodeName_ == 'Discretize':
            obj_ = Discretize.factory()
            obj_.build(child_)
            self.Discretize = obj_
            obj_.original_tagname_ = 'Discretize'
        elif nodeName_ == 'MapValues':
            obj_ = MapValues.factory()
            obj_.build(child_)
            self.MapValues = obj_
            obj_.original_tagname_ = 'MapValues'
        elif nodeName_ == 'TextIndex':
            obj_ = TextIndex.factory()
            obj_.build(child_)
            self.TextIndex = obj_
            obj_.original_tagname_ = 'TextIndex'
        elif nodeName_ == 'Aggregate':
            obj_ = Aggregate.factory()
            obj_.build(child_)
            self.Aggregate = obj_
            obj_.original_tagname_ = 'Aggregate'
        elif nodeName_ == 'Lag':
            obj_ = Lag.factory()
            obj_.build(child_)
            self.Lag = obj_
            obj_.original_tagname_ = 'Lag'
# end class Mean


class Lower(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, FieldRef=None, Apply=None, Constant=None, NormContinuous=None, NormDiscrete=None, Discretize=None, MapValues=None, TextIndex=None, Aggregate=None, Lag=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.FieldRef = FieldRef
        self.Apply = Apply
        self.Constant = Constant
        self.NormContinuous = NormContinuous
        self.NormDiscrete = NormDiscrete
        self.Discretize = Discretize
        self.MapValues = MapValues
        self.TextIndex = TextIndex
        self.Aggregate = Aggregate
        self.Lag = Lag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Lower)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Lower.subclass:
            return Lower.subclass(*args_, **kwargs_)
        else:
            return Lower(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_FieldRef(self): return self.FieldRef
    def set_FieldRef(self, FieldRef): self.FieldRef = FieldRef
    def get_Apply(self): return self.Apply
    def set_Apply(self, Apply): self.Apply = Apply
    def get_Constant(self): return self.Constant
    def set_Constant(self, Constant): self.Constant = Constant
    def get_NormContinuous(self): return self.NormContinuous
    def set_NormContinuous(self, NormContinuous): self.NormContinuous = NormContinuous
    def get_NormDiscrete(self): return self.NormDiscrete
    def set_NormDiscrete(self, NormDiscrete): self.NormDiscrete = NormDiscrete
    def get_Discretize(self): return self.Discretize
    def set_Discretize(self, Discretize): self.Discretize = Discretize
    def get_MapValues(self): return self.MapValues
    def set_MapValues(self, MapValues): self.MapValues = MapValues
    def get_TextIndex(self): return self.TextIndex
    def set_TextIndex(self, TextIndex): self.TextIndex = TextIndex
    def get_Aggregate(self): return self.Aggregate
    def set_Aggregate(self, Aggregate): self.Aggregate = Aggregate
    def get_Lag(self): return self.Lag
    def set_Lag(self, Lag): self.Lag = Lag
    def hasContent_(self):
        if (
            self.Extension or
            self.FieldRef is not None or
            self.Apply is not None or
            self.Constant is not None or
            self.NormContinuous is not None or
            self.NormDiscrete is not None or
            self.Discretize is not None or
            self.MapValues is not None or
            self.TextIndex is not None or
            self.Aggregate is not None or
            self.Lag is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Lower', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Lower')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Lower')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Lower', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Lower'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Lower', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.FieldRef is not None:
            self.FieldRef.export(outfile, level, namespace_, name_='FieldRef', pretty_print=pretty_print)
        if self.Apply is not None:
            self.Apply.export(outfile, level, namespace_, name_='Apply', pretty_print=pretty_print)
        if self.Constant is not None:
            self.Constant.export(outfile, level, namespace_, name_='Constant', pretty_print=pretty_print)
        if self.NormContinuous is not None:
            self.NormContinuous.export(outfile, level, namespace_, name_='NormContinuous', pretty_print=pretty_print)
        if self.NormDiscrete is not None:
            self.NormDiscrete.export(outfile, level, namespace_, name_='NormDiscrete', pretty_print=pretty_print)
        if self.Discretize is not None:
            self.Discretize.export(outfile, level, namespace_, name_='Discretize', pretty_print=pretty_print)
        if self.MapValues is not None:
            self.MapValues.export(outfile, level, namespace_, name_='MapValues', pretty_print=pretty_print)
        if self.TextIndex is not None:
            self.TextIndex.export(outfile, level, namespace_, name_='TextIndex', pretty_print=pretty_print)
        if self.Aggregate is not None:
            self.Aggregate.export(outfile, level, namespace_, name_='Aggregate', pretty_print=pretty_print)
        if self.Lag is not None:
            self.Lag.export(outfile, level, namespace_, name_='Lag', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Lower', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.FieldRef is not None:
            FieldRef_ = self.FieldRef
            FieldRef_.to_etree(element, name_='FieldRef', mapping_=mapping_)
        if self.Apply is not None:
            Apply_ = self.Apply
            Apply_.to_etree(element, name_='Apply', mapping_=mapping_)
        if self.Constant is not None:
            Constant_ = self.Constant
            Constant_.to_etree(element, name_='Constant', mapping_=mapping_)
        if self.NormContinuous is not None:
            NormContinuous_ = self.NormContinuous
            NormContinuous_.to_etree(element, name_='NormContinuous', mapping_=mapping_)
        if self.NormDiscrete is not None:
            NormDiscrete_ = self.NormDiscrete
            NormDiscrete_.to_etree(element, name_='NormDiscrete', mapping_=mapping_)
        if self.Discretize is not None:
            Discretize_ = self.Discretize
            Discretize_.to_etree(element, name_='Discretize', mapping_=mapping_)
        if self.MapValues is not None:
            MapValues_ = self.MapValues
            MapValues_.to_etree(element, name_='MapValues', mapping_=mapping_)
        if self.TextIndex is not None:
            TextIndex_ = self.TextIndex
            TextIndex_.to_etree(element, name_='TextIndex', mapping_=mapping_)
        if self.Aggregate is not None:
            Aggregate_ = self.Aggregate
            Aggregate_.to_etree(element, name_='Aggregate', mapping_=mapping_)
        if self.Lag is not None:
            Lag_ = self.Lag
            Lag_.to_etree(element, name_='Lag', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Lower'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.FieldRef is not None:
            showIndent(outfile, level)
            outfile.write('FieldRef=model_.FieldRef(\n')
            self.FieldRef.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Apply is not None:
            showIndent(outfile, level)
            outfile.write('Apply=model_.Apply(\n')
            self.Apply.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Constant is not None:
            showIndent(outfile, level)
            outfile.write('Constant=model_.Constant(\n')
            self.Constant.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormContinuous is not None:
            showIndent(outfile, level)
            outfile.write('NormContinuous=model_.NormContinuous(\n')
            self.NormContinuous.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormDiscrete is not None:
            showIndent(outfile, level)
            outfile.write('NormDiscrete=model_.NormDiscrete(\n')
            self.NormDiscrete.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Discretize is not None:
            showIndent(outfile, level)
            outfile.write('Discretize=model_.Discretize(\n')
            self.Discretize.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MapValues is not None:
            showIndent(outfile, level)
            outfile.write('MapValues=model_.MapValues(\n')
            self.MapValues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextIndex is not None:
            showIndent(outfile, level)
            outfile.write('TextIndex=model_.TextIndex(\n')
            self.TextIndex.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Aggregate is not None:
            showIndent(outfile, level)
            outfile.write('Aggregate=model_.Aggregate(\n')
            self.Aggregate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Lag is not None:
            showIndent(outfile, level)
            outfile.write('Lag=model_.Lag(\n')
            self.Lag.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory()
            obj_.build(child_)
            self.FieldRef = obj_
            obj_.original_tagname_ = 'FieldRef'
        elif nodeName_ == 'Apply':
            obj_ = Apply.factory()
            obj_.build(child_)
            self.Apply = obj_
            obj_.original_tagname_ = 'Apply'
        elif nodeName_ == 'Constant':
            obj_ = Constant.factory()
            obj_.build(child_)
            self.Constant = obj_
            obj_.original_tagname_ = 'Constant'
        elif nodeName_ == 'NormContinuous':
            obj_ = NormContinuous.factory()
            obj_.build(child_)
            self.NormContinuous = obj_
            obj_.original_tagname_ = 'NormContinuous'
        elif nodeName_ == 'NormDiscrete':
            obj_ = NormDiscrete.factory()
            obj_.build(child_)
            self.NormDiscrete = obj_
            obj_.original_tagname_ = 'NormDiscrete'
        elif nodeName_ == 'Discretize':
            obj_ = Discretize.factory()
            obj_.build(child_)
            self.Discretize = obj_
            obj_.original_tagname_ = 'Discretize'
        elif nodeName_ == 'MapValues':
            obj_ = MapValues.factory()
            obj_.build(child_)
            self.MapValues = obj_
            obj_.original_tagname_ = 'MapValues'
        elif nodeName_ == 'TextIndex':
            obj_ = TextIndex.factory()
            obj_.build(child_)
            self.TextIndex = obj_
            obj_.original_tagname_ = 'TextIndex'
        elif nodeName_ == 'Aggregate':
            obj_ = Aggregate.factory()
            obj_.build(child_)
            self.Aggregate = obj_
            obj_.original_tagname_ = 'Aggregate'
        elif nodeName_ == 'Lag':
            obj_ = Lag.factory()
            obj_.build(child_)
            self.Lag = obj_
            obj_.original_tagname_ = 'Lag'
# end class Lower


class Upper(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, FieldRef=None, Apply=None, Constant=None, NormContinuous=None, NormDiscrete=None, Discretize=None, MapValues=None, TextIndex=None, Aggregate=None, Lag=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.FieldRef = FieldRef
        self.Apply = Apply
        self.Constant = Constant
        self.NormContinuous = NormContinuous
        self.NormDiscrete = NormDiscrete
        self.Discretize = Discretize
        self.MapValues = MapValues
        self.TextIndex = TextIndex
        self.Aggregate = Aggregate
        self.Lag = Lag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Upper)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Upper.subclass:
            return Upper.subclass(*args_, **kwargs_)
        else:
            return Upper(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_FieldRef(self): return self.FieldRef
    def set_FieldRef(self, FieldRef): self.FieldRef = FieldRef
    def get_Apply(self): return self.Apply
    def set_Apply(self, Apply): self.Apply = Apply
    def get_Constant(self): return self.Constant
    def set_Constant(self, Constant): self.Constant = Constant
    def get_NormContinuous(self): return self.NormContinuous
    def set_NormContinuous(self, NormContinuous): self.NormContinuous = NormContinuous
    def get_NormDiscrete(self): return self.NormDiscrete
    def set_NormDiscrete(self, NormDiscrete): self.NormDiscrete = NormDiscrete
    def get_Discretize(self): return self.Discretize
    def set_Discretize(self, Discretize): self.Discretize = Discretize
    def get_MapValues(self): return self.MapValues
    def set_MapValues(self, MapValues): self.MapValues = MapValues
    def get_TextIndex(self): return self.TextIndex
    def set_TextIndex(self, TextIndex): self.TextIndex = TextIndex
    def get_Aggregate(self): return self.Aggregate
    def set_Aggregate(self, Aggregate): self.Aggregate = Aggregate
    def get_Lag(self): return self.Lag
    def set_Lag(self, Lag): self.Lag = Lag
    def hasContent_(self):
        if (
            self.Extension or
            self.FieldRef is not None or
            self.Apply is not None or
            self.Constant is not None or
            self.NormContinuous is not None or
            self.NormDiscrete is not None or
            self.Discretize is not None or
            self.MapValues is not None or
            self.TextIndex is not None or
            self.Aggregate is not None or
            self.Lag is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Upper', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Upper')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Upper')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Upper', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Upper'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Upper', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.FieldRef is not None:
            self.FieldRef.export(outfile, level, namespace_, name_='FieldRef', pretty_print=pretty_print)
        if self.Apply is not None:
            self.Apply.export(outfile, level, namespace_, name_='Apply', pretty_print=pretty_print)
        if self.Constant is not None:
            self.Constant.export(outfile, level, namespace_, name_='Constant', pretty_print=pretty_print)
        if self.NormContinuous is not None:
            self.NormContinuous.export(outfile, level, namespace_, name_='NormContinuous', pretty_print=pretty_print)
        if self.NormDiscrete is not None:
            self.NormDiscrete.export(outfile, level, namespace_, name_='NormDiscrete', pretty_print=pretty_print)
        if self.Discretize is not None:
            self.Discretize.export(outfile, level, namespace_, name_='Discretize', pretty_print=pretty_print)
        if self.MapValues is not None:
            self.MapValues.export(outfile, level, namespace_, name_='MapValues', pretty_print=pretty_print)
        if self.TextIndex is not None:
            self.TextIndex.export(outfile, level, namespace_, name_='TextIndex', pretty_print=pretty_print)
        if self.Aggregate is not None:
            self.Aggregate.export(outfile, level, namespace_, name_='Aggregate', pretty_print=pretty_print)
        if self.Lag is not None:
            self.Lag.export(outfile, level, namespace_, name_='Lag', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Upper', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.FieldRef is not None:
            FieldRef_ = self.FieldRef
            FieldRef_.to_etree(element, name_='FieldRef', mapping_=mapping_)
        if self.Apply is not None:
            Apply_ = self.Apply
            Apply_.to_etree(element, name_='Apply', mapping_=mapping_)
        if self.Constant is not None:
            Constant_ = self.Constant
            Constant_.to_etree(element, name_='Constant', mapping_=mapping_)
        if self.NormContinuous is not None:
            NormContinuous_ = self.NormContinuous
            NormContinuous_.to_etree(element, name_='NormContinuous', mapping_=mapping_)
        if self.NormDiscrete is not None:
            NormDiscrete_ = self.NormDiscrete
            NormDiscrete_.to_etree(element, name_='NormDiscrete', mapping_=mapping_)
        if self.Discretize is not None:
            Discretize_ = self.Discretize
            Discretize_.to_etree(element, name_='Discretize', mapping_=mapping_)
        if self.MapValues is not None:
            MapValues_ = self.MapValues
            MapValues_.to_etree(element, name_='MapValues', mapping_=mapping_)
        if self.TextIndex is not None:
            TextIndex_ = self.TextIndex
            TextIndex_.to_etree(element, name_='TextIndex', mapping_=mapping_)
        if self.Aggregate is not None:
            Aggregate_ = self.Aggregate
            Aggregate_.to_etree(element, name_='Aggregate', mapping_=mapping_)
        if self.Lag is not None:
            Lag_ = self.Lag
            Lag_.to_etree(element, name_='Lag', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Upper'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.FieldRef is not None:
            showIndent(outfile, level)
            outfile.write('FieldRef=model_.FieldRef(\n')
            self.FieldRef.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Apply is not None:
            showIndent(outfile, level)
            outfile.write('Apply=model_.Apply(\n')
            self.Apply.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Constant is not None:
            showIndent(outfile, level)
            outfile.write('Constant=model_.Constant(\n')
            self.Constant.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormContinuous is not None:
            showIndent(outfile, level)
            outfile.write('NormContinuous=model_.NormContinuous(\n')
            self.NormContinuous.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormDiscrete is not None:
            showIndent(outfile, level)
            outfile.write('NormDiscrete=model_.NormDiscrete(\n')
            self.NormDiscrete.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Discretize is not None:
            showIndent(outfile, level)
            outfile.write('Discretize=model_.Discretize(\n')
            self.Discretize.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MapValues is not None:
            showIndent(outfile, level)
            outfile.write('MapValues=model_.MapValues(\n')
            self.MapValues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextIndex is not None:
            showIndent(outfile, level)
            outfile.write('TextIndex=model_.TextIndex(\n')
            self.TextIndex.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Aggregate is not None:
            showIndent(outfile, level)
            outfile.write('Aggregate=model_.Aggregate(\n')
            self.Aggregate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Lag is not None:
            showIndent(outfile, level)
            outfile.write('Lag=model_.Lag(\n')
            self.Lag.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory()
            obj_.build(child_)
            self.FieldRef = obj_
            obj_.original_tagname_ = 'FieldRef'
        elif nodeName_ == 'Apply':
            obj_ = Apply.factory()
            obj_.build(child_)
            self.Apply = obj_
            obj_.original_tagname_ = 'Apply'
        elif nodeName_ == 'Constant':
            obj_ = Constant.factory()
            obj_.build(child_)
            self.Constant = obj_
            obj_.original_tagname_ = 'Constant'
        elif nodeName_ == 'NormContinuous':
            obj_ = NormContinuous.factory()
            obj_.build(child_)
            self.NormContinuous = obj_
            obj_.original_tagname_ = 'NormContinuous'
        elif nodeName_ == 'NormDiscrete':
            obj_ = NormDiscrete.factory()
            obj_.build(child_)
            self.NormDiscrete = obj_
            obj_.original_tagname_ = 'NormDiscrete'
        elif nodeName_ == 'Discretize':
            obj_ = Discretize.factory()
            obj_.build(child_)
            self.Discretize = obj_
            obj_.original_tagname_ = 'Discretize'
        elif nodeName_ == 'MapValues':
            obj_ = MapValues.factory()
            obj_.build(child_)
            self.MapValues = obj_
            obj_.original_tagname_ = 'MapValues'
        elif nodeName_ == 'TextIndex':
            obj_ = TextIndex.factory()
            obj_.build(child_)
            self.TextIndex = obj_
            obj_.original_tagname_ = 'TextIndex'
        elif nodeName_ == 'Aggregate':
            obj_ = Aggregate.factory()
            obj_.build(child_)
            self.Aggregate = obj_
            obj_.original_tagname_ = 'Aggregate'
        elif nodeName_ == 'Lag':
            obj_ = Lag.factory()
            obj_.build(child_)
            self.Lag = obj_
            obj_.original_tagname_ = 'Lag'
# end class Upper


class Variance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, FieldRef=None, Apply=None, Constant=None, NormContinuous=None, NormDiscrete=None, Discretize=None, MapValues=None, TextIndex=None, Aggregate=None, Lag=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.FieldRef = FieldRef
        self.Apply = Apply
        self.Constant = Constant
        self.NormContinuous = NormContinuous
        self.NormDiscrete = NormDiscrete
        self.Discretize = Discretize
        self.MapValues = MapValues
        self.TextIndex = TextIndex
        self.Aggregate = Aggregate
        self.Lag = Lag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Variance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Variance.subclass:
            return Variance.subclass(*args_, **kwargs_)
        else:
            return Variance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_FieldRef(self): return self.FieldRef
    def set_FieldRef(self, FieldRef): self.FieldRef = FieldRef
    def get_Apply(self): return self.Apply
    def set_Apply(self, Apply): self.Apply = Apply
    def get_Constant(self): return self.Constant
    def set_Constant(self, Constant): self.Constant = Constant
    def get_NormContinuous(self): return self.NormContinuous
    def set_NormContinuous(self, NormContinuous): self.NormContinuous = NormContinuous
    def get_NormDiscrete(self): return self.NormDiscrete
    def set_NormDiscrete(self, NormDiscrete): self.NormDiscrete = NormDiscrete
    def get_Discretize(self): return self.Discretize
    def set_Discretize(self, Discretize): self.Discretize = Discretize
    def get_MapValues(self): return self.MapValues
    def set_MapValues(self, MapValues): self.MapValues = MapValues
    def get_TextIndex(self): return self.TextIndex
    def set_TextIndex(self, TextIndex): self.TextIndex = TextIndex
    def get_Aggregate(self): return self.Aggregate
    def set_Aggregate(self, Aggregate): self.Aggregate = Aggregate
    def get_Lag(self): return self.Lag
    def set_Lag(self, Lag): self.Lag = Lag
    def hasContent_(self):
        if (
            self.Extension or
            self.FieldRef is not None or
            self.Apply is not None or
            self.Constant is not None or
            self.NormContinuous is not None or
            self.NormDiscrete is not None or
            self.Discretize is not None or
            self.MapValues is not None or
            self.TextIndex is not None or
            self.Aggregate is not None or
            self.Lag is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Variance', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Variance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Variance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Variance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Variance'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Variance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.FieldRef is not None:
            self.FieldRef.export(outfile, level, namespace_, name_='FieldRef', pretty_print=pretty_print)
        if self.Apply is not None:
            self.Apply.export(outfile, level, namespace_, name_='Apply', pretty_print=pretty_print)
        if self.Constant is not None:
            self.Constant.export(outfile, level, namespace_, name_='Constant', pretty_print=pretty_print)
        if self.NormContinuous is not None:
            self.NormContinuous.export(outfile, level, namespace_, name_='NormContinuous', pretty_print=pretty_print)
        if self.NormDiscrete is not None:
            self.NormDiscrete.export(outfile, level, namespace_, name_='NormDiscrete', pretty_print=pretty_print)
        if self.Discretize is not None:
            self.Discretize.export(outfile, level, namespace_, name_='Discretize', pretty_print=pretty_print)
        if self.MapValues is not None:
            self.MapValues.export(outfile, level, namespace_, name_='MapValues', pretty_print=pretty_print)
        if self.TextIndex is not None:
            self.TextIndex.export(outfile, level, namespace_, name_='TextIndex', pretty_print=pretty_print)
        if self.Aggregate is not None:
            self.Aggregate.export(outfile, level, namespace_, name_='Aggregate', pretty_print=pretty_print)
        if self.Lag is not None:
            self.Lag.export(outfile, level, namespace_, name_='Lag', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Variance', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.FieldRef is not None:
            FieldRef_ = self.FieldRef
            FieldRef_.to_etree(element, name_='FieldRef', mapping_=mapping_)
        if self.Apply is not None:
            Apply_ = self.Apply
            Apply_.to_etree(element, name_='Apply', mapping_=mapping_)
        if self.Constant is not None:
            Constant_ = self.Constant
            Constant_.to_etree(element, name_='Constant', mapping_=mapping_)
        if self.NormContinuous is not None:
            NormContinuous_ = self.NormContinuous
            NormContinuous_.to_etree(element, name_='NormContinuous', mapping_=mapping_)
        if self.NormDiscrete is not None:
            NormDiscrete_ = self.NormDiscrete
            NormDiscrete_.to_etree(element, name_='NormDiscrete', mapping_=mapping_)
        if self.Discretize is not None:
            Discretize_ = self.Discretize
            Discretize_.to_etree(element, name_='Discretize', mapping_=mapping_)
        if self.MapValues is not None:
            MapValues_ = self.MapValues
            MapValues_.to_etree(element, name_='MapValues', mapping_=mapping_)
        if self.TextIndex is not None:
            TextIndex_ = self.TextIndex
            TextIndex_.to_etree(element, name_='TextIndex', mapping_=mapping_)
        if self.Aggregate is not None:
            Aggregate_ = self.Aggregate
            Aggregate_.to_etree(element, name_='Aggregate', mapping_=mapping_)
        if self.Lag is not None:
            Lag_ = self.Lag
            Lag_.to_etree(element, name_='Lag', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Variance'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.FieldRef is not None:
            showIndent(outfile, level)
            outfile.write('FieldRef=model_.FieldRef(\n')
            self.FieldRef.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Apply is not None:
            showIndent(outfile, level)
            outfile.write('Apply=model_.Apply(\n')
            self.Apply.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Constant is not None:
            showIndent(outfile, level)
            outfile.write('Constant=model_.Constant(\n')
            self.Constant.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormContinuous is not None:
            showIndent(outfile, level)
            outfile.write('NormContinuous=model_.NormContinuous(\n')
            self.NormContinuous.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NormDiscrete is not None:
            showIndent(outfile, level)
            outfile.write('NormDiscrete=model_.NormDiscrete(\n')
            self.NormDiscrete.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Discretize is not None:
            showIndent(outfile, level)
            outfile.write('Discretize=model_.Discretize(\n')
            self.Discretize.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MapValues is not None:
            showIndent(outfile, level)
            outfile.write('MapValues=model_.MapValues(\n')
            self.MapValues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextIndex is not None:
            showIndent(outfile, level)
            outfile.write('TextIndex=model_.TextIndex(\n')
            self.TextIndex.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Aggregate is not None:
            showIndent(outfile, level)
            outfile.write('Aggregate=model_.Aggregate(\n')
            self.Aggregate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Lag is not None:
            showIndent(outfile, level)
            outfile.write('Lag=model_.Lag(\n')
            self.Lag.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory()
            obj_.build(child_)
            self.FieldRef = obj_
            obj_.original_tagname_ = 'FieldRef'
        elif nodeName_ == 'Apply':
            obj_ = Apply.factory()
            obj_.build(child_)
            self.Apply = obj_
            obj_.original_tagname_ = 'Apply'
        elif nodeName_ == 'Constant':
            obj_ = Constant.factory()
            obj_.build(child_)
            self.Constant = obj_
            obj_.original_tagname_ = 'Constant'
        elif nodeName_ == 'NormContinuous':
            obj_ = NormContinuous.factory()
            obj_.build(child_)
            self.NormContinuous = obj_
            obj_.original_tagname_ = 'NormContinuous'
        elif nodeName_ == 'NormDiscrete':
            obj_ = NormDiscrete.factory()
            obj_.build(child_)
            self.NormDiscrete = obj_
            obj_.original_tagname_ = 'NormDiscrete'
        elif nodeName_ == 'Discretize':
            obj_ = Discretize.factory()
            obj_.build(child_)
            self.Discretize = obj_
            obj_.original_tagname_ = 'Discretize'
        elif nodeName_ == 'MapValues':
            obj_ = MapValues.factory()
            obj_.build(child_)
            self.MapValues = obj_
            obj_.original_tagname_ = 'MapValues'
        elif nodeName_ == 'TextIndex':
            obj_ = TextIndex.factory()
            obj_.build(child_)
            self.TextIndex = obj_
            obj_.original_tagname_ = 'TextIndex'
        elif nodeName_ == 'Aggregate':
            obj_ = Aggregate.factory()
            obj_.build(child_)
            self.Aggregate = obj_
            obj_.original_tagname_ = 'Aggregate'
        elif nodeName_ == 'Lag':
            obj_ = Lag.factory()
            obj_.build(child_)
            self.Lag = obj_
            obj_.original_tagname_ = 'Lag'
# end class Variance


class Targets(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Target=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Target is None:
            self.Target = []
        else:
            self.Target = Target
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Targets)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Targets.subclass:
            return Targets.subclass(*args_, **kwargs_)
        else:
            return Targets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Target(self): return self.Target
    def set_Target(self, Target): self.Target = Target
    def add_Target(self, value): self.Target.append(value)
    def insert_Target_at(self, index, value): self.Target.insert(index, value)
    def replace_Target_at(self, index, value): self.Target[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.Target
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Targets', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Targets')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Targets')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Targets', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Targets'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Targets', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Target_ in self.Target:
            Target_.export(outfile, level, namespace_, name_='Target', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Targets', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Target_ in self.Target:
            Target_.to_etree(element, name_='Target', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Targets'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Target=[\n')
        level += 1
        for Target_ in self.Target:
            showIndent(outfile, level)
            outfile.write('model_.Target(\n')
            Target_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Target':
            obj_ = Target.factory()
            obj_.build(child_)
            self.Target.append(obj_)
            obj_.original_tagname_ = 'Target'
# end class Targets


class Target(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, optype=None, castInteger=None, min=None, max=None, rescaleConstant=0, rescaleFactor=1, Extension=None, TargetValue=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.optype = _cast(None, optype)
        self.castInteger = _cast(None, castInteger)
        self.min = _cast(float, min)
        self.max = _cast(float, max)
        self.rescaleConstant = _cast(float, rescaleConstant)
        self.rescaleFactor = _cast(float, rescaleFactor)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if TargetValue is None:
            self.TargetValue = []
        else:
            self.TargetValue = TargetValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Target)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Target.subclass:
            return Target.subclass(*args_, **kwargs_)
        else:
            return Target(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_TargetValue(self): return self.TargetValue
    def set_TargetValue(self, TargetValue): self.TargetValue = TargetValue
    def add_TargetValue(self, value): self.TargetValue.append(value)
    def insert_TargetValue_at(self, index, value): self.TargetValue.insert(index, value)
    def replace_TargetValue_at(self, index, value): self.TargetValue[index] = value
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_optype(self): return self.optype
    def set_optype(self, optype): self.optype = optype
    def get_castInteger(self): return self.castInteger
    def set_castInteger(self, castInteger): self.castInteger = castInteger
    def get_min(self): return self.min
    def set_min(self, min): self.min = min
    def get_max(self): return self.max
    def set_max(self, max): self.max = max
    def get_rescaleConstant(self): return self.rescaleConstant
    def set_rescaleConstant(self, rescaleConstant): self.rescaleConstant = rescaleConstant
    def get_rescaleFactor(self): return self.rescaleFactor
    def set_rescaleFactor(self, rescaleFactor): self.rescaleFactor = rescaleFactor
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_OPTYPE(self, value):
        # Validate type OPTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['categorical', 'ordinal', 'continuous']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OPTYPE' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Extension or
            self.TargetValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Target', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Target')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Target')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Target', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Target'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            outfile.write(' optype=%s' % (quote_attrib(self.optype), ))
        if self.castInteger is not None and 'castInteger' not in already_processed:
            already_processed.add('castInteger')
            outfile.write(' castInteger=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.castInteger), input_name='castInteger')), ))
        if self.min is not None and 'min' not in already_processed:
            already_processed.add('min')
            outfile.write(' min="%s"' % self.gds_format_double(self.min, input_name='min'))
        if self.max is not None and 'max' not in already_processed:
            already_processed.add('max')
            outfile.write(' max="%s"' % self.gds_format_double(self.max, input_name='max'))
        if self.rescaleConstant != 0 and 'rescaleConstant' not in already_processed:
            already_processed.add('rescaleConstant')
            outfile.write(' rescaleConstant="%s"' % self.gds_format_double(self.rescaleConstant, input_name='rescaleConstant'))
        if self.rescaleFactor != 1 and 'rescaleFactor' not in already_processed:
            already_processed.add('rescaleFactor')
            outfile.write(' rescaleFactor="%s"' % self.gds_format_double(self.rescaleFactor, input_name='rescaleFactor'))
    def exportChildren(self, outfile, level, namespace_='', name_='Target', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for TargetValue_ in self.TargetValue:
            TargetValue_.export(outfile, level, namespace_, name_='TargetValue', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Target', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.optype is not None:
            element.set('optype', self.optype)
        if self.castInteger is not None:
            element.set('castInteger', self.gds_format_string(self.castInteger))
        if self.min is not None:
            element.set('min', self.gds_format_double(self.min))
        if self.max is not None:
            element.set('max', self.gds_format_double(self.max))
        if self.rescaleConstant is not None:
            element.set('rescaleConstant', self.gds_format_double(self.rescaleConstant))
        if self.rescaleFactor is not None:
            element.set('rescaleFactor', self.gds_format_double(self.rescaleFactor))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for TargetValue_ in self.TargetValue:
            TargetValue_.to_etree(element, name_='TargetValue', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Target'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            showIndent(outfile, level)
            outfile.write('optype="%s",\n' % (self.optype,))
        if self.castInteger is not None and 'castInteger' not in already_processed:
            already_processed.add('castInteger')
            showIndent(outfile, level)
            outfile.write('castInteger="%s",\n' % (self.castInteger,))
        if self.min is not None and 'min' not in already_processed:
            already_processed.add('min')
            showIndent(outfile, level)
            outfile.write('min=%e,\n' % (self.min,))
        if self.max is not None and 'max' not in already_processed:
            already_processed.add('max')
            showIndent(outfile, level)
            outfile.write('max=%e,\n' % (self.max,))
        if self.rescaleConstant is not None and 'rescaleConstant' not in already_processed:
            already_processed.add('rescaleConstant')
            showIndent(outfile, level)
            outfile.write('rescaleConstant=%e,\n' % (self.rescaleConstant,))
        if self.rescaleFactor is not None and 'rescaleFactor' not in already_processed:
            already_processed.add('rescaleFactor')
            showIndent(outfile, level)
            outfile.write('rescaleFactor=%e,\n' % (self.rescaleFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TargetValue=[\n')
        level += 1
        for TargetValue_ in self.TargetValue:
            showIndent(outfile, level)
            outfile.write('model_.TargetValue(\n')
            TargetValue_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('optype', node)
        if value is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            self.optype = value
            self.validate_OPTYPE(self.optype)    # validate type OPTYPE
        value = find_attr_value_('castInteger', node)
        if value is not None and 'castInteger' not in already_processed:
            already_processed.add('castInteger')
            self.castInteger = value
        value = find_attr_value_('min', node)
        if value is not None and 'min' not in already_processed:
            already_processed.add('min')
            try:
                self.min = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (min): %s' % exp)
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.add('max')
            try:
                self.max = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (max): %s' % exp)
        value = find_attr_value_('rescaleConstant', node)
        if value is not None and 'rescaleConstant' not in already_processed:
            already_processed.add('rescaleConstant')
            try:
                self.rescaleConstant = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rescaleConstant): %s' % exp)
        value = find_attr_value_('rescaleFactor', node)
        if value is not None and 'rescaleFactor' not in already_processed:
            already_processed.add('rescaleFactor')
            try:
                self.rescaleFactor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rescaleFactor): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TargetValue':
            obj_ = TargetValue.factory()
            obj_.build(child_)
            self.TargetValue.append(obj_)
            obj_.original_tagname_ = 'TargetValue'
# end class Target


class TargetValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, displayValue=None, priorProbability=None, defaultValue=None, Extension=None, Partition=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.displayValue = _cast(None, displayValue)
        self.priorProbability = _cast(None, priorProbability)
        self.defaultValue = _cast(None, defaultValue)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Partition = Partition
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetValue.subclass:
            return TargetValue.subclass(*args_, **kwargs_)
        else:
            return TargetValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Partition(self): return self.Partition
    def set_Partition(self, Partition): self.Partition = Partition
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_displayValue(self): return self.displayValue
    def set_displayValue(self, displayValue): self.displayValue = displayValue
    def get_priorProbability(self): return self.priorProbability
    def set_priorProbability(self, priorProbability): self.priorProbability = priorProbability
    def get_defaultValue(self): return self.defaultValue
    def set_defaultValue(self, defaultValue): self.defaultValue = defaultValue
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Partition is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TargetValue', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TargetValue')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TargetValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TargetValue'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.displayValue is not None and 'displayValue' not in already_processed:
            already_processed.add('displayValue')
            outfile.write(' displayValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayValue), input_name='displayValue')), ))
        if self.priorProbability is not None and 'priorProbability' not in already_processed:
            already_processed.add('priorProbability')
            outfile.write(' priorProbability=%s' % (quote_attrib(self.priorProbability), ))
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            outfile.write(' defaultValue=%s' % (quote_attrib(self.defaultValue), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TargetValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Partition is not None:
            self.Partition.export(outfile, level, namespace_, name_='Partition', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TargetValue', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.displayValue is not None:
            element.set('displayValue', self.gds_format_string(self.displayValue))
        if self.priorProbability is not None:
            element.set('priorProbability', self.priorProbability)
        if self.defaultValue is not None:
            element.set('defaultValue', self.defaultValue)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Partition is not None:
            Partition_ = self.Partition
            Partition_.to_etree(element, name_='Partition', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TargetValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.displayValue is not None and 'displayValue' not in already_processed:
            already_processed.add('displayValue')
            showIndent(outfile, level)
            outfile.write('displayValue="%s",\n' % (self.displayValue,))
        if self.priorProbability is not None and 'priorProbability' not in already_processed:
            already_processed.add('priorProbability')
            showIndent(outfile, level)
            outfile.write('priorProbability=%e,\n' % (self.priorProbability,))
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            showIndent(outfile, level)
            outfile.write('defaultValue=%e,\n' % (self.defaultValue,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Partition is not None:
            showIndent(outfile, level)
            outfile.write('Partition=model_.Partition(\n')
            self.Partition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('displayValue', node)
        if value is not None and 'displayValue' not in already_processed:
            already_processed.add('displayValue')
            self.displayValue = value
        value = find_attr_value_('priorProbability', node)
        if value is not None and 'priorProbability' not in already_processed:
            already_processed.add('priorProbability')
            try:
                self.priorProbability = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (priorProbability): %s' % exp)
            self.validate_PROB_NUMBER(self.priorProbability)    # validate type PROB-NUMBER
        value = find_attr_value_('defaultValue', node)
        if value is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            try:
                self.defaultValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (defaultValue): %s' % exp)
            self.validate_NUMBER(self.defaultValue)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Partition':
            obj_ = Partition.factory()
            obj_.build(child_)
            self.Partition = obj_
            obj_.original_tagname_ = 'Partition'
# end class TargetValue


class TextModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, numberOfTerms=None, numberOfDocuments=None, isScorable=True, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, TextDictionary=None, TextCorpus=None, DocumentTermMatrix=None, TextModelNormalization=None, TextModelSimiliarity=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.numberOfTerms = _cast(int, numberOfTerms)
        self.numberOfDocuments = _cast(int, numberOfDocuments)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.ModelExplanation = ModelExplanation
        self.Targets = Targets
        self.LocalTransformations = LocalTransformations
        self.TextDictionary = TextDictionary
        self.TextCorpus = TextCorpus
        self.DocumentTermMatrix = DocumentTermMatrix
        self.TextModelNormalization = TextModelNormalization
        self.TextModelSimiliarity = TextModelSimiliarity
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextModel.subclass:
            return TextModel.subclass(*args_, **kwargs_)
        else:
            return TextModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_ModelExplanation(self): return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation): self.ModelExplanation = ModelExplanation
    def get_Targets(self): return self.Targets
    def set_Targets(self, Targets): self.Targets = Targets
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_TextDictionary(self): return self.TextDictionary
    def set_TextDictionary(self, TextDictionary): self.TextDictionary = TextDictionary
    def get_TextCorpus(self): return self.TextCorpus
    def set_TextCorpus(self, TextCorpus): self.TextCorpus = TextCorpus
    def get_DocumentTermMatrix(self): return self.DocumentTermMatrix
    def set_DocumentTermMatrix(self, DocumentTermMatrix): self.DocumentTermMatrix = DocumentTermMatrix
    def get_TextModelNormalization(self): return self.TextModelNormalization
    def set_TextModelNormalization(self, TextModelNormalization): self.TextModelNormalization = TextModelNormalization
    def get_TextModelSimiliarity(self): return self.TextModelSimiliarity
    def set_TextModelSimiliarity(self, TextModelSimiliarity): self.TextModelSimiliarity = TextModelSimiliarity
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_numberOfTerms(self): return self.numberOfTerms
    def set_numberOfTerms(self, numberOfTerms): self.numberOfTerms = numberOfTerms
    def get_numberOfDocuments(self): return self.numberOfDocuments
    def set_numberOfDocuments(self, numberOfDocuments): self.numberOfDocuments = numberOfDocuments
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.TextDictionary is not None or
            self.TextCorpus is not None or
            self.DocumentTermMatrix is not None or
            self.TextModelNormalization is not None or
            self.TextModelSimiliarity is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TextModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TextModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.numberOfTerms is not None and 'numberOfTerms' not in already_processed:
            already_processed.add('numberOfTerms')
            outfile.write(' numberOfTerms="%s"' % self.gds_format_integer(self.numberOfTerms, input_name='numberOfTerms'))
        if self.numberOfDocuments is not None and 'numberOfDocuments' not in already_processed:
            already_processed.add('numberOfDocuments')
            outfile.write(' numberOfDocuments="%s"' % self.gds_format_integer(self.numberOfDocuments, input_name='numberOfDocuments'))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='TextModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            self.ModelExplanation.export(outfile, level, namespace_, name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            self.Targets.export(outfile, level, namespace_, name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        if self.TextDictionary is not None:
            self.TextDictionary.export(outfile, level, namespace_, name_='TextDictionary', pretty_print=pretty_print)
        if self.TextCorpus is not None:
            self.TextCorpus.export(outfile, level, namespace_, name_='TextCorpus', pretty_print=pretty_print)
        if self.DocumentTermMatrix is not None:
            self.DocumentTermMatrix.export(outfile, level, namespace_, name_='DocumentTermMatrix', pretty_print=pretty_print)
        if self.TextModelNormalization is not None:
            self.TextModelNormalization.export(outfile, level, namespace_, name_='TextModelNormalization', pretty_print=pretty_print)
        if self.TextModelSimiliarity is not None:
            self.TextModelSimiliarity.export(outfile, level, namespace_, name_='TextModelSimiliarity', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TextModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.numberOfTerms is not None:
            element.set('numberOfTerms', self.gds_format_integer(self.numberOfTerms))
        if self.numberOfDocuments is not None:
            element.set('numberOfDocuments', self.gds_format_integer(self.numberOfDocuments))
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.ModelExplanation is not None:
            ModelExplanation_ = self.ModelExplanation
            ModelExplanation_.to_etree(element, name_='ModelExplanation', mapping_=mapping_)
        if self.Targets is not None:
            Targets_ = self.Targets
            Targets_.to_etree(element, name_='Targets', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        if self.TextDictionary is not None:
            TextDictionary_ = self.TextDictionary
            TextDictionary_.to_etree(element, name_='TextDictionary', mapping_=mapping_)
        if self.TextCorpus is not None:
            TextCorpus_ = self.TextCorpus
            TextCorpus_.to_etree(element, name_='TextCorpus', mapping_=mapping_)
        if self.DocumentTermMatrix is not None:
            DocumentTermMatrix_ = self.DocumentTermMatrix
            DocumentTermMatrix_.to_etree(element, name_='DocumentTermMatrix', mapping_=mapping_)
        if self.TextModelNormalization is not None:
            TextModelNormalization_ = self.TextModelNormalization
            TextModelNormalization_.to_etree(element, name_='TextModelNormalization', mapping_=mapping_)
        if self.TextModelSimiliarity is not None:
            TextModelSimiliarity_ = self.TextModelSimiliarity
            TextModelSimiliarity_.to_etree(element, name_='TextModelSimiliarity', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TextModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.numberOfTerms is not None and 'numberOfTerms' not in already_processed:
            already_processed.add('numberOfTerms')
            showIndent(outfile, level)
            outfile.write('numberOfTerms=%d,\n' % (self.numberOfTerms,))
        if self.numberOfDocuments is not None and 'numberOfDocuments' not in already_processed:
            already_processed.add('numberOfDocuments')
            showIndent(outfile, level)
            outfile.write('numberOfDocuments=%d,\n' % (self.numberOfDocuments,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelExplanation is not None:
            showIndent(outfile, level)
            outfile.write('ModelExplanation=model_.ModelExplanation(\n')
            self.ModelExplanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targets is not None:
            showIndent(outfile, level)
            outfile.write('Targets=model_.Targets(\n')
            self.Targets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextDictionary is not None:
            showIndent(outfile, level)
            outfile.write('TextDictionary=model_.TextDictionary(\n')
            self.TextDictionary.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextCorpus is not None:
            showIndent(outfile, level)
            outfile.write('TextCorpus=model_.TextCorpus(\n')
            self.TextCorpus.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DocumentTermMatrix is not None:
            showIndent(outfile, level)
            outfile.write('DocumentTermMatrix=model_.DocumentTermMatrix(\n')
            self.DocumentTermMatrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextModelNormalization is not None:
            showIndent(outfile, level)
            outfile.write('TextModelNormalization=model_.TextModelNormalization(\n')
            self.TextModelNormalization.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextModelSimiliarity is not None:
            showIndent(outfile, level)
            outfile.write('TextModelSimiliarity=model_.TextModelSimiliarity(\n')
            self.TextModelSimiliarity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('numberOfTerms', node)
        if value is not None and 'numberOfTerms' not in already_processed:
            already_processed.add('numberOfTerms')
            try:
                self.numberOfTerms = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfTerms < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('numberOfDocuments', node)
        if value is not None and 'numberOfDocuments' not in already_processed:
            already_processed.add('numberOfDocuments')
            try:
                self.numberOfDocuments = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfDocuments < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory()
            obj_.build(child_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory()
            obj_.build(child_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'TextDictionary':
            obj_ = TextDictionary.factory()
            obj_.build(child_)
            self.TextDictionary = obj_
            obj_.original_tagname_ = 'TextDictionary'
        elif nodeName_ == 'TextCorpus':
            obj_ = TextCorpus.factory()
            obj_.build(child_)
            self.TextCorpus = obj_
            obj_.original_tagname_ = 'TextCorpus'
        elif nodeName_ == 'DocumentTermMatrix':
            obj_ = DocumentTermMatrix.factory()
            obj_.build(child_)
            self.DocumentTermMatrix = obj_
            obj_.original_tagname_ = 'DocumentTermMatrix'
        elif nodeName_ == 'TextModelNormalization':
            obj_ = TextModelNormalization.factory()
            obj_.build(child_)
            self.TextModelNormalization = obj_
            obj_.original_tagname_ = 'TextModelNormalization'
        elif nodeName_ == 'TextModelSimiliarity':
            obj_ = TextModelSimiliarity.factory()
            obj_.build(child_)
            self.TextModelSimiliarity = obj_
            obj_.original_tagname_ = 'TextModelSimiliarity'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class TextModel


class TextDictionary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Taxonomy=None, Array=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Taxonomy = Taxonomy
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextDictionary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextDictionary.subclass:
            return TextDictionary.subclass(*args_, **kwargs_)
        else:
            return TextDictionary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Taxonomy(self): return self.Taxonomy
    def set_Taxonomy(self, Taxonomy): self.Taxonomy = Taxonomy
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Extension or
            self.Taxonomy is not None or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TextDictionary', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextDictionary')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextDictionary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TextDictionary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextDictionary'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TextDictionary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Taxonomy is not None:
            self.Taxonomy.export(outfile, level, namespace_, name_='Taxonomy', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TextDictionary', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Taxonomy is not None:
            Taxonomy_ = self.Taxonomy
            Taxonomy_.to_etree(element, name_='Taxonomy', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TextDictionary'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Taxonomy is not None:
            showIndent(outfile, level)
            outfile.write('Taxonomy=model_.Taxonomy(\n')
            self.Taxonomy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Taxonomy':
            obj_ = Taxonomy.factory()
            obj_.build(child_)
            self.Taxonomy = obj_
            obj_.original_tagname_ = 'Taxonomy'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class TextDictionary


class TextCorpus(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, TextDocument=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if TextDocument is None:
            self.TextDocument = []
        else:
            self.TextDocument = TextDocument
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextCorpus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextCorpus.subclass:
            return TextCorpus.subclass(*args_, **kwargs_)
        else:
            return TextCorpus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_TextDocument(self): return self.TextDocument
    def set_TextDocument(self, TextDocument): self.TextDocument = TextDocument
    def add_TextDocument(self, value): self.TextDocument.append(value)
    def insert_TextDocument_at(self, index, value): self.TextDocument.insert(index, value)
    def replace_TextDocument_at(self, index, value): self.TextDocument[index] = value
    def hasContent_(self):
        if (
            self.Extension or
            self.TextDocument
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TextCorpus', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextCorpus')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextCorpus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TextCorpus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextCorpus'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TextCorpus', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for TextDocument_ in self.TextDocument:
            TextDocument_.export(outfile, level, namespace_, name_='TextDocument', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TextCorpus', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for TextDocument_ in self.TextDocument:
            TextDocument_.to_etree(element, name_='TextDocument', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TextCorpus'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TextDocument=[\n')
        level += 1
        for TextDocument_ in self.TextDocument:
            showIndent(outfile, level)
            outfile.write('model_.TextDocument(\n')
            TextDocument_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TextDocument':
            obj_ = TextDocument.factory()
            obj_.build(child_)
            self.TextDocument.append(obj_)
            obj_.original_tagname_ = 'TextDocument'
# end class TextCorpus


class TextDocument(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, length=None, file=None, Extension=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.length = _cast(None, length)
        self.file = _cast(None, file)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextDocument.subclass:
            return TextDocument.subclass(*args_, **kwargs_)
        else:
            return TextDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_file(self): return self.file
    def set_file(self, file): self.file = file
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TextDocument', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextDocument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextDocument')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TextDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextDocument'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length=%s' % (quote_attrib(self.length), ))
        if self.file is not None and 'file' not in already_processed:
            already_processed.add('file')
            outfile.write(' file=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.file), input_name='file')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TextDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TextDocument', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.length is not None:
            element.set('length', self.length)
        if self.file is not None:
            element.set('file', self.gds_format_string(self.file))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TextDocument'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            showIndent(outfile, level)
            outfile.write('length=%d,\n' % (self.length,))
        if self.file is not None and 'file' not in already_processed:
            already_processed.add('file')
            showIndent(outfile, level)
            outfile.write('file="%s",\n' % (self.file,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            try:
                self.length = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_INT_NUMBER(self.length)    # validate type INT-NUMBER
        value = find_attr_value_('file', node)
        if value is not None and 'file' not in already_processed:
            already_processed.add('file')
            self.file = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class TextDocument


class DocumentTermMatrix(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Matrix=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Matrix = Matrix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentTermMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentTermMatrix.subclass:
            return DocumentTermMatrix.subclass(*args_, **kwargs_)
        else:
            return DocumentTermMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Matrix(self): return self.Matrix
    def set_Matrix(self, Matrix): self.Matrix = Matrix
    def hasContent_(self):
        if (
            self.Extension or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DocumentTermMatrix', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentTermMatrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentTermMatrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DocumentTermMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DocumentTermMatrix'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DocumentTermMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Matrix is not None:
            self.Matrix.export(outfile, level, namespace_, name_='Matrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DocumentTermMatrix', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Matrix is not None:
            Matrix_ = self.Matrix
            Matrix_.to_etree(element, name_='Matrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='DocumentTermMatrix'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Matrix is not None:
            showIndent(outfile, level)
            outfile.write('Matrix=model_.Matrix(\n')
            self.Matrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory()
            obj_.build(child_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class DocumentTermMatrix


class TextModelNormalization(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, localTermWeights='termFrequency', globalTermWeights='inverseDocumentFrequency', documentNormalization='none', Extension=None):
        self.original_tagname_ = None
        self.localTermWeights = _cast(None, localTermWeights)
        self.globalTermWeights = _cast(None, globalTermWeights)
        self.documentNormalization = _cast(None, documentNormalization)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextModelNormalization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextModelNormalization.subclass:
            return TextModelNormalization.subclass(*args_, **kwargs_)
        else:
            return TextModelNormalization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_localTermWeights(self): return self.localTermWeights
    def set_localTermWeights(self, localTermWeights): self.localTermWeights = localTermWeights
    def get_globalTermWeights(self): return self.globalTermWeights
    def set_globalTermWeights(self, globalTermWeights): self.globalTermWeights = globalTermWeights
    def get_documentNormalization(self): return self.documentNormalization
    def set_documentNormalization(self, documentNormalization): self.documentNormalization = documentNormalization
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TextModelNormalization', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextModelNormalization')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextModelNormalization')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TextModelNormalization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextModelNormalization'):
        if self.localTermWeights != "termFrequency" and 'localTermWeights' not in already_processed:
            already_processed.add('localTermWeights')
            outfile.write(' localTermWeights=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.localTermWeights), input_name='localTermWeights')), ))
        if self.globalTermWeights != "inverseDocumentFrequency" and 'globalTermWeights' not in already_processed:
            already_processed.add('globalTermWeights')
            outfile.write(' globalTermWeights=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.globalTermWeights), input_name='globalTermWeights')), ))
        if self.documentNormalization != "none" and 'documentNormalization' not in already_processed:
            already_processed.add('documentNormalization')
            outfile.write(' documentNormalization=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.documentNormalization), input_name='documentNormalization')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TextModelNormalization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TextModelNormalization', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.localTermWeights is not None:
            element.set('localTermWeights', self.gds_format_string(self.localTermWeights))
        if self.globalTermWeights is not None:
            element.set('globalTermWeights', self.gds_format_string(self.globalTermWeights))
        if self.documentNormalization is not None:
            element.set('documentNormalization', self.gds_format_string(self.documentNormalization))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TextModelNormalization'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.localTermWeights is not None and 'localTermWeights' not in already_processed:
            already_processed.add('localTermWeights')
            showIndent(outfile, level)
            outfile.write('localTermWeights="%s",\n' % (self.localTermWeights,))
        if self.globalTermWeights is not None and 'globalTermWeights' not in already_processed:
            already_processed.add('globalTermWeights')
            showIndent(outfile, level)
            outfile.write('globalTermWeights="%s",\n' % (self.globalTermWeights,))
        if self.documentNormalization is not None and 'documentNormalization' not in already_processed:
            already_processed.add('documentNormalization')
            showIndent(outfile, level)
            outfile.write('documentNormalization="%s",\n' % (self.documentNormalization,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('localTermWeights', node)
        if value is not None and 'localTermWeights' not in already_processed:
            already_processed.add('localTermWeights')
            self.localTermWeights = value
        value = find_attr_value_('globalTermWeights', node)
        if value is not None and 'globalTermWeights' not in already_processed:
            already_processed.add('globalTermWeights')
            self.globalTermWeights = value
        value = find_attr_value_('documentNormalization', node)
        if value is not None and 'documentNormalization' not in already_processed:
            already_processed.add('documentNormalization')
            self.documentNormalization = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class TextModelNormalization


class TextModelSimiliarity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, similarityType=None, Extension=None):
        self.original_tagname_ = None
        self.similarityType = _cast(None, similarityType)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextModelSimiliarity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextModelSimiliarity.subclass:
            return TextModelSimiliarity.subclass(*args_, **kwargs_)
        else:
            return TextModelSimiliarity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_similarityType(self): return self.similarityType
    def set_similarityType(self, similarityType): self.similarityType = similarityType
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TextModelSimiliarity', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextModelSimiliarity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextModelSimiliarity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TextModelSimiliarity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextModelSimiliarity'):
        if self.similarityType is not None and 'similarityType' not in already_processed:
            already_processed.add('similarityType')
            outfile.write(' similarityType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.similarityType), input_name='similarityType')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TextModelSimiliarity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='TextModelSimiliarity', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.similarityType is not None:
            element.set('similarityType', self.gds_format_string(self.similarityType))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='TextModelSimiliarity'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.similarityType is not None and 'similarityType' not in already_processed:
            already_processed.add('similarityType')
            showIndent(outfile, level)
            outfile.write('similarityType="%s",\n' % (self.similarityType,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('similarityType', node)
        if value is not None and 'similarityType' not in already_processed:
            already_processed.add('similarityType')
            self.similarityType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class TextModelSimiliarity


class ClusteringModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, modelClass=None, numberOfClusters=None, isScorable=True, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, LocalTransformations=None, ComparisonMeasure=None, ClusteringField=None, MissingValueWeights=None, Cluster=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.modelClass = _cast(None, modelClass)
        self.numberOfClusters = _cast(int, numberOfClusters)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.ModelExplanation = ModelExplanation
        self.LocalTransformations = LocalTransformations
        self.ComparisonMeasure = ComparisonMeasure
        if ClusteringField is None:
            self.ClusteringField = []
        else:
            self.ClusteringField = ClusteringField
        self.MissingValueWeights = MissingValueWeights
        if Cluster is None:
            self.Cluster = []
        else:
            self.Cluster = Cluster
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClusteringModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClusteringModel.subclass:
            return ClusteringModel.subclass(*args_, **kwargs_)
        else:
            return ClusteringModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_ModelExplanation(self): return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation): self.ModelExplanation = ModelExplanation
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_ComparisonMeasure(self): return self.ComparisonMeasure
    def set_ComparisonMeasure(self, ComparisonMeasure): self.ComparisonMeasure = ComparisonMeasure
    def get_ClusteringField(self): return self.ClusteringField
    def set_ClusteringField(self, ClusteringField): self.ClusteringField = ClusteringField
    def add_ClusteringField(self, value): self.ClusteringField.append(value)
    def insert_ClusteringField_at(self, index, value): self.ClusteringField.insert(index, value)
    def replace_ClusteringField_at(self, index, value): self.ClusteringField[index] = value
    def get_MissingValueWeights(self): return self.MissingValueWeights
    def set_MissingValueWeights(self, MissingValueWeights): self.MissingValueWeights = MissingValueWeights
    def get_Cluster(self): return self.Cluster
    def set_Cluster(self, Cluster): self.Cluster = Cluster
    def add_Cluster(self, value): self.Cluster.append(value)
    def insert_Cluster_at(self, index, value): self.Cluster.insert(index, value)
    def replace_Cluster_at(self, index, value): self.Cluster[index] = value
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_modelClass(self): return self.modelClass
    def set_modelClass(self, modelClass): self.modelClass = modelClass
    def get_numberOfClusters(self): return self.numberOfClusters
    def set_numberOfClusters(self, numberOfClusters): self.numberOfClusters = numberOfClusters
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.LocalTransformations is not None or
            self.ComparisonMeasure is not None or
            self.ClusteringField or
            self.MissingValueWeights is not None or
            self.Cluster or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClusteringModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClusteringModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClusteringModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClusteringModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClusteringModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.modelClass is not None and 'modelClass' not in already_processed:
            already_processed.add('modelClass')
            outfile.write(' modelClass=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelClass), input_name='modelClass')), ))
        if self.numberOfClusters is not None and 'numberOfClusters' not in already_processed:
            already_processed.add('numberOfClusters')
            outfile.write(' numberOfClusters="%s"' % self.gds_format_integer(self.numberOfClusters, input_name='numberOfClusters'))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='ClusteringModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            self.ModelExplanation.export(outfile, level, namespace_, name_='ModelExplanation', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        if self.ComparisonMeasure is not None:
            self.ComparisonMeasure.export(outfile, level, namespace_, name_='ComparisonMeasure', pretty_print=pretty_print)
        for ClusteringField_ in self.ClusteringField:
            ClusteringField_.export(outfile, level, namespace_, name_='ClusteringField', pretty_print=pretty_print)
        if self.MissingValueWeights is not None:
            self.MissingValueWeights.export(outfile, level, namespace_, name_='MissingValueWeights', pretty_print=pretty_print)
        for Cluster_ in self.Cluster:
            Cluster_.export(outfile, level, namespace_, name_='Cluster', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ClusteringModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.modelClass is not None:
            element.set('modelClass', self.gds_format_string(self.modelClass))
        if self.numberOfClusters is not None:
            element.set('numberOfClusters', self.gds_format_integer(self.numberOfClusters))
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.ModelExplanation is not None:
            ModelExplanation_ = self.ModelExplanation
            ModelExplanation_.to_etree(element, name_='ModelExplanation', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        if self.ComparisonMeasure is not None:
            ComparisonMeasure_ = self.ComparisonMeasure
            ComparisonMeasure_.to_etree(element, name_='ComparisonMeasure', mapping_=mapping_)
        for ClusteringField_ in self.ClusteringField:
            ClusteringField_.to_etree(element, name_='ClusteringField', mapping_=mapping_)
        if self.MissingValueWeights is not None:
            MissingValueWeights_ = self.MissingValueWeights
            MissingValueWeights_.to_etree(element, name_='MissingValueWeights', mapping_=mapping_)
        for Cluster_ in self.Cluster:
            Cluster_.to_etree(element, name_='Cluster', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ClusteringModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.modelClass is not None and 'modelClass' not in already_processed:
            already_processed.add('modelClass')
            showIndent(outfile, level)
            outfile.write('modelClass="%s",\n' % (self.modelClass,))
        if self.numberOfClusters is not None and 'numberOfClusters' not in already_processed:
            already_processed.add('numberOfClusters')
            showIndent(outfile, level)
            outfile.write('numberOfClusters=%d,\n' % (self.numberOfClusters,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelExplanation is not None:
            showIndent(outfile, level)
            outfile.write('ModelExplanation=model_.ModelExplanation(\n')
            self.ModelExplanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ComparisonMeasure is not None:
            showIndent(outfile, level)
            outfile.write('ComparisonMeasure=model_.ComparisonMeasure(\n')
            self.ComparisonMeasure.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ClusteringField=[\n')
        level += 1
        for ClusteringField_ in self.ClusteringField:
            showIndent(outfile, level)
            outfile.write('model_.ClusteringField(\n')
            ClusteringField_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.MissingValueWeights is not None:
            showIndent(outfile, level)
            outfile.write('MissingValueWeights=model_.MissingValueWeights(\n')
            self.MissingValueWeights.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Cluster=[\n')
        level += 1
        for Cluster_ in self.Cluster:
            showIndent(outfile, level)
            outfile.write('model_.Cluster(\n')
            Cluster_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('modelClass', node)
        if value is not None and 'modelClass' not in already_processed:
            already_processed.add('modelClass')
            self.modelClass = value
        value = find_attr_value_('numberOfClusters', node)
        if value is not None and 'numberOfClusters' not in already_processed:
            already_processed.add('numberOfClusters')
            try:
                self.numberOfClusters = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberOfClusters < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory()
            obj_.build(child_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'ComparisonMeasure':
            obj_ = ComparisonMeasure.factory()
            obj_.build(child_)
            self.ComparisonMeasure = obj_
            obj_.original_tagname_ = 'ComparisonMeasure'
        elif nodeName_ == 'ClusteringField':
            obj_ = ClusteringField.factory()
            obj_.build(child_)
            self.ClusteringField.append(obj_)
            obj_.original_tagname_ = 'ClusteringField'
        elif nodeName_ == 'MissingValueWeights':
            obj_ = MissingValueWeights.factory()
            obj_.build(child_)
            self.MissingValueWeights = obj_
            obj_.original_tagname_ = 'MissingValueWeights'
        elif nodeName_ == 'Cluster':
            obj_ = Cluster.factory()
            obj_.build(child_)
            self.Cluster.append(obj_)
            obj_.original_tagname_ = 'Cluster'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class ClusteringModel


class MissingValueWeights(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MissingValueWeights)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MissingValueWeights.subclass:
            return MissingValueWeights.subclass(*args_, **kwargs_)
        else:
            return MissingValueWeights(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MissingValueWeights', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MissingValueWeights')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MissingValueWeights')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MissingValueWeights', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MissingValueWeights'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MissingValueWeights', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MissingValueWeights', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='MissingValueWeights'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class MissingValueWeights


class Cluster(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, size=None, Extension=None, KohonenMap=None, Array=None, Partition=None, Covariances=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.size = _cast(int, size)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.KohonenMap = KohonenMap
        self.Array = Array
        self.Partition = Partition
        self.Covariances = Covariances
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Cluster)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cluster.subclass:
            return Cluster.subclass(*args_, **kwargs_)
        else:
            return Cluster(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_KohonenMap(self): return self.KohonenMap
    def set_KohonenMap(self, KohonenMap): self.KohonenMap = KohonenMap
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def get_Partition(self): return self.Partition
    def set_Partition(self, Partition): self.Partition = Partition
    def get_Covariances(self): return self.Covariances
    def set_Covariances(self, Covariances): self.Covariances = Covariances
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (
            self.Extension or
            self.KohonenMap is not None or
            self.Array is not None or
            self.Partition is not None or
            self.Covariances is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Cluster', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Cluster')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Cluster')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Cluster', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Cluster'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
    def exportChildren(self, outfile, level, namespace_='', name_='Cluster', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.KohonenMap is not None:
            self.KohonenMap.export(outfile, level, namespace_, name_='KohonenMap', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
        if self.Partition is not None:
            self.Partition.export(outfile, level, namespace_, name_='Partition', pretty_print=pretty_print)
        if self.Covariances is not None:
            self.Covariances.export(outfile, level, namespace_, name_='Covariances', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Cluster', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.size is not None:
            element.set('size', self.gds_format_integer(self.size))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.KohonenMap is not None:
            KohonenMap_ = self.KohonenMap
            KohonenMap_.to_etree(element, name_='KohonenMap', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if self.Partition is not None:
            Partition_ = self.Partition
            Partition_.to_etree(element, name_='Partition', mapping_=mapping_)
        if self.Covariances is not None:
            Covariances_ = self.Covariances
            Covariances_.to_etree(element, name_='Covariances', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Cluster'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % (self.size,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.KohonenMap is not None:
            showIndent(outfile, level)
            outfile.write('KohonenMap=model_.KohonenMap(\n')
            self.KohonenMap.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Partition is not None:
            showIndent(outfile, level)
            outfile.write('Partition=model_.Partition(\n')
            self.Partition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Covariances is not None:
            showIndent(outfile, level)
            outfile.write('Covariances=model_.Covariances(\n')
            self.Covariances.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            try:
                self.size = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.size < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'KohonenMap':
            obj_ = KohonenMap.factory()
            obj_.build(child_)
            self.KohonenMap = obj_
            obj_.original_tagname_ = 'KohonenMap'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
        elif nodeName_ == 'Partition':
            obj_ = Partition.factory()
            obj_.build(child_)
            self.Partition = obj_
            obj_.original_tagname_ = 'Partition'
        elif nodeName_ == 'Covariances':
            obj_ = Covariances.factory()
            obj_.build(child_)
            self.Covariances = obj_
            obj_.original_tagname_ = 'Covariances'
# end class Cluster


class KohonenMap(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, coord1=None, coord2=None, coord3=None, Extension=None):
        self.original_tagname_ = None
        self.coord1 = _cast(float, coord1)
        self.coord2 = _cast(float, coord2)
        self.coord3 = _cast(float, coord3)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KohonenMap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KohonenMap.subclass:
            return KohonenMap.subclass(*args_, **kwargs_)
        else:
            return KohonenMap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_coord1(self): return self.coord1
    def set_coord1(self, coord1): self.coord1 = coord1
    def get_coord2(self): return self.coord2
    def set_coord2(self, coord2): self.coord2 = coord2
    def get_coord3(self): return self.coord3
    def set_coord3(self, coord3): self.coord3 = coord3
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KohonenMap', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KohonenMap')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KohonenMap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KohonenMap', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KohonenMap'):
        if self.coord1 is not None and 'coord1' not in already_processed:
            already_processed.add('coord1')
            outfile.write(' coord1="%s"' % self.gds_format_double(self.coord1, input_name='coord1'))
        if self.coord2 is not None and 'coord2' not in already_processed:
            already_processed.add('coord2')
            outfile.write(' coord2="%s"' % self.gds_format_double(self.coord2, input_name='coord2'))
        if self.coord3 is not None and 'coord3' not in already_processed:
            already_processed.add('coord3')
            outfile.write(' coord3="%s"' % self.gds_format_double(self.coord3, input_name='coord3'))
    def exportChildren(self, outfile, level, namespace_='', name_='KohonenMap', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='KohonenMap', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.coord1 is not None:
            element.set('coord1', self.gds_format_double(self.coord1))
        if self.coord2 is not None:
            element.set('coord2', self.gds_format_double(self.coord2))
        if self.coord3 is not None:
            element.set('coord3', self.gds_format_double(self.coord3))
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='KohonenMap'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.coord1 is not None and 'coord1' not in already_processed:
            already_processed.add('coord1')
            showIndent(outfile, level)
            outfile.write('coord1=%e,\n' % (self.coord1,))
        if self.coord2 is not None and 'coord2' not in already_processed:
            already_processed.add('coord2')
            showIndent(outfile, level)
            outfile.write('coord2=%e,\n' % (self.coord2,))
        if self.coord3 is not None and 'coord3' not in already_processed:
            already_processed.add('coord3')
            showIndent(outfile, level)
            outfile.write('coord3=%e,\n' % (self.coord3,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coord1', node)
        if value is not None and 'coord1' not in already_processed:
            already_processed.add('coord1')
            try:
                self.coord1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coord1): %s' % exp)
        value = find_attr_value_('coord2', node)
        if value is not None and 'coord2' not in already_processed:
            already_processed.add('coord2')
            try:
                self.coord2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coord2): %s' % exp)
        value = find_attr_value_('coord3', node)
        if value is not None and 'coord3' not in already_processed:
            already_processed.add('coord3')
            try:
                self.coord3 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (coord3): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class KohonenMap


class Covariances(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Matrix=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Matrix = Matrix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Covariances)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Covariances.subclass:
            return Covariances.subclass(*args_, **kwargs_)
        else:
            return Covariances(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Matrix(self): return self.Matrix
    def set_Matrix(self, Matrix): self.Matrix = Matrix
    def hasContent_(self):
        if (
            self.Extension or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Covariances', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Covariances')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Covariances')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Covariances', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Covariances'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Covariances', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Matrix is not None:
            self.Matrix.export(outfile, level, namespace_, name_='Matrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Covariances', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Matrix is not None:
            Matrix_ = self.Matrix
            Matrix_.to_etree(element, name_='Matrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Covariances'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Matrix is not None:
            showIndent(outfile, level)
            outfile.write('Matrix=model_.Matrix(\n')
            self.Matrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory()
            obj_.build(child_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class Covariances


class ClusteringField(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, isCenterField='true', fieldWeight='1', similarityScale=None, compareFunction=None, Extension=None, Comparisons=None):
        self.original_tagname_ = None
        self.field = _cast(None, field)
        self.isCenterField = _cast(None, isCenterField)
        self.fieldWeight = _cast(None, fieldWeight)
        self.similarityScale = _cast(None, similarityScale)
        self.compareFunction = _cast(None, compareFunction)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Comparisons = Comparisons
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClusteringField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClusteringField.subclass:
            return ClusteringField.subclass(*args_, **kwargs_)
        else:
            return ClusteringField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Comparisons(self): return self.Comparisons
    def set_Comparisons(self, Comparisons): self.Comparisons = Comparisons
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def get_isCenterField(self): return self.isCenterField
    def set_isCenterField(self, isCenterField): self.isCenterField = isCenterField
    def get_fieldWeight(self): return self.fieldWeight
    def set_fieldWeight(self, fieldWeight): self.fieldWeight = fieldWeight
    def get_similarityScale(self): return self.similarityScale
    def set_similarityScale(self, similarityScale): self.similarityScale = similarityScale
    def get_compareFunction(self): return self.compareFunction
    def set_compareFunction(self, compareFunction): self.compareFunction = compareFunction
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_COMPARE_FUNCTION(self, value):
        # Validate type COMPARE-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['absDiff', 'gaussSim', 'delta', 'equal', 'table']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on COMPARE-FUNCTION' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Extension or
            self.Comparisons is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClusteringField', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClusteringField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClusteringField')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClusteringField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClusteringField'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (quote_attrib(self.field), ))
        if self.isCenterField != "true" and 'isCenterField' not in already_processed:
            already_processed.add('isCenterField')
            outfile.write(' isCenterField=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.isCenterField), input_name='isCenterField')), ))
        if self.fieldWeight != 1 and 'fieldWeight' not in already_processed:
            already_processed.add('fieldWeight')
            outfile.write(' fieldWeight=%s' % (quote_attrib(self.fieldWeight), ))
        if self.similarityScale is not None and 'similarityScale' not in already_processed:
            already_processed.add('similarityScale')
            outfile.write(' similarityScale=%s' % (quote_attrib(self.similarityScale), ))
        if self.compareFunction is not None and 'compareFunction' not in already_processed:
            already_processed.add('compareFunction')
            outfile.write(' compareFunction=%s' % (quote_attrib(self.compareFunction), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ClusteringField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Comparisons is not None:
            self.Comparisons.export(outfile, level, namespace_, name_='Comparisons', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ClusteringField', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.field is not None:
            element.set('field', self.field)
        if self.isCenterField is not None:
            element.set('isCenterField', self.gds_format_string(self.isCenterField))
        if self.fieldWeight is not None:
            element.set('fieldWeight', self.fieldWeight)
        if self.similarityScale is not None:
            element.set('similarityScale', self.similarityScale)
        if self.compareFunction is not None:
            element.set('compareFunction', self.compareFunction)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Comparisons is not None:
            Comparisons_ = self.Comparisons
            Comparisons_.to_etree(element, name_='Comparisons', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ClusteringField'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            showIndent(outfile, level)
            outfile.write('field="%s",\n' % (self.field,))
        if self.isCenterField is not None and 'isCenterField' not in already_processed:
            already_processed.add('isCenterField')
            showIndent(outfile, level)
            outfile.write('isCenterField="%s",\n' % (self.isCenterField,))
        if self.fieldWeight is not None and 'fieldWeight' not in already_processed:
            already_processed.add('fieldWeight')
            showIndent(outfile, level)
            outfile.write('fieldWeight=%e,\n' % (self.fieldWeight,))
        if self.similarityScale is not None and 'similarityScale' not in already_processed:
            already_processed.add('similarityScale')
            showIndent(outfile, level)
            outfile.write('similarityScale=%e,\n' % (self.similarityScale,))
        if self.compareFunction is not None and 'compareFunction' not in already_processed:
            already_processed.add('compareFunction')
            showIndent(outfile, level)
            outfile.write('compareFunction="%s",\n' % (self.compareFunction,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Comparisons is not None:
            showIndent(outfile, level)
            outfile.write('Comparisons=model_.Comparisons(\n')
            self.Comparisons.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('isCenterField', node)
        if value is not None and 'isCenterField' not in already_processed:
            already_processed.add('isCenterField')
            self.isCenterField = value
        value = find_attr_value_('fieldWeight', node)
        if value is not None and 'fieldWeight' not in already_processed:
            already_processed.add('fieldWeight')
            try:
                self.fieldWeight = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (fieldWeight): %s' % exp)
            self.validate_REAL_NUMBER(self.fieldWeight)    # validate type REAL-NUMBER
        value = find_attr_value_('similarityScale', node)
        if value is not None and 'similarityScale' not in already_processed:
            already_processed.add('similarityScale')
            try:
                self.similarityScale = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (similarityScale): %s' % exp)
            self.validate_REAL_NUMBER(self.similarityScale)    # validate type REAL-NUMBER
        value = find_attr_value_('compareFunction', node)
        if value is not None and 'compareFunction' not in already_processed:
            already_processed.add('compareFunction')
            self.compareFunction = value
            self.validate_COMPARE_FUNCTION(self.compareFunction)    # validate type COMPARE-FUNCTION
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Comparisons':
            obj_ = Comparisons.factory()
            obj_.build(child_)
            self.Comparisons = obj_
            obj_.original_tagname_ = 'Comparisons'
# end class ClusteringField


class Comparisons(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Matrix=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Matrix = Matrix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Comparisons)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Comparisons.subclass:
            return Comparisons.subclass(*args_, **kwargs_)
        else:
            return Comparisons(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Matrix(self): return self.Matrix
    def set_Matrix(self, Matrix): self.Matrix = Matrix
    def hasContent_(self):
        if (
            self.Extension or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Comparisons', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Comparisons')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Comparisons')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Comparisons', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Comparisons'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Comparisons', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Matrix is not None:
            self.Matrix.export(outfile, level, namespace_, name_='Matrix', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Comparisons', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Matrix is not None:
            Matrix_ = self.Matrix
            Matrix_.to_etree(element, name_='Matrix', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Comparisons'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Matrix is not None:
            showIndent(outfile, level)
            outfile.write('Matrix=model_.Matrix(\n')
            self.Matrix.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory()
            obj_.build(child_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class Comparisons


class ComparisonMeasure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, kind=None, compareFunction='absDiff', minimum=None, maximum=None, Extension=None, euclidean=None, squaredEuclidean=None, chebychev=None, cityBlock=None, minkowski=None, simpleMatching=None, jaccard=None, tanimoto=None, binarySimilarity=None):
        self.original_tagname_ = None
        self.kind = _cast(None, kind)
        self.compareFunction = _cast(None, compareFunction)
        self.minimum = _cast(None, minimum)
        self.maximum = _cast(None, maximum)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.euclidean = euclidean
        self.squaredEuclidean = squaredEuclidean
        self.chebychev = chebychev
        self.cityBlock = cityBlock
        self.minkowski = minkowski
        self.simpleMatching = simpleMatching
        self.jaccard = jaccard
        self.tanimoto = tanimoto
        self.binarySimilarity = binarySimilarity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComparisonMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComparisonMeasure.subclass:
            return ComparisonMeasure.subclass(*args_, **kwargs_)
        else:
            return ComparisonMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_euclidean(self): return self.euclidean
    def set_euclidean(self, euclidean): self.euclidean = euclidean
    def get_squaredEuclidean(self): return self.squaredEuclidean
    def set_squaredEuclidean(self, squaredEuclidean): self.squaredEuclidean = squaredEuclidean
    def get_chebychev(self): return self.chebychev
    def set_chebychev(self, chebychev): self.chebychev = chebychev
    def get_cityBlock(self): return self.cityBlock
    def set_cityBlock(self, cityBlock): self.cityBlock = cityBlock
    def get_minkowski(self): return self.minkowski
    def set_minkowski(self, minkowski): self.minkowski = minkowski
    def get_simpleMatching(self): return self.simpleMatching
    def set_simpleMatching(self, simpleMatching): self.simpleMatching = simpleMatching
    def get_jaccard(self): return self.jaccard
    def set_jaccard(self, jaccard): self.jaccard = jaccard
    def get_tanimoto(self): return self.tanimoto
    def set_tanimoto(self, tanimoto): self.tanimoto = tanimoto
    def get_binarySimilarity(self): return self.binarySimilarity
    def set_binarySimilarity(self, binarySimilarity): self.binarySimilarity = binarySimilarity
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    def get_compareFunction(self): return self.compareFunction
    def set_compareFunction(self, compareFunction): self.compareFunction = compareFunction
    def get_minimum(self): return self.minimum
    def set_minimum(self, minimum): self.minimum = minimum
    def get_maximum(self): return self.maximum
    def set_maximum(self, maximum): self.maximum = maximum
    def validate_COMPARE_FUNCTION(self, value):
        # Validate type COMPARE-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['absDiff', 'gaussSim', 'delta', 'equal', 'table']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on COMPARE-FUNCTION' % {"value" : value.encode("utf-8")} )
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.euclidean is not None or
            self.squaredEuclidean is not None or
            self.chebychev is not None or
            self.cityBlock is not None or
            self.minkowski is not None or
            self.simpleMatching is not None or
            self.jaccard is not None or
            self.tanimoto is not None or
            self.binarySimilarity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ComparisonMeasure', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ComparisonMeasure')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComparisonMeasure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ComparisonMeasure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ComparisonMeasure'):
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            outfile.write(' kind=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.kind), input_name='kind')), ))
        if self.compareFunction != "absDiff" and 'compareFunction' not in already_processed:
            already_processed.add('compareFunction')
            outfile.write(' compareFunction=%s' % (quote_attrib(self.compareFunction), ))
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum=%s' % (quote_attrib(self.minimum), ))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum=%s' % (quote_attrib(self.maximum), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ComparisonMeasure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.euclidean is not None:
            self.euclidean.export(outfile, level, namespace_, name_='euclidean', pretty_print=pretty_print)
        if self.squaredEuclidean is not None:
            self.squaredEuclidean.export(outfile, level, namespace_, name_='squaredEuclidean', pretty_print=pretty_print)
        if self.chebychev is not None:
            self.chebychev.export(outfile, level, namespace_, name_='chebychev', pretty_print=pretty_print)
        if self.cityBlock is not None:
            self.cityBlock.export(outfile, level, namespace_, name_='cityBlock', pretty_print=pretty_print)
        if self.minkowski is not None:
            self.minkowski.export(outfile, level, namespace_, name_='minkowski', pretty_print=pretty_print)
        if self.simpleMatching is not None:
            self.simpleMatching.export(outfile, level, namespace_, name_='simpleMatching', pretty_print=pretty_print)
        if self.jaccard is not None:
            self.jaccard.export(outfile, level, namespace_, name_='jaccard', pretty_print=pretty_print)
        if self.tanimoto is not None:
            self.tanimoto.export(outfile, level, namespace_, name_='tanimoto', pretty_print=pretty_print)
        if self.binarySimilarity is not None:
            self.binarySimilarity.export(outfile, level, namespace_, name_='binarySimilarity', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ComparisonMeasure', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.kind is not None:
            element.set('kind', self.gds_format_string(self.kind))
        if self.compareFunction is not None:
            element.set('compareFunction', self.compareFunction)
        if self.minimum is not None:
            element.set('minimum', self.minimum)
        if self.maximum is not None:
            element.set('maximum', self.maximum)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.euclidean is not None:
            euclidean_ = self.euclidean
            euclidean_.to_etree(element, name_='euclidean', mapping_=mapping_)
        if self.squaredEuclidean is not None:
            squaredEuclidean_ = self.squaredEuclidean
            squaredEuclidean_.to_etree(element, name_='squaredEuclidean', mapping_=mapping_)
        if self.chebychev is not None:
            chebychev_ = self.chebychev
            chebychev_.to_etree(element, name_='chebychev', mapping_=mapping_)
        if self.cityBlock is not None:
            cityBlock_ = self.cityBlock
            cityBlock_.to_etree(element, name_='cityBlock', mapping_=mapping_)
        if self.minkowski is not None:
            minkowski_ = self.minkowski
            minkowski_.to_etree(element, name_='minkowski', mapping_=mapping_)
        if self.simpleMatching is not None:
            simpleMatching_ = self.simpleMatching
            simpleMatching_.to_etree(element, name_='simpleMatching', mapping_=mapping_)
        if self.jaccard is not None:
            jaccard_ = self.jaccard
            jaccard_.to_etree(element, name_='jaccard', mapping_=mapping_)
        if self.tanimoto is not None:
            tanimoto_ = self.tanimoto
            tanimoto_.to_etree(element, name_='tanimoto', mapping_=mapping_)
        if self.binarySimilarity is not None:
            binarySimilarity_ = self.binarySimilarity
            binarySimilarity_.to_etree(element, name_='binarySimilarity', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ComparisonMeasure'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            showIndent(outfile, level)
            outfile.write('kind="%s",\n' % (self.kind,))
        if self.compareFunction is not None and 'compareFunction' not in already_processed:
            already_processed.add('compareFunction')
            showIndent(outfile, level)
            outfile.write('compareFunction="%s",\n' % (self.compareFunction,))
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            showIndent(outfile, level)
            outfile.write('minimum=%e,\n' % (self.minimum,))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            showIndent(outfile, level)
            outfile.write('maximum=%e,\n' % (self.maximum,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.euclidean is not None:
            showIndent(outfile, level)
            outfile.write('euclidean=model_.euclidean(\n')
            self.euclidean.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.squaredEuclidean is not None:
            showIndent(outfile, level)
            outfile.write('squaredEuclidean=model_.squaredEuclidean(\n')
            self.squaredEuclidean.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.chebychev is not None:
            showIndent(outfile, level)
            outfile.write('chebychev=model_.chebychev(\n')
            self.chebychev.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cityBlock is not None:
            showIndent(outfile, level)
            outfile.write('cityBlock=model_.cityBlock(\n')
            self.cityBlock.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.minkowski is not None:
            showIndent(outfile, level)
            outfile.write('minkowski=model_.minkowski(\n')
            self.minkowski.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.simpleMatching is not None:
            showIndent(outfile, level)
            outfile.write('simpleMatching=model_.simpleMatching(\n')
            self.simpleMatching.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.jaccard is not None:
            showIndent(outfile, level)
            outfile.write('jaccard=model_.jaccard(\n')
            self.jaccard.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.tanimoto is not None:
            showIndent(outfile, level)
            outfile.write('tanimoto=model_.tanimoto(\n')
            self.tanimoto.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.binarySimilarity is not None:
            showIndent(outfile, level)
            outfile.write('binarySimilarity=model_.binarySimilarity(\n')
            self.binarySimilarity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('kind', node)
        if value is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            self.kind = value
        value = find_attr_value_('compareFunction', node)
        if value is not None and 'compareFunction' not in already_processed:
            already_processed.add('compareFunction')
            self.compareFunction = value
            self.validate_COMPARE_FUNCTION(self.compareFunction)    # validate type COMPARE-FUNCTION
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            try:
                self.minimum = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (minimum): %s' % exp)
            self.validate_NUMBER(self.minimum)    # validate type NUMBER
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            try:
                self.maximum = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (maximum): %s' % exp)
            self.validate_NUMBER(self.maximum)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'euclidean':
            obj_ = euclidean.factory()
            obj_.build(child_)
            self.euclidean = obj_
            obj_.original_tagname_ = 'euclidean'
        elif nodeName_ == 'squaredEuclidean':
            obj_ = squaredEuclidean.factory()
            obj_.build(child_)
            self.squaredEuclidean = obj_
            obj_.original_tagname_ = 'squaredEuclidean'
        elif nodeName_ == 'chebychev':
            obj_ = chebychev.factory()
            obj_.build(child_)
            self.chebychev = obj_
            obj_.original_tagname_ = 'chebychev'
        elif nodeName_ == 'cityBlock':
            obj_ = cityBlock.factory()
            obj_.build(child_)
            self.cityBlock = obj_
            obj_.original_tagname_ = 'cityBlock'
        elif nodeName_ == 'minkowski':
            obj_ = minkowski.factory()
            obj_.build(child_)
            self.minkowski = obj_
            obj_.original_tagname_ = 'minkowski'
        elif nodeName_ == 'simpleMatching':
            obj_ = simpleMatching.factory()
            obj_.build(child_)
            self.simpleMatching = obj_
            obj_.original_tagname_ = 'simpleMatching'
        elif nodeName_ == 'jaccard':
            obj_ = jaccard.factory()
            obj_.build(child_)
            self.jaccard = obj_
            obj_.original_tagname_ = 'jaccard'
        elif nodeName_ == 'tanimoto':
            obj_ = tanimoto.factory()
            obj_.build(child_)
            self.tanimoto = obj_
            obj_.original_tagname_ = 'tanimoto'
        elif nodeName_ == 'binarySimilarity':
            obj_ = binarySimilarity.factory()
            obj_.build(child_)
            self.binarySimilarity = obj_
            obj_.original_tagname_ = 'binarySimilarity'
# end class ComparisonMeasure


class euclidean(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, euclidean)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if euclidean.subclass:
            return euclidean.subclass(*args_, **kwargs_)
        else:
            return euclidean(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='euclidean', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('euclidean')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='euclidean')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='euclidean', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='euclidean'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='euclidean', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='euclidean', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='euclidean'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class euclidean


class squaredEuclidean(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, squaredEuclidean)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if squaredEuclidean.subclass:
            return squaredEuclidean.subclass(*args_, **kwargs_)
        else:
            return squaredEuclidean(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='squaredEuclidean', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('squaredEuclidean')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='squaredEuclidean')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='squaredEuclidean', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='squaredEuclidean'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='squaredEuclidean', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='squaredEuclidean', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='squaredEuclidean'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class squaredEuclidean


class cityBlock(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cityBlock)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cityBlock.subclass:
            return cityBlock.subclass(*args_, **kwargs_)
        else:
            return cityBlock(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cityBlock', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cityBlock')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cityBlock')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cityBlock', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cityBlock'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cityBlock', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='cityBlock', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='cityBlock'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class cityBlock


class chebychev(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, chebychev)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if chebychev.subclass:
            return chebychev.subclass(*args_, **kwargs_)
        else:
            return chebychev(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='chebychev', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('chebychev')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='chebychev')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='chebychev', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='chebychev'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='chebychev', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='chebychev', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='chebychev'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class chebychev


class minkowski(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, p_parameter=None, Extension=None):
        self.original_tagname_ = None
        self.p_parameter = _cast(None, p_parameter)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, minkowski)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if minkowski.subclass:
            return minkowski.subclass(*args_, **kwargs_)
        else:
            return minkowski(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_p_parameter(self): return self.p_parameter
    def set_p_parameter(self, p_parameter): self.p_parameter = p_parameter
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='minkowski', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('minkowski')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='minkowski')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='minkowski', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='minkowski'):
        if self.p_parameter is not None and 'p_parameter' not in already_processed:
            already_processed.add('p_parameter')
            outfile.write(' p-parameter=%s' % (quote_attrib(self.p_parameter), ))
    def exportChildren(self, outfile, level, namespace_='', name_='minkowski', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='minkowski', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.p_parameter is not None:
            element.set('p-parameter', self.p_parameter)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='minkowski'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.p_parameter is not None and 'p_parameter' not in already_processed:
            already_processed.add('p_parameter')
            showIndent(outfile, level)
            outfile.write('p_parameter=%e,\n' % (self.p_parameter,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('p-parameter', node)
        if value is not None and 'p-parameter' not in already_processed:
            already_processed.add('p-parameter')
            try:
                self.p_parameter = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (p-parameter): %s' % exp)
            self.validate_NUMBER(self.p_parameter)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class minkowski


class simpleMatching(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, simpleMatching)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if simpleMatching.subclass:
            return simpleMatching.subclass(*args_, **kwargs_)
        else:
            return simpleMatching(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='simpleMatching', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('simpleMatching')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='simpleMatching')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='simpleMatching', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='simpleMatching'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='simpleMatching', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='simpleMatching', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='simpleMatching'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class simpleMatching


class jaccard(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, jaccard)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if jaccard.subclass:
            return jaccard.subclass(*args_, **kwargs_)
        else:
            return jaccard(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='jaccard', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('jaccard')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='jaccard')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='jaccard', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='jaccard'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='jaccard', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='jaccard', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='jaccard'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class jaccard


class tanimoto(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tanimoto)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tanimoto.subclass:
            return tanimoto.subclass(*args_, **kwargs_)
        else:
            return tanimoto(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tanimoto', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tanimoto')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tanimoto')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tanimoto', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tanimoto'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tanimoto', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='tanimoto', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='tanimoto'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class tanimoto


class binarySimilarity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, c00_parameter=None, c01_parameter=None, c10_parameter=None, c11_parameter=None, d00_parameter=None, d01_parameter=None, d10_parameter=None, d11_parameter=None, Extension=None):
        self.original_tagname_ = None
        self.c00_parameter = _cast(None, c00_parameter)
        self.c01_parameter = _cast(None, c01_parameter)
        self.c10_parameter = _cast(None, c10_parameter)
        self.c11_parameter = _cast(None, c11_parameter)
        self.d00_parameter = _cast(None, d00_parameter)
        self.d01_parameter = _cast(None, d01_parameter)
        self.d10_parameter = _cast(None, d10_parameter)
        self.d11_parameter = _cast(None, d11_parameter)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, binarySimilarity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if binarySimilarity.subclass:
            return binarySimilarity.subclass(*args_, **kwargs_)
        else:
            return binarySimilarity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_c00_parameter(self): return self.c00_parameter
    def set_c00_parameter(self, c00_parameter): self.c00_parameter = c00_parameter
    def get_c01_parameter(self): return self.c01_parameter
    def set_c01_parameter(self, c01_parameter): self.c01_parameter = c01_parameter
    def get_c10_parameter(self): return self.c10_parameter
    def set_c10_parameter(self, c10_parameter): self.c10_parameter = c10_parameter
    def get_c11_parameter(self): return self.c11_parameter
    def set_c11_parameter(self, c11_parameter): self.c11_parameter = c11_parameter
    def get_d00_parameter(self): return self.d00_parameter
    def set_d00_parameter(self, d00_parameter): self.d00_parameter = d00_parameter
    def get_d01_parameter(self): return self.d01_parameter
    def set_d01_parameter(self, d01_parameter): self.d01_parameter = d01_parameter
    def get_d10_parameter(self): return self.d10_parameter
    def set_d10_parameter(self, d10_parameter): self.d10_parameter = d10_parameter
    def get_d11_parameter(self): return self.d11_parameter
    def set_d11_parameter(self, d11_parameter): self.d11_parameter = d11_parameter
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='binarySimilarity', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('binarySimilarity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='binarySimilarity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='binarySimilarity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='binarySimilarity'):
        if self.c00_parameter is not None and 'c00_parameter' not in already_processed:
            already_processed.add('c00_parameter')
            outfile.write(' c00-parameter=%s' % (quote_attrib(self.c00_parameter), ))
        if self.c01_parameter is not None and 'c01_parameter' not in already_processed:
            already_processed.add('c01_parameter')
            outfile.write(' c01-parameter=%s' % (quote_attrib(self.c01_parameter), ))
        if self.c10_parameter is not None and 'c10_parameter' not in already_processed:
            already_processed.add('c10_parameter')
            outfile.write(' c10-parameter=%s' % (quote_attrib(self.c10_parameter), ))
        if self.c11_parameter is not None and 'c11_parameter' not in already_processed:
            already_processed.add('c11_parameter')
            outfile.write(' c11-parameter=%s' % (quote_attrib(self.c11_parameter), ))
        if self.d00_parameter is not None and 'd00_parameter' not in already_processed:
            already_processed.add('d00_parameter')
            outfile.write(' d00-parameter=%s' % (quote_attrib(self.d00_parameter), ))
        if self.d01_parameter is not None and 'd01_parameter' not in already_processed:
            already_processed.add('d01_parameter')
            outfile.write(' d01-parameter=%s' % (quote_attrib(self.d01_parameter), ))
        if self.d10_parameter is not None and 'd10_parameter' not in already_processed:
            already_processed.add('d10_parameter')
            outfile.write(' d10-parameter=%s' % (quote_attrib(self.d10_parameter), ))
        if self.d11_parameter is not None and 'd11_parameter' not in already_processed:
            already_processed.add('d11_parameter')
            outfile.write(' d11-parameter=%s' % (quote_attrib(self.d11_parameter), ))
    def exportChildren(self, outfile, level, namespace_='', name_='binarySimilarity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='binarySimilarity', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.c00_parameter is not None:
            element.set('c00-parameter', self.c00_parameter)
        if self.c01_parameter is not None:
            element.set('c01-parameter', self.c01_parameter)
        if self.c10_parameter is not None:
            element.set('c10-parameter', self.c10_parameter)
        if self.c11_parameter is not None:
            element.set('c11-parameter', self.c11_parameter)
        if self.d00_parameter is not None:
            element.set('d00-parameter', self.d00_parameter)
        if self.d01_parameter is not None:
            element.set('d01-parameter', self.d01_parameter)
        if self.d10_parameter is not None:
            element.set('d10-parameter', self.d10_parameter)
        if self.d11_parameter is not None:
            element.set('d11-parameter', self.d11_parameter)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='binarySimilarity'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.c00_parameter is not None and 'c00_parameter' not in already_processed:
            already_processed.add('c00_parameter')
            showIndent(outfile, level)
            outfile.write('c00_parameter=%e,\n' % (self.c00_parameter,))
        if self.c01_parameter is not None and 'c01_parameter' not in already_processed:
            already_processed.add('c01_parameter')
            showIndent(outfile, level)
            outfile.write('c01_parameter=%e,\n' % (self.c01_parameter,))
        if self.c10_parameter is not None and 'c10_parameter' not in already_processed:
            already_processed.add('c10_parameter')
            showIndent(outfile, level)
            outfile.write('c10_parameter=%e,\n' % (self.c10_parameter,))
        if self.c11_parameter is not None and 'c11_parameter' not in already_processed:
            already_processed.add('c11_parameter')
            showIndent(outfile, level)
            outfile.write('c11_parameter=%e,\n' % (self.c11_parameter,))
        if self.d00_parameter is not None and 'd00_parameter' not in already_processed:
            already_processed.add('d00_parameter')
            showIndent(outfile, level)
            outfile.write('d00_parameter=%e,\n' % (self.d00_parameter,))
        if self.d01_parameter is not None and 'd01_parameter' not in already_processed:
            already_processed.add('d01_parameter')
            showIndent(outfile, level)
            outfile.write('d01_parameter=%e,\n' % (self.d01_parameter,))
        if self.d10_parameter is not None and 'd10_parameter' not in already_processed:
            already_processed.add('d10_parameter')
            showIndent(outfile, level)
            outfile.write('d10_parameter=%e,\n' % (self.d10_parameter,))
        if self.d11_parameter is not None and 'd11_parameter' not in already_processed:
            already_processed.add('d11_parameter')
            showIndent(outfile, level)
            outfile.write('d11_parameter=%e,\n' % (self.d11_parameter,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('c00-parameter', node)
        if value is not None and 'c00-parameter' not in already_processed:
            already_processed.add('c00-parameter')
            try:
                self.c00_parameter = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (c00-parameter): %s' % exp)
            self.validate_NUMBER(self.c00_parameter)    # validate type NUMBER
        value = find_attr_value_('c01-parameter', node)
        if value is not None and 'c01-parameter' not in already_processed:
            already_processed.add('c01-parameter')
            try:
                self.c01_parameter = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (c01-parameter): %s' % exp)
            self.validate_NUMBER(self.c01_parameter)    # validate type NUMBER
        value = find_attr_value_('c10-parameter', node)
        if value is not None and 'c10-parameter' not in already_processed:
            already_processed.add('c10-parameter')
            try:
                self.c10_parameter = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (c10-parameter): %s' % exp)
            self.validate_NUMBER(self.c10_parameter)    # validate type NUMBER
        value = find_attr_value_('c11-parameter', node)
        if value is not None and 'c11-parameter' not in already_processed:
            already_processed.add('c11-parameter')
            try:
                self.c11_parameter = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (c11-parameter): %s' % exp)
            self.validate_NUMBER(self.c11_parameter)    # validate type NUMBER
        value = find_attr_value_('d00-parameter', node)
        if value is not None and 'd00-parameter' not in already_processed:
            already_processed.add('d00-parameter')
            try:
                self.d00_parameter = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (d00-parameter): %s' % exp)
            self.validate_NUMBER(self.d00_parameter)    # validate type NUMBER
        value = find_attr_value_('d01-parameter', node)
        if value is not None and 'd01-parameter' not in already_processed:
            already_processed.add('d01-parameter')
            try:
                self.d01_parameter = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (d01-parameter): %s' % exp)
            self.validate_NUMBER(self.d01_parameter)    # validate type NUMBER
        value = find_attr_value_('d10-parameter', node)
        if value is not None and 'd10-parameter' not in already_processed:
            already_processed.add('d10-parameter')
            try:
                self.d10_parameter = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (d10-parameter): %s' % exp)
            self.validate_NUMBER(self.d10_parameter)    # validate type NUMBER
        value = find_attr_value_('d11-parameter', node)
        if value is not None and 'd11-parameter' not in already_processed:
            already_processed.add('d11-parameter')
            try:
                self.d11_parameter = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (d11-parameter): %s' % exp)
            self.validate_NUMBER(self.d11_parameter)    # validate type NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class binarySimilarity


class GaussianProcessModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, optimizer=None, isScorable=True, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, RadialBasisKernel=None, ARDSquaredExponentialKernel=None, AbsoluteExponentialKernel=None, GeneralizedExponentialKernel=None, TrainingInstances=None, ModelVerification=None, Extension=None):
        self.original_tagname_ = None
        self.modelName = _cast(None, modelName)
        self.functionName = _cast(None, functionName)
        self.algorithmName = _cast(None, algorithmName)
        self.optimizer = _cast(None, optimizer)
        self.isScorable = _cast(bool, isScorable)
        self.MiningSchema = MiningSchema
        self.Output = Output
        self.ModelStats = ModelStats
        self.ModelExplanation = ModelExplanation
        self.Targets = Targets
        self.LocalTransformations = LocalTransformations
        self.RadialBasisKernel = RadialBasisKernel
        self.ARDSquaredExponentialKernel = ARDSquaredExponentialKernel
        self.AbsoluteExponentialKernel = AbsoluteExponentialKernel
        self.GeneralizedExponentialKernel = GeneralizedExponentialKernel
        self.TrainingInstances = TrainingInstances
        self.ModelVerification = ModelVerification
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GaussianProcessModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GaussianProcessModel.subclass:
            return GaussianProcessModel.subclass(*args_, **kwargs_)
        else:
            return GaussianProcessModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MiningSchema(self): return self.MiningSchema
    def set_MiningSchema(self, MiningSchema): self.MiningSchema = MiningSchema
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def get_ModelStats(self): return self.ModelStats
    def set_ModelStats(self, ModelStats): self.ModelStats = ModelStats
    def get_ModelExplanation(self): return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation): self.ModelExplanation = ModelExplanation
    def get_Targets(self): return self.Targets
    def set_Targets(self, Targets): self.Targets = Targets
    def get_LocalTransformations(self): return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations): self.LocalTransformations = LocalTransformations
    def get_RadialBasisKernel(self): return self.RadialBasisKernel
    def set_RadialBasisKernel(self, RadialBasisKernel): self.RadialBasisKernel = RadialBasisKernel
    def get_ARDSquaredExponentialKernel(self): return self.ARDSquaredExponentialKernel
    def set_ARDSquaredExponentialKernel(self, ARDSquaredExponentialKernel): self.ARDSquaredExponentialKernel = ARDSquaredExponentialKernel
    def get_AbsoluteExponentialKernel(self): return self.AbsoluteExponentialKernel
    def set_AbsoluteExponentialKernel(self, AbsoluteExponentialKernel): self.AbsoluteExponentialKernel = AbsoluteExponentialKernel
    def get_GeneralizedExponentialKernel(self): return self.GeneralizedExponentialKernel
    def set_GeneralizedExponentialKernel(self, GeneralizedExponentialKernel): self.GeneralizedExponentialKernel = GeneralizedExponentialKernel
    def get_TrainingInstances(self): return self.TrainingInstances
    def set_TrainingInstances(self, TrainingInstances): self.TrainingInstances = TrainingInstances
    def get_ModelVerification(self): return self.ModelVerification
    def set_ModelVerification(self, ModelVerification): self.ModelVerification = ModelVerification
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_modelName(self): return self.modelName
    def set_modelName(self, modelName): self.modelName = modelName
    def get_functionName(self): return self.functionName
    def set_functionName(self, functionName): self.functionName = functionName
    def get_algorithmName(self): return self.algorithmName
    def set_algorithmName(self, algorithmName): self.algorithmName = algorithmName
    def get_optimizer(self): return self.optimizer
    def set_optimizer(self, optimizer): self.optimizer = optimizer
    def get_isScorable(self): return self.isScorable
    def set_isScorable(self, isScorable): self.isScorable = isScorable
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.RadialBasisKernel is not None or
            self.ARDSquaredExponentialKernel is not None or
            self.AbsoluteExponentialKernel is not None or
            self.GeneralizedExponentialKernel is not None or
            self.TrainingInstances is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GaussianProcessModel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GaussianProcessModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GaussianProcessModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GaussianProcessModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GaussianProcessModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (quote_attrib(self.functionName), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.optimizer is not None and 'optimizer' not in already_processed:
            already_processed.add('optimizer')
            outfile.write(' optimizer=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.optimizer), input_name='optimizer')), ))
        if not self.isScorable and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            outfile.write(' isScorable="%s"' % self.gds_format_boolean(self.isScorable, input_name='isScorable'))
    def exportChildren(self, outfile, level, namespace_='', name_='GaussianProcessModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            self.MiningSchema.export(outfile, level, namespace_, name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            self.Output.export(outfile, level, namespace_, name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            self.ModelStats.export(outfile, level, namespace_, name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            self.ModelExplanation.export(outfile, level, namespace_, name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            self.Targets.export(outfile, level, namespace_, name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            self.LocalTransformations.export(outfile, level, namespace_, name_='LocalTransformations', pretty_print=pretty_print)
        if self.RadialBasisKernel is not None:
            self.RadialBasisKernel.export(outfile, level, namespace_, name_='RadialBasisKernel', pretty_print=pretty_print)
        if self.ARDSquaredExponentialKernel is not None:
            self.ARDSquaredExponentialKernel.export(outfile, level, namespace_, name_='ARDSquaredExponentialKernel', pretty_print=pretty_print)
        if self.AbsoluteExponentialKernel is not None:
            self.AbsoluteExponentialKernel.export(outfile, level, namespace_, name_='AbsoluteExponentialKernel', pretty_print=pretty_print)
        if self.GeneralizedExponentialKernel is not None:
            self.GeneralizedExponentialKernel.export(outfile, level, namespace_, name_='GeneralizedExponentialKernel', pretty_print=pretty_print)
        if self.TrainingInstances is not None:
            self.TrainingInstances.export(outfile, level, namespace_, name_='TrainingInstances', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            self.ModelVerification.export(outfile, level, namespace_, name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GaussianProcessModel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.modelName is not None:
            element.set('modelName', self.gds_format_string(self.modelName))
        if self.functionName is not None:
            element.set('functionName', self.functionName)
        if self.algorithmName is not None:
            element.set('algorithmName', self.gds_format_string(self.algorithmName))
        if self.optimizer is not None:
            element.set('optimizer', self.gds_format_string(self.optimizer))
        if self.isScorable is not None:
            element.set('isScorable', self.gds_format_boolean(self.isScorable))
        if self.MiningSchema is not None:
            MiningSchema_ = self.MiningSchema
            MiningSchema_.to_etree(element, name_='MiningSchema', mapping_=mapping_)
        if self.Output is not None:
            Output_ = self.Output
            Output_.to_etree(element, name_='Output', mapping_=mapping_)
        if self.ModelStats is not None:
            ModelStats_ = self.ModelStats
            ModelStats_.to_etree(element, name_='ModelStats', mapping_=mapping_)
        if self.ModelExplanation is not None:
            ModelExplanation_ = self.ModelExplanation
            ModelExplanation_.to_etree(element, name_='ModelExplanation', mapping_=mapping_)
        if self.Targets is not None:
            Targets_ = self.Targets
            Targets_.to_etree(element, name_='Targets', mapping_=mapping_)
        if self.LocalTransformations is not None:
            LocalTransformations_ = self.LocalTransformations
            LocalTransformations_.to_etree(element, name_='LocalTransformations', mapping_=mapping_)
        if self.RadialBasisKernel is not None:
            RadialBasisKernel_ = self.RadialBasisKernel
            RadialBasisKernel_.to_etree(element, name_='RadialBasisKernel', mapping_=mapping_)
        if self.ARDSquaredExponentialKernel is not None:
            ARDSquaredExponentialKernel_ = self.ARDSquaredExponentialKernel
            ARDSquaredExponentialKernel_.to_etree(element, name_='ARDSquaredExponentialKernel', mapping_=mapping_)
        if self.AbsoluteExponentialKernel is not None:
            AbsoluteExponentialKernel_ = self.AbsoluteExponentialKernel
            AbsoluteExponentialKernel_.to_etree(element, name_='AbsoluteExponentialKernel', mapping_=mapping_)
        if self.GeneralizedExponentialKernel is not None:
            GeneralizedExponentialKernel_ = self.GeneralizedExponentialKernel
            GeneralizedExponentialKernel_.to_etree(element, name_='GeneralizedExponentialKernel', mapping_=mapping_)
        if self.TrainingInstances is not None:
            TrainingInstances_ = self.TrainingInstances
            TrainingInstances_.to_etree(element, name_='TrainingInstances', mapping_=mapping_)
        if self.ModelVerification is not None:
            ModelVerification_ = self.ModelVerification
            ModelVerification_.to_etree(element, name_='ModelVerification', mapping_=mapping_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='GaussianProcessModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            showIndent(outfile, level)
            outfile.write('modelName="%s",\n' % (self.modelName,))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            showIndent(outfile, level)
            outfile.write('functionName="%s",\n' % (self.functionName,))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            showIndent(outfile, level)
            outfile.write('algorithmName="%s",\n' % (self.algorithmName,))
        if self.optimizer is not None and 'optimizer' not in already_processed:
            already_processed.add('optimizer')
            showIndent(outfile, level)
            outfile.write('optimizer="%s",\n' % (self.optimizer,))
        if self.isScorable is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            showIndent(outfile, level)
            outfile.write('isScorable=%s,\n' % (self.isScorable,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MiningSchema is not None:
            showIndent(outfile, level)
            outfile.write('MiningSchema=model_.MiningSchema(\n')
            self.MiningSchema.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Output is not None:
            showIndent(outfile, level)
            outfile.write('Output=model_.Output(\n')
            self.Output.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelStats is not None:
            showIndent(outfile, level)
            outfile.write('ModelStats=model_.ModelStats(\n')
            self.ModelStats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelExplanation is not None:
            showIndent(outfile, level)
            outfile.write('ModelExplanation=model_.ModelExplanation(\n')
            self.ModelExplanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Targets is not None:
            showIndent(outfile, level)
            outfile.write('Targets=model_.Targets(\n')
            self.Targets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalTransformations is not None:
            showIndent(outfile, level)
            outfile.write('LocalTransformations=model_.LocalTransformations(\n')
            self.LocalTransformations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RadialBasisKernel is not None:
            showIndent(outfile, level)
            outfile.write('RadialBasisKernel=model_.RadialBasisKernel(\n')
            self.RadialBasisKernel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ARDSquaredExponentialKernel is not None:
            showIndent(outfile, level)
            outfile.write('ARDSquaredExponentialKernel=model_.ARDSquaredExponentialKernel(\n')
            self.ARDSquaredExponentialKernel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AbsoluteExponentialKernel is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExponentialKernel=model_.AbsoluteExponentialKernel(\n')
            self.AbsoluteExponentialKernel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GeneralizedExponentialKernel is not None:
            showIndent(outfile, level)
            outfile.write('GeneralizedExponentialKernel=model_.GeneralizedExponentialKernel(\n')
            self.GeneralizedExponentialKernel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TrainingInstances is not None:
            showIndent(outfile, level)
            outfile.write('TrainingInstances=model_.TrainingInstances(\n')
            self.TrainingInstances.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModelVerification is not None:
            showIndent(outfile, level)
            outfile.write('ModelVerification=model_.ModelVerification(\n')
            self.ModelVerification.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('optimizer', node)
        if value is not None and 'optimizer' not in already_processed:
            already_processed.add('optimizer')
            self.optimizer = value
        value = find_attr_value_('isScorable', node)
        if value is not None and 'isScorable' not in already_processed:
            already_processed.add('isScorable')
            if value in ('true', '1'):
                self.isScorable = True
            elif value in ('false', '0'):
                self.isScorable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory()
            obj_.build(child_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory()
            obj_.build(child_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory()
            obj_.build(child_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory()
            obj_.build(child_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory()
            obj_.build(child_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory()
            obj_.build(child_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'RadialBasisKernel':
            obj_ = RadialBasisKernel.factory()
            obj_.build(child_)
            self.RadialBasisKernel = obj_
            obj_.original_tagname_ = 'RadialBasisKernel'
        elif nodeName_ == 'ARDSquaredExponentialKernel':
            obj_ = ARDSquaredExponentialKernel.factory()
            obj_.build(child_)
            self.ARDSquaredExponentialKernel = obj_
            obj_.original_tagname_ = 'ARDSquaredExponentialKernel'
        elif nodeName_ == 'AbsoluteExponentialKernel':
            obj_ = AbsoluteExponentialKernel.factory()
            obj_.build(child_)
            self.AbsoluteExponentialKernel = obj_
            obj_.original_tagname_ = 'AbsoluteExponentialKernel'
        elif nodeName_ == 'GeneralizedExponentialKernel':
            obj_ = GeneralizedExponentialKernel.factory()
            obj_.build(child_)
            self.GeneralizedExponentialKernel = obj_
            obj_.original_tagname_ = 'GeneralizedExponentialKernel'
        elif nodeName_ == 'TrainingInstances':
            obj_ = TrainingInstances.factory()
            obj_.build(child_)
            self.TrainingInstances = obj_
            obj_.original_tagname_ = 'TrainingInstances'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory()
            obj_.build(child_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class GaussianProcessModel


class RadialBasisKernel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, gamma='1', noiseVariance='1', lambda_='1', Extension=None):
        self.original_tagname_ = None
        self.description = _cast(None, description)
        self.gamma = _cast(None, gamma)
        self.noiseVariance = _cast(None, noiseVariance)
        self.lambda_ = _cast(None, lambda_)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RadialBasisKernel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RadialBasisKernel.subclass:
            return RadialBasisKernel.subclass(*args_, **kwargs_)
        else:
            return RadialBasisKernel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_gamma(self): return self.gamma
    def set_gamma(self, gamma): self.gamma = gamma
    def get_noiseVariance(self): return self.noiseVariance
    def set_noiseVariance(self, noiseVariance): self.noiseVariance = noiseVariance
    def get_lambda(self): return self.lambda_
    def set_lambda(self, lambda_): self.lambda_ = lambda_
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RadialBasisKernel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RadialBasisKernel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RadialBasisKernel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RadialBasisKernel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RadialBasisKernel'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.gamma != 1 and 'gamma' not in already_processed:
            already_processed.add('gamma')
            outfile.write(' gamma=%s' % (quote_attrib(self.gamma), ))
        if self.noiseVariance != 1 and 'noiseVariance' not in already_processed:
            already_processed.add('noiseVariance')
            outfile.write(' noiseVariance=%s' % (quote_attrib(self.noiseVariance), ))
        if self.lambda_ != 1 and 'lambda_' not in already_processed:
            already_processed.add('lambda_')
            outfile.write(' lambda=%s' % (quote_attrib(self.lambda_), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RadialBasisKernel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='RadialBasisKernel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        if self.gamma is not None:
            element.set('gamma', self.gamma)
        if self.noiseVariance is not None:
            element.set('noiseVariance', self.noiseVariance)
        if self.lambda_ is not None:
            element.set('lambda', self.lambda_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='RadialBasisKernel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            showIndent(outfile, level)
            outfile.write('description="%s",\n' % (self.description,))
        if self.gamma is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            showIndent(outfile, level)
            outfile.write('gamma=%e,\n' % (self.gamma,))
        if self.noiseVariance is not None and 'noiseVariance' not in already_processed:
            already_processed.add('noiseVariance')
            showIndent(outfile, level)
            outfile.write('noiseVariance=%e,\n' % (self.noiseVariance,))
        if self.lambda_ is not None and 'lambda_' not in already_processed:
            already_processed.add('lambda_')
            showIndent(outfile, level)
            outfile.write('lambda_=%e,\n' % (self.lambda_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('gamma', node)
        if value is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            try:
                self.gamma = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (gamma): %s' % exp)
            self.validate_REAL_NUMBER(self.gamma)    # validate type REAL-NUMBER
        value = find_attr_value_('noiseVariance', node)
        if value is not None and 'noiseVariance' not in already_processed:
            already_processed.add('noiseVariance')
            try:
                self.noiseVariance = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (noiseVariance): %s' % exp)
            self.validate_REAL_NUMBER(self.noiseVariance)    # validate type REAL-NUMBER
        value = find_attr_value_('lambda', node)
        if value is not None and 'lambda' not in already_processed:
            already_processed.add('lambda')
            try:
                self.lambda_ = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lambda): %s' % exp)
            self.validate_REAL_NUMBER(self.lambda_)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class RadialBasisKernel


class ARDSquaredExponentialKernel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, gamma='1', noiseVariance='1', Extension=None, Lambda=None):
        self.original_tagname_ = None
        self.description = _cast(None, description)
        self.gamma = _cast(None, gamma)
        self.noiseVariance = _cast(None, noiseVariance)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Lambda is None:
            self.Lambda = []
        else:
            self.Lambda = Lambda
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ARDSquaredExponentialKernel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ARDSquaredExponentialKernel.subclass:
            return ARDSquaredExponentialKernel.subclass(*args_, **kwargs_)
        else:
            return ARDSquaredExponentialKernel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Lambda(self): return self.Lambda
    def set_Lambda(self, Lambda): self.Lambda = Lambda
    def add_Lambda(self, value): self.Lambda.append(value)
    def insert_Lambda_at(self, index, value): self.Lambda.insert(index, value)
    def replace_Lambda_at(self, index, value): self.Lambda[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_gamma(self): return self.gamma
    def set_gamma(self, gamma): self.gamma = gamma
    def get_noiseVariance(self): return self.noiseVariance
    def set_noiseVariance(self, noiseVariance): self.noiseVariance = noiseVariance
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Lambda
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ARDSquaredExponentialKernel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ARDSquaredExponentialKernel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ARDSquaredExponentialKernel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ARDSquaredExponentialKernel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ARDSquaredExponentialKernel'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.gamma != 1 and 'gamma' not in already_processed:
            already_processed.add('gamma')
            outfile.write(' gamma=%s' % (quote_attrib(self.gamma), ))
        if self.noiseVariance != 1 and 'noiseVariance' not in already_processed:
            already_processed.add('noiseVariance')
            outfile.write(' noiseVariance=%s' % (quote_attrib(self.noiseVariance), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ARDSquaredExponentialKernel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Lambda_ in self.Lambda:
            Lambda_.export(outfile, level, namespace_, name_='Lambda', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ARDSquaredExponentialKernel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        if self.gamma is not None:
            element.set('gamma', self.gamma)
        if self.noiseVariance is not None:
            element.set('noiseVariance', self.noiseVariance)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Lambda_ in self.Lambda:
            Lambda_.to_etree(element, name_='Lambda', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='ARDSquaredExponentialKernel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            showIndent(outfile, level)
            outfile.write('description="%s",\n' % (self.description,))
        if self.gamma is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            showIndent(outfile, level)
            outfile.write('gamma=%e,\n' % (self.gamma,))
        if self.noiseVariance is not None and 'noiseVariance' not in already_processed:
            already_processed.add('noiseVariance')
            showIndent(outfile, level)
            outfile.write('noiseVariance=%e,\n' % (self.noiseVariance,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Lambda=[\n')
        level += 1
        for Lambda_ in self.Lambda:
            showIndent(outfile, level)
            outfile.write('model_.Lambda(\n')
            Lambda_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('gamma', node)
        if value is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            try:
                self.gamma = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (gamma): %s' % exp)
            self.validate_REAL_NUMBER(self.gamma)    # validate type REAL-NUMBER
        value = find_attr_value_('noiseVariance', node)
        if value is not None and 'noiseVariance' not in already_processed:
            already_processed.add('noiseVariance')
            try:
                self.noiseVariance = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (noiseVariance): %s' % exp)
            self.validate_REAL_NUMBER(self.noiseVariance)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Lambda':
            obj_ = Lambda.factory()
            obj_.build(child_)
            self.Lambda.append(obj_)
            obj_.original_tagname_ = 'Lambda'
# end class ARDSquaredExponentialKernel


class AbsoluteExponentialKernel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, gamma='1', noiseVariance='1', Extension=None, Lambda=None):
        self.original_tagname_ = None
        self.description = _cast(None, description)
        self.gamma = _cast(None, gamma)
        self.noiseVariance = _cast(None, noiseVariance)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Lambda is None:
            self.Lambda = []
        else:
            self.Lambda = Lambda
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbsoluteExponentialKernel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbsoluteExponentialKernel.subclass:
            return AbsoluteExponentialKernel.subclass(*args_, **kwargs_)
        else:
            return AbsoluteExponentialKernel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Lambda(self): return self.Lambda
    def set_Lambda(self, Lambda): self.Lambda = Lambda
    def add_Lambda(self, value): self.Lambda.append(value)
    def insert_Lambda_at(self, index, value): self.Lambda.insert(index, value)
    def replace_Lambda_at(self, index, value): self.Lambda[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_gamma(self): return self.gamma
    def set_gamma(self, gamma): self.gamma = gamma
    def get_noiseVariance(self): return self.noiseVariance
    def set_noiseVariance(self, noiseVariance): self.noiseVariance = noiseVariance
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Lambda
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AbsoluteExponentialKernel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbsoluteExponentialKernel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbsoluteExponentialKernel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AbsoluteExponentialKernel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbsoluteExponentialKernel'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.gamma != 1 and 'gamma' not in already_processed:
            already_processed.add('gamma')
            outfile.write(' gamma=%s' % (quote_attrib(self.gamma), ))
        if self.noiseVariance != 1 and 'noiseVariance' not in already_processed:
            already_processed.add('noiseVariance')
            outfile.write(' noiseVariance=%s' % (quote_attrib(self.noiseVariance), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AbsoluteExponentialKernel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Lambda_ in self.Lambda:
            Lambda_.export(outfile, level, namespace_, name_='Lambda', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AbsoluteExponentialKernel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        if self.gamma is not None:
            element.set('gamma', self.gamma)
        if self.noiseVariance is not None:
            element.set('noiseVariance', self.noiseVariance)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Lambda_ in self.Lambda:
            Lambda_.to_etree(element, name_='Lambda', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='AbsoluteExponentialKernel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            showIndent(outfile, level)
            outfile.write('description="%s",\n' % (self.description,))
        if self.gamma is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            showIndent(outfile, level)
            outfile.write('gamma=%e,\n' % (self.gamma,))
        if self.noiseVariance is not None and 'noiseVariance' not in already_processed:
            already_processed.add('noiseVariance')
            showIndent(outfile, level)
            outfile.write('noiseVariance=%e,\n' % (self.noiseVariance,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Lambda=[\n')
        level += 1
        for Lambda_ in self.Lambda:
            showIndent(outfile, level)
            outfile.write('model_.Lambda(\n')
            Lambda_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('gamma', node)
        if value is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            try:
                self.gamma = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (gamma): %s' % exp)
            self.validate_REAL_NUMBER(self.gamma)    # validate type REAL-NUMBER
        value = find_attr_value_('noiseVariance', node)
        if value is not None and 'noiseVariance' not in already_processed:
            already_processed.add('noiseVariance')
            try:
                self.noiseVariance = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (noiseVariance): %s' % exp)
            self.validate_REAL_NUMBER(self.noiseVariance)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Lambda':
            obj_ = Lambda.factory()
            obj_.build(child_)
            self.Lambda.append(obj_)
            obj_.original_tagname_ = 'Lambda'
# end class AbsoluteExponentialKernel


class GeneralizedExponentialKernel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, gamma='1', noiseVariance='1', degree='1', Extension=None, Lambda=None):
        self.original_tagname_ = None
        self.description = _cast(None, description)
        self.gamma = _cast(None, gamma)
        self.noiseVariance = _cast(None, noiseVariance)
        self.degree = _cast(None, degree)
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        if Lambda is None:
            self.Lambda = []
        else:
            self.Lambda = Lambda
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralizedExponentialKernel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralizedExponentialKernel.subclass:
            return GeneralizedExponentialKernel.subclass(*args_, **kwargs_)
        else:
            return GeneralizedExponentialKernel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Lambda(self): return self.Lambda
    def set_Lambda(self, Lambda): self.Lambda = Lambda
    def add_Lambda(self, value): self.Lambda.append(value)
    def insert_Lambda_at(self, index, value): self.Lambda.insert(index, value)
    def replace_Lambda_at(self, index, value): self.Lambda[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_gamma(self): return self.gamma
    def set_gamma(self, gamma): self.gamma = gamma
    def get_noiseVariance(self): return self.noiseVariance
    def set_noiseVariance(self, noiseVariance): self.noiseVariance = noiseVariance
    def get_degree(self): return self.degree
    def set_degree(self, degree): self.degree = degree
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Extension or
            self.Lambda
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GeneralizedExponentialKernel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeneralizedExponentialKernel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeneralizedExponentialKernel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GeneralizedExponentialKernel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeneralizedExponentialKernel'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.gamma != 1 and 'gamma' not in already_processed:
            already_processed.add('gamma')
            outfile.write(' gamma=%s' % (quote_attrib(self.gamma), ))
        if self.noiseVariance != 1 and 'noiseVariance' not in already_processed:
            already_processed.add('noiseVariance')
            outfile.write(' noiseVariance=%s' % (quote_attrib(self.noiseVariance), ))
        if self.degree != 1 and 'degree' not in already_processed:
            already_processed.add('degree')
            outfile.write(' degree=%s' % (quote_attrib(self.degree), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GeneralizedExponentialKernel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        for Lambda_ in self.Lambda:
            Lambda_.export(outfile, level, namespace_, name_='Lambda', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GeneralizedExponentialKernel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        if self.gamma is not None:
            element.set('gamma', self.gamma)
        if self.noiseVariance is not None:
            element.set('noiseVariance', self.noiseVariance)
        if self.degree is not None:
            element.set('degree', self.degree)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        for Lambda_ in self.Lambda:
            Lambda_.to_etree(element, name_='Lambda', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='GeneralizedExponentialKernel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            showIndent(outfile, level)
            outfile.write('description="%s",\n' % (self.description,))
        if self.gamma is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            showIndent(outfile, level)
            outfile.write('gamma=%e,\n' % (self.gamma,))
        if self.noiseVariance is not None and 'noiseVariance' not in already_processed:
            already_processed.add('noiseVariance')
            showIndent(outfile, level)
            outfile.write('noiseVariance=%e,\n' % (self.noiseVariance,))
        if self.degree is not None and 'degree' not in already_processed:
            already_processed.add('degree')
            showIndent(outfile, level)
            outfile.write('degree=%e,\n' % (self.degree,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Lambda=[\n')
        level += 1
        for Lambda_ in self.Lambda:
            showIndent(outfile, level)
            outfile.write('model_.Lambda(\n')
            Lambda_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('gamma', node)
        if value is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            try:
                self.gamma = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (gamma): %s' % exp)
            self.validate_REAL_NUMBER(self.gamma)    # validate type REAL-NUMBER
        value = find_attr_value_('noiseVariance', node)
        if value is not None and 'noiseVariance' not in already_processed:
            already_processed.add('noiseVariance')
            try:
                self.noiseVariance = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (noiseVariance): %s' % exp)
            self.validate_REAL_NUMBER(self.noiseVariance)    # validate type REAL-NUMBER
        value = find_attr_value_('degree', node)
        if value is not None and 'degree' not in already_processed:
            already_processed.add('degree')
            try:
                self.degree = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (degree): %s' % exp)
            self.validate_REAL_NUMBER(self.degree)    # validate type REAL-NUMBER
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Lambda':
            obj_ = Lambda.factory()
            obj_.build(child_)
            self.Lambda.append(obj_)
            obj_.original_tagname_ = 'Lambda'
# end class GeneralizedExponentialKernel


class Lambda(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None):
        self.original_tagname_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Array = Array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Lambda)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Lambda.subclass:
            return Lambda.subclass(*args_, **kwargs_)
        else:
            return Lambda(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def add_Extension(self, value): self.Extension.append(value)
    def insert_Extension_at(self, index, value): self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value): self.Extension[index] = value
    def get_Array(self): return self.Array
    def set_Array(self, Array): self.Array = Array
    def hasContent_(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Lambda', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Lambda')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Lambda')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Lambda', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Lambda'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Lambda', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            Extension_.export(outfile, level, namespace_, name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            self.Array.export(outfile, level, namespace_, name_='Array', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Lambda', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.dmg.org/PMML-4_4}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.dmg.org/PMML-4_4}' + name_)
        for Extension_ in self.Extension:
            Extension_.to_etree(element, name_='Extension', mapping_=mapping_)
        if self.Array is not None:
            Array_ = self.Array
            Array_.to_etree(element, name_='Array', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def exportLiteral(self, outfile, level, name_='Lambda'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Extension=[\n')
        level += 1
        for Extension_ in self.Extension:
            showIndent(outfile, level)
            outfile.write('model_.Extension(\n')
            Extension_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Array is not None:
            showIndent(outfile, level)
            outfile.write('Array=model_.Array(\n')
            self.Array.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory()
            obj_.build(child_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory()
            obj_.build(child_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class Lambda


GDSClassesMapping = {
    'Array': ArrayType,
    'CountTable': COUNT_TABLE_TYPE,
    'NormalizedCountTable': COUNT_TABLE_TYPE,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DefineFunction'
        rootClass = DefineFunction
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DefineFunction'
        rootClass = DefineFunction
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DefineFunction'
        rootClass = DefineFunction
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DefineFunction'
        rootClass = DefineFunction
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from pmml44Super import *\n\n')
        sys.stdout.write('import pmml44Super as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AR",
    "ARDSquaredExponentialKernel",
    "ARIMA",
    "ARMAPart",
    "AbsoluteExponentialKernel",
    "Aggregate",
    "Alternate",
    "Annotation",
    "AnomalyDetectionModel",
    "Anova",
    "AnovaRow",
    "AntecedentSequence",
    "AnyDistribution",
    "Application",
    "Apply",
    "ArrayType",
    "AssociationModel",
    "AssociationRule",
    "Attribute",
    "BaseCumHazardTables",
    "Baseline",
    "BaselineCell",
    "BaselineModel",
    "BaselineStratum",
    "BayesInput",
    "BayesInputs",
    "BayesOutput",
    "BayesianNetworkModel",
    "BayesianNetworkNodes",
    "BlockIndicator",
    "BoundaryValueMeans",
    "BoundaryValues",
    "COUNT_TABLE_TYPE",
    "CategoricalPredictor",
    "Categories",
    "Category",
    "Characteristic",
    "Characteristics",
    "ChildParent",
    "ClassLabels",
    "Cluster",
    "ClusteringField",
    "ClusteringModel",
    "ClusteringModelQuality",
    "Coefficient",
    "Coefficients",
    "ComparisonMeasure",
    "Comparisons",
    "ComplexPartialScore",
    "CompoundPredicate",
    "CompoundRule",
    "Con",
    "ConfusionMatrix",
    "ConsequentSequence",
    "Constant",
    "Constraints",
    "ContStats",
    "ContinuousConditionalProbability",
    "ContinuousDistribution",
    "ContinuousNode",
    "CorrelationFields",
    "CorrelationMethods",
    "CorrelationValues",
    "Correlations",
    "Counts",
    "Covariances",
    "CovariateList",
    "DataDictionary",
    "DataField",
    "Decision",
    "DecisionTree",
    "Decisions",
    "DefineFunction",
    "Delimiter",
    "Denominator",
    "DerivedField",
    "DiscrStats",
    "DiscreteConditionalProbability",
    "DiscreteNode",
    "Discretize",
    "DiscretizeBin",
    "DocumentTermMatrix",
    "DynamicRegressor",
    "EventValues",
    "ExponentialSmoothing",
    "Extension",
    "FactorList",
    "False_",
    "FieldColumnPair",
    "FieldRef",
    "FieldValue",
    "FieldValueCount",
    "FinalNoise",
    "FinalNu",
    "FinalOmega",
    "FinalPredictedNoise",
    "FinalStateVector",
    "FinalTheta",
    "GARCH",
    "GARCHPart",
    "GaussianDistribution",
    "GaussianProcessModel",
    "GeneralRegressionModel",
    "GeneralizedExponentialKernel",
    "HVector",
    "Header",
    "INT_Entries",
    "INT_SparseArray",
    "Indices",
    "InlineTable",
    "InstanceField",
    "InstanceFields",
    "InterceptVector",
    "Interval",
    "Item",
    "ItemRef",
    "Itemset",
    "KNNInput",
    "KNNInputs",
    "KalmanState",
    "KohonenMap",
    "Lag",
    "Lambda",
    "Level",
    "LiftData",
    "LiftGraph",
    "LinearKernelType",
    "LinearNorm",
    "LocalTransformations",
    "LognormalDistributionForBN",
    "Lower",
    "MA",
    "MACoefficients",
    "MapValues",
    "MatCell",
    "Matrix",
    "MaximumLikelihoodStat",
    "Mean",
    "MeanClusterDistances",
    "MeasurementMatrix",
    "MiningBuildTask",
    "MiningField",
    "MiningModel",
    "MiningSchema",
    "MissingValueWeights",
    "ModelExplanation",
    "ModelLiftGraph",
    "ModelStats",
    "ModelVerification",
    "MultivariateStat",
    "MultivariateStats",
    "NaiveBayesModel",
    "NearestNeighborModel",
    "NeuralInput",
    "NeuralInputs",
    "NeuralLayer",
    "NeuralNetwork",
    "NeuralOutput",
    "NeuralOutputs",
    "Neuron",
    "Node",
    "NonseasonalComponent",
    "NonseasonalFactor",
    "NormContinuous",
    "NormDiscrete",
    "NormalDistributionForBN",
    "Numerator",
    "NumericInfo",
    "NumericPredictor",
    "ObservationVarianceMatrix",
    "OptimumLiftGraph",
    "OutlierEffect",
    "Output",
    "OutputField",
    "PCell",
    "PCovCell",
    "PCovMatrix",
    "PMML",
    "PPCell",
    "PPMatrix",
    "PairCounts",
    "ParamMatrix",
    "Parameter",
    "ParameterField",
    "ParameterList",
    "ParentValue",
    "Partition",
    "PartitionFieldStats",
    "PastVariances",
    "PoissonDistribution",
    "PolynomialKernelType",
    "PredictedStateCovarianceMatrix",
    "PredictiveModelQuality",
    "Predictor",
    "PredictorTerm",
    "PsiVector",
    "Quantile",
    "REAL_Entries",
    "REAL_SparseArray",
    "ROC",
    "ROCGraph",
    "RadialBasisKernel",
    "RadialBasisKernelType",
    "RandomLiftGraph",
    "Regression",
    "RegressionModel",
    "RegressionTable",
    "RegressorValues",
    "ResidualSquareCoefficients",
    "Residuals",
    "ResultField",
    "RuleSelectionMethod",
    "RuleSet",
    "RuleSetModel",
    "ScoreDistribution",
    "Scorecard",
    "SeasonalComponent",
    "SeasonalFactor",
    "SeasonalTrendDecomposition",
    "Seasonality_ExpoSmooth",
    "Segment",
    "Segmentation",
    "SelectedStateCovarianceMatrix",
    "Sequence",
    "SequenceModel",
    "SequenceReference",
    "SequenceRule",
    "SetPredicate",
    "SetReference",
    "SigmoidKernelType",
    "SimplePredicate",
    "SimpleRule",
    "SimpleSetPredicate",
    "SpectralAnalysis",
    "StateSpaceModel",
    "StateVector",
    "SupportVector",
    "SupportVectorMachine",
    "SupportVectorMachineModel",
    "SupportVectors",
    "TableLocator",
    "Target",
    "TargetValue",
    "TargetValueCount",
    "TargetValueCounts",
    "TargetValueStat",
    "TargetValueStats",
    "Targets",
    "Taxonomy",
    "TestDistributions",
    "TextCorpus",
    "TextDictionary",
    "TextDocument",
    "TextIndex",
    "TextIndexNormalization",
    "TextModel",
    "TextModelNormalization",
    "TextModelSimiliarity",
    "Theta",
    "ThetaRecursionState",
    "Time",
    "TimeAnchor",
    "TimeCycle",
    "TimeException",
    "TimeSeries",
    "TimeSeriesModel",
    "TimeValue",
    "Timestamp",
    "TrainingInstances",
    "TransferFunctionValues",
    "TransformationDictionary",
    "TransitionMatrix",
    "TreeModel",
    "TrendCoefficients",
    "Trend_ExpoSmooth",
    "TriangularDistributionForBN",
    "True_",
    "UniformDistribution",
    "UniformDistributionForBN",
    "UnivariateStats",
    "Upper",
    "Value",
    "ValueProbability",
    "VariableWeight",
    "Variance",
    "VarianceCoefficients",
    "VectorDictionary",
    "VectorFields",
    "VectorInstance",
    "VerificationField",
    "VerificationFields",
    "XCoordinates",
    "YCoordinates",
    "binarySimilarity",
    "chebychev",
    "cityBlock",
    "euclidean",
    "jaccard",
    "minkowski",
    "row",
    "simpleMatching",
    "squaredEuclidean",
    "tanimoto"
]
